/* automatically generated by rust-bindgen 0.60.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __uint64_t = ::std::os::raw::c_ulong;
    pub type __intmax_t = ::std::os::raw::c_long;
    pub type intmax_t = root::__intmax_t;
    pub mod rev {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const REVLibError_kOk: root::rev::REVLibError = 0;
        pub const REVLibError_kError: root::rev::REVLibError = 1;
        pub const REVLibError_kTimeout: root::rev::REVLibError = 2;
        pub const REVLibError_kNotImplemented: root::rev::REVLibError = 3;
        pub const REVLibError_kHALError: root::rev::REVLibError = 4;
        pub const REVLibError_kCantFindFirmware: root::rev::REVLibError = 5;
        pub const REVLibError_kFirmwareTooOld: root::rev::REVLibError = 6;
        pub const REVLibError_kFirmwareTooNew: root::rev::REVLibError = 7;
        pub const REVLibError_kParamInvalidID: root::rev::REVLibError = 8;
        pub const REVLibError_kParamMismatchType: root::rev::REVLibError = 9;
        pub const REVLibError_kParamAccessMode: root::rev::REVLibError = 10;
        pub const REVLibError_kParamInvalid: root::rev::REVLibError = 11;
        pub const REVLibError_kParamNotImplementedDeprecated: root::rev::REVLibError = 12;
        pub const REVLibError_kFollowConfigMismatch: root::rev::REVLibError = 13;
        pub const REVLibError_kInvalid: root::rev::REVLibError = 14;
        pub const REVLibError_kSetpointOutOfRange: root::rev::REVLibError = 15;
        pub const REVLibError_kUnknown: root::rev::REVLibError = 16;
        pub const REVLibError_kCANDisconnected: root::rev::REVLibError = 17;
        pub const REVLibError_kDuplicateCANId: root::rev::REVLibError = 18;
        pub const REVLibError_kInvalidCANId: root::rev::REVLibError = 19;
        pub const REVLibError_kSparkMaxDataPortAlreadyConfiguredDifferently:
            root::rev::REVLibError = 20;
        pub type REVLibError = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct AnalogInput__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Get an instance of AnalogInput by using"]
        #[doc = " CANSparkMax::GetAnalog(SparkMaxAnalogSensor::Mode)}."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnalogInput {
            pub vtable_: *const AnalogInput__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_AnalogInput() {
            assert_eq!(
                ::std::mem::size_of::<AnalogInput>(),
                8usize,
                concat!("Size of: ", stringify!(AnalogInput))
            );
            assert_eq!(
                ::std::mem::align_of::<AnalogInput>(),
                8usize,
                concat!("Alignment of ", stringify!(AnalogInput))
            );
        }
        #[repr(C)]
        pub struct CANSensor__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " @deprecated Use MotorFeedbackSensor instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANSensor {
            pub vtable_: *const CANSensor__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CANSensor() {
            assert_eq!(
                ::std::mem::size_of::<CANSensor>(),
                8usize,
                concat!("Size of: ", stringify!(CANSensor))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSensor>(),
                8usize,
                concat!("Alignment of ", stringify!(CANSensor))
            );
        }
        #[doc = " A sensor that can be used to provide rotational feedback to a motor"]
        #[doc = " controller"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct MotorFeedbackSensor {
            pub _base: root::rev::CANSensor,
        }
        #[test]
        fn bindgen_test_layout_MotorFeedbackSensor() {
            assert_eq!(
                ::std::mem::size_of::<MotorFeedbackSensor>(),
                8usize,
                concat!("Size of: ", stringify!(MotorFeedbackSensor))
            );
            assert_eq!(
                ::std::mem::align_of::<MotorFeedbackSensor>(),
                8usize,
                concat!("Alignment of ", stringify!(MotorFeedbackSensor))
            );
        }
        #[doc = " @deprecated Use SparkMaxAnalogSensor instead."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANAnalog {
            pub _base: root::rev::MotorFeedbackSensor,
        }
        pub const CANAnalog_AnalogMode_kAbsolute: root::rev::CANAnalog_AnalogMode = 0;
        pub const CANAnalog_AnalogMode_kRelative: root::rev::CANAnalog_AnalogMode = 1;
        #[doc = " Analog sensors have the ability to either be absolute or relative."]
        #[doc = " By default, GetAnalog() will return an absolute analog sensor, but"]
        #[doc = " it can also be configured to be a relative sensor instead."]
        #[doc = ""]
        #[doc = " @deprecated Use SparkMaxAnalogSensor::Mode instead"]
        pub type CANAnalog_AnalogMode = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANAnalog() {
            assert_eq!(
                ::std::mem::size_of::<CANAnalog>(),
                8usize,
                concat!("Size of: ", stringify!(CANAnalog))
            );
            assert_eq!(
                ::std::mem::align_of::<CANAnalog>(),
                8usize,
                concat!("Alignment of ", stringify!(CANAnalog))
            );
        }
        #[repr(C)]
        pub struct CANDigitalInput__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " @deprecated Use SparkMaxLimitSwitch instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANDigitalInput {
            pub vtable_: *const CANDigitalInput__bindgen_vtable,
        }
        pub const CANDigitalInput_LimitSwitchPolarity_kNormallyOpen:
            root::rev::CANDigitalInput_LimitSwitchPolarity = 0;
        pub const CANDigitalInput_LimitSwitchPolarity_kNormallyClosed:
            root::rev::CANDigitalInput_LimitSwitchPolarity = 1;
        #[doc = " @deprecated Use SparkMaxLimitSwitch::Type instead"]
        pub type CANDigitalInput_LimitSwitchPolarity = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANDigitalInput() {
            assert_eq!(
                ::std::mem::size_of::<CANDigitalInput>(),
                8usize,
                concat!("Size of: ", stringify!(CANDigitalInput))
            );
            assert_eq!(
                ::std::mem::align_of::<CANDigitalInput>(),
                8usize,
                concat!("Alignment of ", stringify!(CANDigitalInput))
            );
        }
        #[doc = " @deprecated Use SparkMaxRelativeEncoder or SparkMaxAlternateEncoder instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANEncoder {
            pub _base: root::rev::MotorFeedbackSensor,
        }
        pub const CANEncoder_EncoderType_kNoSensor: root::rev::CANEncoder_EncoderType = 0;
        pub const CANEncoder_EncoderType_kHallSensor: root::rev::CANEncoder_EncoderType = 1;
        pub const CANEncoder_EncoderType_kQuadrature: root::rev::CANEncoder_EncoderType = 2;
        #[doc = " @deprecated Use SparkMaxRelativeEncoder::Type instead"]
        pub type CANEncoder_EncoderType = ::std::os::raw::c_int;
        pub const CANEncoder_AlternateEncoderType_kQuadrature:
            root::rev::CANEncoder_AlternateEncoderType = 0;
        #[doc = " @deprecated Use SparkMaxAlternateEncoder::Type instead"]
        pub type CANEncoder_AlternateEncoderType = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANEncoder() {
            assert_eq!(
                ::std::mem::size_of::<CANEncoder>(),
                8usize,
                concat!("Size of: ", stringify!(CANEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<CANEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(CANEncoder))
            );
        }
        pub const ControlType_kDutyCycle: root::rev::ControlType = 0;
        pub const ControlType_kVelocity: root::rev::ControlType = 1;
        pub const ControlType_kVoltage: root::rev::ControlType = 2;
        pub const ControlType_kPosition: root::rev::ControlType = 3;
        pub const ControlType_kSmartMotion: root::rev::ControlType = 4;
        pub const ControlType_kCurrent: root::rev::ControlType = 5;
        pub const ControlType_kSmartVelocity: root::rev::ControlType = 6;
        #[doc = " @deprecated Use CANSparkMax::ControlType instead"]
        pub type ControlType = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct CANPIDController__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " @deprecated Use SparkMaxPIDController instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANPIDController {
            pub vtable_: *const CANPIDController__bindgen_vtable,
        }
        pub const CANPIDController_AccelStrategy_kTrapezoidal:
            root::rev::CANPIDController_AccelStrategy = 0;
        pub const CANPIDController_AccelStrategy_kSCurve:
            root::rev::CANPIDController_AccelStrategy = 1;
        #[doc = " @deprecated Use SparkMaxPIDController::AccelStrategy instead"]
        pub type CANPIDController_AccelStrategy = ::std::os::raw::c_int;
        pub const CANPIDController_ArbFFUnits_kVoltage: root::rev::CANPIDController_ArbFFUnits = 0;
        pub const CANPIDController_ArbFFUnits_kPercentOut: root::rev::CANPIDController_ArbFFUnits =
            1;
        #[doc = " @deprecated Use SparkMaxPIDController::ArbFFUnits instead"]
        pub type CANPIDController_ArbFFUnits = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANPIDController() {
            assert_eq!(
                ::std::mem::size_of::<CANPIDController>(),
                8usize,
                concat!("Size of: ", stringify!(CANPIDController))
            );
            assert_eq!(
                ::std::mem::align_of::<CANPIDController>(),
                8usize,
                concat!("Alignment of ", stringify!(CANPIDController))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANSparkMaxLowLevel {
            pub _base: root::frc::MotorController,
            pub m_motorType: root::rev::CANSparkMaxLowLevel_MotorType,
            pub m_sparkMaxHandle: *mut ::std::os::raw::c_void,
            pub m_deviceID: ::std::os::raw::c_int,
        }
        pub const CANSparkMaxLowLevel_MotorType_kBrushed: root::rev::CANSparkMaxLowLevel_MotorType =
            0;
        pub const CANSparkMaxLowLevel_MotorType_kBrushless:
            root::rev::CANSparkMaxLowLevel_MotorType = 1;
        pub type CANSparkMaxLowLevel_MotorType = ::std::os::raw::c_int;
        pub const CANSparkMaxLowLevel_ControlType_kDutyCycle:
            root::rev::CANSparkMaxLowLevel_ControlType = 0;
        pub const CANSparkMaxLowLevel_ControlType_kVelocity:
            root::rev::CANSparkMaxLowLevel_ControlType = 1;
        pub const CANSparkMaxLowLevel_ControlType_kVoltage:
            root::rev::CANSparkMaxLowLevel_ControlType = 2;
        pub const CANSparkMaxLowLevel_ControlType_kPosition:
            root::rev::CANSparkMaxLowLevel_ControlType = 3;
        pub const CANSparkMaxLowLevel_ControlType_kSmartMotion:
            root::rev::CANSparkMaxLowLevel_ControlType = 4;
        pub const CANSparkMaxLowLevel_ControlType_kCurrent:
            root::rev::CANSparkMaxLowLevel_ControlType = 5;
        pub const CANSparkMaxLowLevel_ControlType_kSmartVelocity:
            root::rev::CANSparkMaxLowLevel_ControlType = 6;
        pub type CANSparkMaxLowLevel_ControlType = ::std::os::raw::c_int;
        pub const CANSparkMaxLowLevel_ParameterStatus_kOK:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 0;
        pub const CANSparkMaxLowLevel_ParameterStatus_kInvalidID:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 1;
        pub const CANSparkMaxLowLevel_ParameterStatus_kMismatchType:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 2;
        pub const CANSparkMaxLowLevel_ParameterStatus_kAccessMode:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 3;
        pub const CANSparkMaxLowLevel_ParameterStatus_kInvalid:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 4;
        pub const CANSparkMaxLowLevel_ParameterStatus_kNotImplementedDeprecated:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 5;
        pub type CANSparkMaxLowLevel_ParameterStatus = ::std::os::raw::c_int;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus0:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 0;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus1:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 1;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus2:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 2;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus3:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 3;
        pub type CANSparkMaxLowLevel_PeriodicFrame = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_PeriodicStatus0 {
            pub appliedOutput: f64,
            pub faults: u16,
            pub stickyFaults: u16,
            pub motorType: root::rev::CANSparkMaxLowLevel_MotorType,
            pub isFollower: bool,
            pub lock: u8,
            pub roboRIO: u8,
            pub isInverted: u8,
            pub timestamp: u64,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_PeriodicStatus0() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_PeriodicStatus0>(),
                32usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_PeriodicStatus0))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_PeriodicStatus0>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0)
                )
            );
            fn test_field_appliedOutput() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).appliedOutput) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(appliedOutput)
                    )
                );
            }
            test_field_appliedOutput();
            fn test_field_faults() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).faults) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(faults)
                    )
                );
            }
            test_field_faults();
            fn test_field_stickyFaults() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).stickyFaults) as usize - ptr as usize
                    },
                    10usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(stickyFaults)
                    )
                );
            }
            test_field_stickyFaults();
            fn test_field_motorType() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).motorType) as usize - ptr as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(motorType)
                    )
                );
            }
            test_field_motorType();
            fn test_field_isFollower() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).isFollower) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(isFollower)
                    )
                );
            }
            test_field_isFollower();
            fn test_field_lock() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize
                    },
                    17usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(lock)
                    )
                );
            }
            test_field_lock();
            fn test_field_roboRIO() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).roboRIO) as usize - ptr as usize
                    },
                    18usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(roboRIO)
                    )
                );
            }
            test_field_roboRIO();
            fn test_field_isInverted() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).isInverted) as usize - ptr as usize
                    },
                    19usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(isInverted)
                    )
                );
            }
            test_field_isInverted();
            fn test_field_timestamp() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus0>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                        "::",
                        stringify!(timestamp)
                    )
                );
            }
            test_field_timestamp();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_PeriodicStatus1 {
            pub sensorVelocity: f64,
            pub motorTemperature: u8,
            pub busVoltage: f64,
            pub outputCurrent: f64,
            pub timestamp: u64,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_PeriodicStatus1() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_PeriodicStatus1>(),
                40usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_PeriodicStatus1))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_PeriodicStatus1>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1)
                )
            );
            fn test_field_sensorVelocity() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus1>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).sensorVelocity) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                        "::",
                        stringify!(sensorVelocity)
                    )
                );
            }
            test_field_sensorVelocity();
            fn test_field_motorTemperature() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus1>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).motorTemperature) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                        "::",
                        stringify!(motorTemperature)
                    )
                );
            }
            test_field_motorTemperature();
            fn test_field_busVoltage() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus1>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).busVoltage) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                        "::",
                        stringify!(busVoltage)
                    )
                );
            }
            test_field_busVoltage();
            fn test_field_outputCurrent() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus1>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).outputCurrent) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                        "::",
                        stringify!(outputCurrent)
                    )
                );
            }
            test_field_outputCurrent();
            fn test_field_timestamp() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus1>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                        "::",
                        stringify!(timestamp)
                    )
                );
            }
            test_field_timestamp();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_PeriodicStatus2 {
            pub sensorPosition: f64,
            pub iAccum: f64,
            pub timestamp: u64,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_PeriodicStatus2() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_PeriodicStatus2>(),
                24usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_PeriodicStatus2))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_PeriodicStatus2>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus2)
                )
            );
            fn test_field_sensorPosition() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus2>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).sensorPosition) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus2),
                        "::",
                        stringify!(sensorPosition)
                    )
                );
            }
            test_field_sensorPosition();
            fn test_field_iAccum() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus2>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).iAccum) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus2),
                        "::",
                        stringify!(iAccum)
                    )
                );
            }
            test_field_iAccum();
            fn test_field_timestamp() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_PeriodicStatus2>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_PeriodicStatus2),
                        "::",
                        stringify!(timestamp)
                    )
                );
            }
            test_field_timestamp();
        }
        pub const CANSparkMaxLowLevel_TelemetryID_kBusVoltage:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 0;
        pub const CANSparkMaxLowLevel_TelemetryID_kOutputCurrent:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 1;
        pub const CANSparkMaxLowLevel_TelemetryID_kVelocity:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 2;
        pub const CANSparkMaxLowLevel_TelemetryID_kPosition:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 3;
        pub const CANSparkMaxLowLevel_TelemetryID_kIAccum:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 4;
        pub const CANSparkMaxLowLevel_TelemetryID_kAppliedOutput:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 5;
        pub const CANSparkMaxLowLevel_TelemetryID_kMotorTemp:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 6;
        pub const CANSparkMaxLowLevel_TelemetryID_kFaults:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 7;
        pub const CANSparkMaxLowLevel_TelemetryID_kStickyFaults:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 8;
        pub const CANSparkMaxLowLevel_TelemetryID_kAnalogVoltage:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 9;
        pub const CANSparkMaxLowLevel_TelemetryID_kAnalogPosition:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 10;
        pub const CANSparkMaxLowLevel_TelemetryID_kAnalogVelocity:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 11;
        pub const CANSparkMaxLowLevel_TelemetryID_kAltEncPosition:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 12;
        pub const CANSparkMaxLowLevel_TelemetryID_kAltEncVelocity:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 13;
        pub const CANSparkMaxLowLevel_TelemetryID_kTotalStreams:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 14;
        pub type CANSparkMaxLowLevel_TelemetryID = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_TelemetryMessage {
            pub id: root::rev::CANSparkMaxLowLevel_TelemetryID,
            pub value: f32,
            pub timestamp: u64,
            pub name: *const ::std::os::raw::c_char,
            pub units: *const ::std::os::raw::c_char,
            pub lowerBnd: f32,
            pub upperBnd: f32,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_TelemetryMessage() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_TelemetryMessage>(),
                40usize,
                concat!(
                    "Size of: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_TelemetryMessage>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage)
                )
            );
            fn test_field_id() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(id)
                    )
                );
            }
            test_field_id();
            fn test_field_value() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(value)
                    )
                );
            }
            test_field_value();
            fn test_field_timestamp() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(timestamp)
                    )
                );
            }
            test_field_timestamp();
            fn test_field_name() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(name)
                    )
                );
            }
            test_field_name();
            fn test_field_units() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(units)
                    )
                );
            }
            test_field_units();
            fn test_field_lowerBnd() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).lowerBnd) as usize - ptr as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(lowerBnd)
                    )
                );
            }
            test_field_lowerBnd();
            fn test_field_upperBnd() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_TelemetryMessage>::uninit(
                            );
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).upperBnd) as usize - ptr as usize
                    },
                    36usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                        "::",
                        stringify!(upperBnd)
                    )
                );
            }
            test_field_upperBnd();
        }
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kNoSensor:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 0;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kHallSensor:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 1;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kQuadrature:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 2;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kSensorless:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 3;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kAnalog:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 4;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kAltQuadrature:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 5;
        pub type CANSparkMaxLowLevel_FeedbackSensorType = ::std::os::raw::c_int;
        #[repr(C)]
        #[repr(align(4))]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_FollowConfigBits {
            pub _bitfield_align_1: [u32; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_FollowConfigBits() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_FollowConfigBits>(),
                4usize,
                concat!(
                    "Size of: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfigBits)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_FollowConfigBits>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_FollowConfigBits)
                )
            );
        }
        impl CANSparkMaxLowLevel_FollowConfigBits {
            #[inline]
            pub fn rsvd1(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
            }
            #[inline]
            pub fn set_rsvd1(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 18u8, val as u64)
                }
            }
            #[inline]
            pub fn invert(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
            }
            #[inline]
            pub fn set_invert(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rsvd2(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
            }
            #[inline]
            pub fn set_rsvd2(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(19usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn predefined(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
            }
            #[inline]
            pub fn set_predefined(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(24usize, 8u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                rsvd1: u32,
                invert: u32,
                rsvd2: u32,
                predefined: u32,
            ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 18u8, {
                    let rsvd1: u32 = unsafe { ::std::mem::transmute(rsvd1) };
                    rsvd1 as u64
                });
                __bindgen_bitfield_unit.set(18usize, 1u8, {
                    let invert: u32 = unsafe { ::std::mem::transmute(invert) };
                    invert as u64
                });
                __bindgen_bitfield_unit.set(19usize, 5u8, {
                    let rsvd2: u32 = unsafe { ::std::mem::transmute(rsvd2) };
                    rsvd2 as u64
                });
                __bindgen_bitfield_unit.set(24usize, 8u8, {
                    let predefined: u32 = unsafe { ::std::mem::transmute(predefined) };
                    predefined as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct CANSparkMaxLowLevel_FollowConfig {
            pub leaderArbId: u32,
            pub config: root::rev::CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion {
            pub value: u32,
            pub bits: root::rev::CANSparkMaxLowLevel_FollowConfigBits,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion>(),
                4usize,
                concat!(
                    "Size of: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion)
                )
            );
            fn test_field_value() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<
                            CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion,
                        >::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion),
                        "::",
                        stringify!(value)
                    )
                );
            }
            test_field_value();
            fn test_field_bits() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<
                            CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion,
                        >::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion),
                        "::",
                        stringify!(bits)
                    )
                );
            }
            test_field_bits();
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_FollowConfig() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_FollowConfig>(),
                8usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_FollowConfig))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_FollowConfig>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig)
                )
            );
            fn test_field_leaderArbId() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_FollowConfig>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).leaderArbId) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_FollowConfig),
                        "::",
                        stringify!(leaderArbId)
                    )
                );
            }
            test_field_leaderArbId();
            fn test_field_config() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMaxLowLevel_FollowConfig>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel_FollowConfig),
                        "::",
                        stringify!(config)
                    )
                );
            }
            test_field_config();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel16kAPIMajorVersionE"]
            pub static CANSparkMaxLowLevel_kAPIMajorVersion: u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel16kAPIMinorVersionE"]
            pub static CANSparkMaxLowLevel_kAPIMinorVersion: u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel16kAPIBuildVersionE"]
            pub static CANSparkMaxLowLevel_kAPIBuildVersion: u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel11kAPIVersionE"]
            pub static CANSparkMaxLowLevel_kAPIVersion: u32;
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel>(),
                32usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel>(),
                8usize,
                concat!("Alignment of ", stringify!(CANSparkMaxLowLevel))
            );
            fn test_field_m_motorType() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMaxLowLevel>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_motorType) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel),
                        "::",
                        stringify!(m_motorType)
                    )
                );
            }
            test_field_m_motorType();
            fn test_field_m_sparkMaxHandle() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMaxLowLevel>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_sparkMaxHandle) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel),
                        "::",
                        stringify!(m_sparkMaxHandle)
                    )
                );
            }
            test_field_m_sparkMaxHandle();
            fn test_field_m_deviceID() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMaxLowLevel>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_deviceID) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMaxLowLevel),
                        "::",
                        stringify!(m_deviceID)
                    )
                );
            }
            test_field_m_deviceID();
        }
        extern "C" {
            #[doc = " Get the firmware version of the SPARK MAX."]
            #[doc = ""]
            #[doc = " @return uint32_t Firmware version integer. Value is represented as 4"]
            #[doc = " bytes, Major.Minor.Build H.Build L"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetFirmwareVersionEv"]
            pub fn CANSparkMaxLowLevel_GetFirmwareVersion(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetFirmwareVersionERb"]
            pub fn CANSparkMaxLowLevel_GetFirmwareVersion1(
                this: *mut root::rev::CANSparkMaxLowLevel,
                isDebugBuild: *mut bool,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the firmware version of the SPARK MAX as a string."]
            #[doc = ""]
            #[doc = " @return std::string Human readable firmware version string"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel17GetFirmwareStringB5cxx11Ev"]
            pub fn CANSparkMaxLowLevel_GetFirmwareString(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::std::string;
        }
        extern "C" {
            #[doc = " Get the unique serial number of the SPARK MAX. Currently not implemented."]
            #[doc = ""]
            #[doc = " @return std::vector<uint8_t> Vector of bytes representig the unique"]
            #[doc = " serial number"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel15GetSerialNumberEv"]
            pub fn CANSparkMaxLowLevel_GetSerialNumber(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::std::vector;
        }
        extern "C" {
            #[doc = " Get the configured Device ID of the SPARK MAX."]
            #[doc = ""]
            #[doc = " @return int device ID"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev19CANSparkMaxLowLevel11GetDeviceIdEv"]
            pub fn CANSparkMaxLowLevel_GetDeviceId(
                this: *const root::rev::CANSparkMaxLowLevel,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the motor type setting from when the SparkMax was created."]
            #[doc = ""]
            #[doc = " This does not use the Get Parameter API which means it does not read"]
            #[doc = " what motor type is stored on the SparkMax itself. Instead, it reads"]
            #[doc = " the stored motor type from when the SparkMax object was first created."]
            #[doc = ""]
            #[doc = " @return MotorType Motor type setting"]
            #[doc = ""]
            #[doc = " @deprecated Use GetMotorType() instead"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel19GetInitialMotorTypeEv"]
            pub fn CANSparkMaxLowLevel_GetInitialMotorType(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_MotorType;
        }
        extern "C" {
            #[doc = " Get the motor type setting for the SPARK MAX."]
            #[doc = ""]
            #[doc = " @return MotorType Motor type setting"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel12GetMotorTypeEv"]
            pub fn CANSparkMaxLowLevel_GetMotorType(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_MotorType;
        }
        extern "C" {
            #[doc = " Set the rate of transmission for periodic frames from the SPARK MAX"]
            #[doc = ""]
            #[doc = " Each motor controller sends back three status frames with different"]
            #[doc = " data at set rates. Use this function to change the default rates."]
            #[doc = ""]
            #[doc = " Defaults:"]
            #[doc = " Status0 - 10ms"]
            #[doc = " Status1 - 20ms"]
            #[doc = " Status2 - 50ms"]
            #[doc = ""]
            #[doc = " This value is not stored in the FLASH after calling burnFlash()"]
            #[doc = " and is reset on powerup."]
            #[doc = ""]
            #[doc = " Refer to the SPARK MAX reference manual on details for how and when"]
            #[doc = " to configure this parameter."]
            #[doc = ""]
            #[doc = " @param frame Which periodic frame to change the period of"]
            #[doc = " @param periodMs The rate the controller sends the frame to the"]
            #[doc = " controller."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel22SetPeriodicFramePeriodENS0_13PeriodicFrameEi"]
            pub fn CANSparkMaxLowLevel_SetPeriodicFramePeriod(
                this: *mut root::rev::CANSparkMaxLowLevel,
                frame: root::rev::CANSparkMaxLowLevel_PeriodicFrame,
                periodMs: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the control frame send period for the native CAN Send thread. To"]
            #[doc = " disable periodic sends, set periodMs to 0."]
            #[doc = ""]
            #[doc = " @param periodMs The send period in milliseconds between 1ms and 100ms"]
            #[doc = " or set to 0 to disable periodic sends. Note this is not updated until"]
            #[doc = " the next call to Set() or SetReference()."]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel23SetControlFramePeriodMsEi"]
            pub fn CANSparkMaxLowLevel_SetControlFramePeriodMs(
                this: *mut root::rev::CANSparkMaxLowLevel,
                periodMs: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Restore motor controller parameters to factory default"]
            #[doc = ""]
            #[doc = " @param persist If true, burn the flash with the factory default"]
            #[doc = " parameters"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel22RestoreFactoryDefaultsEb"]
            pub fn CANSparkMaxLowLevel_RestoreFactoryDefaults(
                this: *mut root::rev::CANSparkMaxLowLevel,
                persist: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Allow external controllers to recieve control commands over USB."]
            #[doc = " For example, a configuration where the heartbeat (and enable/disable)"]
            #[doc = " is sent by the main controller, but control frames are sent by"]
            #[doc = " other CAN devices over USB."]
            #[doc = ""]
            #[doc = " This is global for all controllers on the same bus."]
            #[doc = ""]
            #[doc = " This does not disable sending control frames from this device. To prevent"]
            #[doc = " conflicts, do not enable this feature and also send Set() for"]
            #[doc = " SetReference() from the controllers you wish to control."]
            #[doc = ""]
            #[doc = " @param enable Enable or disable external control"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel24EnableExternalUSBControlEb"]
            pub fn CANSparkMaxLowLevel_EnableExternalUSBControl(enable: bool);
        }
        extern "C" {
            #[doc = " Send enabled or disabled command to controllers. This is global for all"]
            #[doc = " controllers on the same bus, and will only work for non-roboRIO targets"]
            #[doc = " in non-competiton use. This function will also not work if a roboRIO is"]
            #[doc = " present on the CAN bus."]
            #[doc = ""]
            #[doc = " This does not disable sending control frames from this device. To prevent"]
            #[doc = " conflicts, do not enable this feature and also send Set() for"]
            #[doc = " SetReference() from the controllers you wish to control."]
            #[doc = ""]
            #[doc = " @param enable Enable or disable external control"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel9SetEnableEb"]
            pub fn CANSparkMaxLowLevel_SetEnable(enable: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetPeriodicStatus0Ev"]
            pub fn CANSparkMaxLowLevel_GetPeriodicStatus0(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus0;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetPeriodicStatus1Ev"]
            pub fn CANSparkMaxLowLevel_GetPeriodicStatus1(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus1;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetPeriodicStatus2Ev"]
            pub fn CANSparkMaxLowLevel_GetPeriodicStatus2(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus2;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel9SetFollowENS0_12FollowConfigE"]
            pub fn CANSparkMaxLowLevel_SetFollow(
                this: *mut root::rev::CANSparkMaxLowLevel,
                config: root::rev::CANSparkMaxLowLevel_FollowConfig,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel15SetpointCommandEdNS0_11ControlTypeEidi"]
            pub fn CANSparkMaxLowLevel_SetpointCommand(
                this: *mut root::rev::CANSparkMaxLowLevel,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel12GetSafeFloatEf"]
            pub fn CANSparkMaxLowLevel_GetSafeFloat(
                this: *mut root::rev::CANSparkMaxLowLevel,
                f: f32,
            ) -> f32;
        }
        impl CANSparkMaxLowLevel {
            #[inline]
            pub unsafe fn GetFirmwareVersion(&mut self) -> u32 {
                CANSparkMaxLowLevel_GetFirmwareVersion(self)
            }
            #[inline]
            pub unsafe fn GetFirmwareVersion1(&mut self, isDebugBuild: *mut bool) -> u32 {
                CANSparkMaxLowLevel_GetFirmwareVersion1(self, isDebugBuild)
            }
            #[inline]
            pub unsafe fn GetFirmwareString(&mut self) -> root::std::string {
                CANSparkMaxLowLevel_GetFirmwareString(self)
            }
            #[inline]
            pub unsafe fn GetSerialNumber(&mut self) -> root::std::vector {
                CANSparkMaxLowLevel_GetSerialNumber(self)
            }
            #[inline]
            pub unsafe fn GetDeviceId(&self) -> ::std::os::raw::c_int {
                CANSparkMaxLowLevel_GetDeviceId(self)
            }
            #[inline]
            pub unsafe fn GetInitialMotorType(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_MotorType {
                CANSparkMaxLowLevel_GetInitialMotorType(self)
            }
            #[inline]
            pub unsafe fn GetMotorType(&mut self) -> root::rev::CANSparkMaxLowLevel_MotorType {
                CANSparkMaxLowLevel_GetMotorType(self)
            }
            #[inline]
            pub unsafe fn SetPeriodicFramePeriod(
                &mut self,
                frame: root::rev::CANSparkMaxLowLevel_PeriodicFrame,
                periodMs: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_SetPeriodicFramePeriod(self, frame, periodMs)
            }
            #[inline]
            pub unsafe fn SetControlFramePeriodMs(&mut self, periodMs: ::std::os::raw::c_int) {
                CANSparkMaxLowLevel_SetControlFramePeriodMs(self, periodMs)
            }
            #[inline]
            pub unsafe fn RestoreFactoryDefaults(
                &mut self,
                persist: bool,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_RestoreFactoryDefaults(self, persist)
            }
            #[inline]
            pub unsafe fn EnableExternalUSBControl(enable: bool) {
                CANSparkMaxLowLevel_EnableExternalUSBControl(enable)
            }
            #[inline]
            pub unsafe fn SetEnable(enable: bool) {
                CANSparkMaxLowLevel_SetEnable(enable)
            }
            #[inline]
            pub unsafe fn GetPeriodicStatus0(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus0 {
                CANSparkMaxLowLevel_GetPeriodicStatus0(self)
            }
            #[inline]
            pub unsafe fn GetPeriodicStatus1(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus1 {
                CANSparkMaxLowLevel_GetPeriodicStatus1(self)
            }
            #[inline]
            pub unsafe fn GetPeriodicStatus2(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus2 {
                CANSparkMaxLowLevel_GetPeriodicStatus2(self)
            }
            #[inline]
            pub unsafe fn SetFollow(
                &mut self,
                config: root::rev::CANSparkMaxLowLevel_FollowConfig,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_SetFollow(self, config)
            }
            #[inline]
            pub unsafe fn SetpointCommand(
                &mut self,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_SetpointCommand(
                    self,
                    value,
                    ctrl,
                    pidSlot,
                    arbFeedforward,
                    arbFFUnits,
                )
            }
            #[inline]
            pub unsafe fn GetSafeFloat(&mut self, f: f32) -> f32 {
                CANSparkMaxLowLevel_GetSafeFloat(self, f)
            }
        }
        extern "C" {
            #[doc = " Closes the SPARK MAX Controller"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevelD1Ev"]
            pub fn CANSparkMaxLowLevel_CANSparkMaxLowLevel_destructor(
                this: *mut root::rev::CANSparkMaxLowLevel,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RelativeEncoder {
            pub _base: root::rev::CANEncoder,
        }
        #[test]
        fn bindgen_test_layout_RelativeEncoder() {
            assert_eq!(
                ::std::mem::size_of::<RelativeEncoder>(),
                8usize,
                concat!("Size of: ", stringify!(RelativeEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<RelativeEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(RelativeEncoder))
            );
        }
        #[doc = " Get an instance of this class by using CANSparkMax::GetEncoder() or"]
        #[doc = " CANSparkMax::GetEncoder(CANSparkMax::EncoderType, int)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxAlternateEncoder {
            pub _base: root::rev::RelativeEncoder,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_countsPerRev: ::std::os::raw::c_int,
        }
        pub const SparkMaxAlternateEncoder_Type_kQuadrature:
            root::rev::SparkMaxAlternateEncoder_Type = 0;
        #[doc = " The type of encoder wired as an Alternate Encoder on a SPARK MAX"]
        pub type SparkMaxAlternateEncoder_Type = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxAlternateEncoder() {
            assert_eq!(
                ::std::mem::size_of::<SparkMaxAlternateEncoder>(),
                24usize,
                concat!("Size of: ", stringify!(SparkMaxAlternateEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxAlternateEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxAlternateEncoder))
            );
            fn test_field_m_device() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxAlternateEncoder>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxAlternateEncoder),
                        "::",
                        stringify!(m_device)
                    )
                );
            }
            test_field_m_device();
            fn test_field_m_countsPerRev() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxAlternateEncoder>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_countsPerRev) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxAlternateEncoder),
                        "::",
                        stringify!(m_countsPerRev)
                    )
                );
            }
            test_field_m_countsPerRev();
        }
        extern "C" {
            #[doc = " Get the position of the motor. This returns the native units"]
            #[doc = " of 'rotations' by default, and can be changed by a scale factor"]
            #[doc = " using setPositionConversionFactor()."]
            #[doc = ""]
            #[doc = " @return Number of rotations of the motor"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder11GetPositionEv"]
            pub fn SparkMaxAlternateEncoder_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the velocity of the motor. This returns the native units"]
            #[doc = " of 'RPM' by default, and can be changed by a scale factor"]
            #[doc = " using setVelocityConversionFactor()."]
            #[doc = ""]
            #[doc = " @return Number the RPM of the motor"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder11GetVelocityEv"]
            pub fn SparkMaxAlternateEncoder_GetVelocity(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the position of the encoder."]
            #[doc = ""]
            #[doc = " @param position Number of rotations of the motor"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder11SetPositionEd"]
            pub fn SparkMaxAlternateEncoder_SetPosition(
                this: *mut ::std::os::raw::c_void,
                position: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for position of the encoder. Multiplied by the"]
            #[doc = " native output units to give you position"]
            #[doc = ""]
            #[doc = " @param factor The conversion factor to multiply the native units by"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder27SetPositionConversionFactorEd"]
            pub fn SparkMaxAlternateEncoder_SetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for velocity of the encoder. Multiplied by the"]
            #[doc = " native output units to give you velocity"]
            #[doc = ""]
            #[doc = " @param factor The conversion factor to multiply the native units by"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder27SetVelocityConversionFactorEd"]
            pub fn SparkMaxAlternateEncoder_SetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the conversion factor for position of the encoder. Multiplied by the"]
            #[doc = " native output units to give you position"]
            #[doc = ""]
            #[doc = " @return The conversion factor for position"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder27GetPositionConversionFactorEv"]
            pub fn SparkMaxAlternateEncoder_GetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the conversion factor for velocity of the encoder. Multiplied by the"]
            #[doc = " native output units to give you velocity"]
            #[doc = ""]
            #[doc = " @return The conversion factor for velocity"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder27GetVelocityConversionFactorEv"]
            pub fn SparkMaxAlternateEncoder_GetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the average sampling depth for a quadrature encoder. This value"]
            #[doc = " sets the number of samples in the average for velocity readings. This"]
            #[doc = " can be any value from 1 to 64."]
            #[doc = ""]
            #[doc = " @param depth The average sampling depth between 1 and 64 (default)"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder15SetAverageDepthEj"]
            pub fn SparkMaxAlternateEncoder_SetAverageDepth(
                this: *mut ::std::os::raw::c_void,
                depth: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the measurement period for velocity measurements of a quadrature"]
            #[doc = " encoder."]
            #[doc = ""]
            #[doc = " The basic formula to calculate velocity is change in position / change in"]
            #[doc = " time. This parameter sets the change in time for measurement."]
            #[doc = ""]
            #[doc = " @param period_ms Measurement period in milliseconds. This number may be"]
            #[doc = " between 1 and 100 (default)."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder20SetMeasurementPeriodEj"]
            pub fn SparkMaxAlternateEncoder_SetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
                period_ms: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the average sampling depth for a quadrature encoder."]
            #[doc = ""]
            #[doc = " @return The average sampling depth"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder15GetAverageDepthEv"]
            pub fn SparkMaxAlternateEncoder_GetAverageDepth(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the number of samples for reading from a quadrature encoder. This"]
            #[doc = " value sets the number of samples in the average for velocity readings."]
            #[doc = ""]
            #[doc = " @return Measurement period in microseconds"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder20GetMeasurementPeriodEv"]
            pub fn SparkMaxAlternateEncoder_GetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the counts per revolution of the quadrature encoder."]
            #[doc = ""]
            #[doc = " For a description on the difference between CPR, PPR, etc. go to"]
            #[doc = " https://www.cuidevices.com/blog/what-is-encoder-ppr-cpr-and-lpr"]
            #[doc = ""]
            #[doc = " @return Counts per revolution"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder22GetCountsPerRevolutionEv"]
            pub fn SparkMaxAlternateEncoder_GetCountsPerRevolution(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Set the phase of the MotorFeedbackSensor so that it is set to be in"]
            #[doc = " phase with the motor itself. This only works for quadrature"]
            #[doc = " encoders."]
            #[doc = ""]
            #[doc = " @param inverted The phase of the encoder"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder11SetInvertedEb"]
            pub fn SparkMaxAlternateEncoder_SetInverted(
                this: *mut ::std::os::raw::c_void,
                inverted: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the phase of the MotorFeedbackSensor. This will just return false"]
            #[doc = " if the user tries to get inverted while the SparkMax is"]
            #[doc = " Brushless and using the hall effect sensor."]
            #[doc = ""]
            #[doc = " @return The phase of the encoder"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder11GetInvertedEv"]
            pub fn SparkMaxAlternateEncoder_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxAnalogSensor {
            pub _base: root::rev::AnalogInput,
            pub _base_1: root::rev::CANAnalog,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_mode: root::rev::SparkMaxAnalogSensor_Mode,
        }
        pub const SparkMaxAnalogSensor_Mode_kAbsolute: root::rev::SparkMaxAnalogSensor_Mode = 0;
        pub const SparkMaxAnalogSensor_Mode_kRelative: root::rev::SparkMaxAnalogSensor_Mode = 1;
        #[doc = " Analog sensors have the ability to either be absolute or relative."]
        #[doc = " By default, CANSparkMax::GetAnalog() will return an absolute analog"]
        #[doc = " sensor, but it can also be configured to be a relative sensor instead."]
        pub type SparkMaxAnalogSensor_Mode = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxAnalogSensor() {
            assert_eq!(
                ::std::mem::size_of::<SparkMaxAnalogSensor>(),
                32usize,
                concat!("Size of: ", stringify!(SparkMaxAnalogSensor))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxAnalogSensor>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxAnalogSensor))
            );
        }
        extern "C" {
            #[doc = " Get the voltage of the analog sensor."]
            #[doc = ""]
            #[doc = " @return Voltage of the sensor"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor10GetVoltageEv"]
            pub fn SparkMaxAnalogSensor_GetVoltage(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the position of the sensor. Returns value in the native unit"]
            #[doc = " of 'volt' by default, and can be changed by a scale factor"]
            #[doc = " using setPositionConversionFactor()."]
            #[doc = ""]
            #[doc = " @return Position of the sensor in volts"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor11GetPositionEv"]
            pub fn SparkMaxAnalogSensor_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the velocity of the sensor. Returns value in the native units of"]
            #[doc = " 'volts per second' by default, and can be changed by a"]
            #[doc = " scale factor using setVelocityConversionFactor()."]
            #[doc = ""]
            #[doc = " @return Velocity of the sensor in volts per second"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor11GetVelocityEv"]
            pub fn SparkMaxAnalogSensor_GetVelocity(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the conversion factor for the position of the analog sensor."]
            #[doc = " By default, revolutions per volt is 1. Changing the position conversion"]
            #[doc = " factor will also change the position units."]
            #[doc = ""]
            #[doc = " @param factor The conversion factor which will be multiplied by volts"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor27SetPositionConversionFactorEd"]
            pub fn SparkMaxAnalogSensor_SetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the current conversion factor for the position of the analog"]
            #[doc = " sensor."]
            #[doc = ""]
            #[doc = " @return Analog position conversion factor"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor27GetPositionConversionFactorEv"]
            pub fn SparkMaxAnalogSensor_GetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the conversion factor for the velocity of the analog sensor."]
            #[doc = " By default, revolutions per volt second is 1. Changing the velocity"]
            #[doc = " conversion factor will also change the velocity units."]
            #[doc = ""]
            #[doc = " @param factor The conversion factor which will be multipled by volts per"]
            #[doc = " second"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk is successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor27SetVelocityConversionFactorEd"]
            pub fn SparkMaxAnalogSensor_SetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the current conversion factor for the velocity of the analog"]
            #[doc = " sensor."]
            #[doc = ""]
            #[doc = " @return Analog velocity conversion factor"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor27GetVelocityConversionFactorEv"]
            pub fn SparkMaxAnalogSensor_GetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the number of samples in the average for velocity readings. This"]
            #[doc = " can be any value from 1 to 64."]
            #[doc = ""]
            #[doc = " When the SparkMax controller is in Brushless mode, this"]
            #[doc = " will not change any behavior."]
            #[doc = ""]
            #[doc = " @param depth The average sampling depth between 1 and 64 (default)"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor15SetAverageDepthEj"]
            pub fn SparkMaxAnalogSensor_SetAverageDepth(
                this: *mut ::std::os::raw::c_void,
                depth: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the measurement period for velocity readings."]
            #[doc = ""]
            #[doc = " The basic formula to calculate velocity is change in position / change in"]
            #[doc = " time. This parameter sets the change in time for measurement."]
            #[doc = ""]
            #[doc = " @param period_ms Measurement period in milliseconds. This number may be"]
            #[doc = " between 1 and 100 (default)."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor20SetMeasurementPeriodEj"]
            pub fn SparkMaxAnalogSensor_SetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
                period_ms: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the number of samples included in the average for velocity readings."]
            #[doc = ""]
            #[doc = " @return The average sampling depth"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor15GetAverageDepthEv"]
            pub fn SparkMaxAnalogSensor_GetAverageDepth(this: *mut ::std::os::raw::c_void) -> u32;
        }
        extern "C" {
            #[doc = " Get the measurement period used for velocity readings."]
            #[doc = ""]
            #[doc = " @return Measurement period in microseconds"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor20GetMeasurementPeriodEv"]
            pub fn SparkMaxAnalogSensor_GetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Set the phase of the MotorFeedbackSensor so that it is set to be in"]
            #[doc = " phase with the motor itself. This only works for quadrature"]
            #[doc = " encoders. This will throw an error if the user tries to set"]
            #[doc = " inverted while the SparkMax is Brushless and using the hall"]
            #[doc = " effect sensor."]
            #[doc = ""]
            #[doc = " @param inverted The phase of the encoder"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor11SetInvertedEb"]
            pub fn SparkMaxAnalogSensor_SetInverted(
                this: *mut ::std::os::raw::c_void,
                inverted: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the phase of the MotorFeedbackSensor. This will just return false"]
            #[doc = " if the user tries to get inverted while the SparkMax is"]
            #[doc = " Brushless and using the hall effect sensor."]
            #[doc = ""]
            #[doc = " @return The phase of the encoder"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor11GetInvertedEv"]
            pub fn SparkMaxAnalogSensor_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxLimitSwitch {
            pub _base: root::rev::CANDigitalInput,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_direction: root::rev::SparkMaxLimitSwitch_Direction,
        }
        pub const SparkMaxLimitSwitch_Type_kNormallyOpen: root::rev::SparkMaxLimitSwitch_Type = 0;
        pub const SparkMaxLimitSwitch_Type_kNormallyClosed: root::rev::SparkMaxLimitSwitch_Type = 1;
        #[doc = " Represents whether the circuit is open or closed when the switch is not"]
        #[doc = " being pressed"]
        pub type SparkMaxLimitSwitch_Type = ::std::os::raw::c_int;
        pub const SparkMaxLimitSwitch_Direction_kForward: root::rev::SparkMaxLimitSwitch_Direction =
            0;
        pub const SparkMaxLimitSwitch_Direction_kReverse: root::rev::SparkMaxLimitSwitch_Direction =
            1;
        pub type SparkMaxLimitSwitch_Direction = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxLimitSwitch() {
            assert_eq!(
                ::std::mem::size_of::<SparkMaxLimitSwitch>(),
                24usize,
                concat!("Size of: ", stringify!(SparkMaxLimitSwitch))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxLimitSwitch>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxLimitSwitch))
            );
            fn test_field_m_device() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxLimitSwitch>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxLimitSwitch),
                        "::",
                        stringify!(m_device)
                    )
                );
            }
            test_field_m_device();
            fn test_field_m_direction() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxLimitSwitch>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_direction) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxLimitSwitch),
                        "::",
                        stringify!(m_direction)
                    )
                );
            }
            test_field_m_direction();
        }
        extern "C" {
            #[doc = " Get the state of the limit switch, whether or not it is enabled"]
            #[doc = " (limiting the rotation of the motor)."]
            #[link_name = "\u{1}_ZNK3rev19SparkMaxLimitSwitch3GetEv"]
            pub fn SparkMaxLimitSwitch_Get(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            #[doc = " Enables or disables controller shutdown based on limit switch."]
            #[link_name = "\u{1}_ZN3rev19SparkMaxLimitSwitch17EnableLimitSwitchEb"]
            pub fn SparkMaxLimitSwitch_EnableLimitSwitch(
                this: *mut ::std::os::raw::c_void,
                enable: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Returns true if limit switch is enabled."]
            #[link_name = "\u{1}_ZNK3rev19SparkMaxLimitSwitch20IsLimitSwitchEnabledEv"]
            pub fn SparkMaxLimitSwitch_IsLimitSwitchEnabled(
                this: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxPIDController {
            pub _base: root::rev::CANPIDController,
            pub m_device: *mut root::rev::CANSparkMax,
        }
        pub const SparkMaxPIDController_AccelStrategy_kTrapezoidal:
            root::rev::SparkMaxPIDController_AccelStrategy = 0;
        pub const SparkMaxPIDController_AccelStrategy_kSCurve:
            root::rev::SparkMaxPIDController_AccelStrategy = 1;
        #[doc = " Acceleration strategy used by Smart Motion"]
        pub type SparkMaxPIDController_AccelStrategy = ::std::os::raw::c_int;
        pub const SparkMaxPIDController_ArbFFUnits_kVoltage:
            root::rev::SparkMaxPIDController_ArbFFUnits = 0;
        pub const SparkMaxPIDController_ArbFFUnits_kPercentOut:
            root::rev::SparkMaxPIDController_ArbFFUnits = 1;
        #[doc = " Units for arbitrary feed-forward"]
        pub type SparkMaxPIDController_ArbFFUnits = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxPIDController() {
            assert_eq!(
                ::std::mem::size_of::<SparkMaxPIDController>(),
                16usize,
                concat!("Size of: ", stringify!(SparkMaxPIDController))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxPIDController>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxPIDController))
            );
            fn test_field_m_device() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxPIDController>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxPIDController),
                        "::",
                        stringify!(m_device)
                    )
                );
            }
            test_field_m_device();
        }
        extern "C" {
            #[doc = " Set the controller reference value based on the selected control mode."]
            #[doc = ""]
            #[doc = " @param value The value to set depending on the control mode. For basic"]
            #[doc = " duty cycle control this should be a value between -1 and 1"]
            #[doc = " Otherwise: Voltage Control: Voltage (volts) Velocity Control: Velocity"]
            #[doc = " (RPM) Position Control: Position (Rotations) Current Control: Current"]
            #[doc = " (Amps). The units can be changed for position and velocity by a scale"]
            #[doc = " factor using setPositionConversionFactor()."]
            #[doc = ""]
            #[doc = " @param ctrl Is the control type"]
            #[doc = ""]
            #[doc = " @param pidSlot for this command"]
            #[doc = ""]
            #[doc = " @param arbFeedforward A value from -32.0 to 32.0 which is a voltage"]
            #[doc = " applied to the motor after the result of the specified control mode. The"]
            #[doc = " units for the parameter is Volts. This value is set after the control"]
            #[doc = " mode, but before any current limits or ramp rates."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController12SetReferenceEdNS_19CANSparkMaxLowLevel11ControlTypeEidNS0_10ArbFFUnitsE"]
            pub fn SparkMaxPIDController_SetReference(
                this: *mut root::rev::SparkMaxPIDController,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: root::rev::SparkMaxPIDController_ArbFFUnits,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " NOTE: As of the 2022 FRC season, the firmware only supports the"]
            #[doc = " trapezoidal motion profiling acceleration strategy."]
            #[doc = ""]
            #[doc = " Configure the acceleration strategy used to control acceleration on the"]
            #[doc = " motor."]
            #[doc = ""]
            #[doc = " @param accelStrategy The acceleration strategy to use for the"]
            #[doc = " automatically generated motion profile"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController27SetSmartMotionAccelStrategyENS0_13AccelStrategyEi"]
            pub fn SparkMaxPIDController_SetSmartMotionAccelStrategy(
                this: *mut root::rev::SparkMaxPIDController,
                accelStrategy: root::rev::SparkMaxPIDController_AccelStrategy,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the acceleration strategy used to control acceleration on the motor."]
            #[doc = " The current strategy is trapezoidal motion profiling."]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return The acceleration strategy to use for the automatically generated"]
            #[doc = " motion profile"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController27GetSmartMotionAccelStrategyEi"]
            pub fn SparkMaxPIDController_GetSmartMotionAccelStrategy(
                this: *const root::rev::SparkMaxPIDController,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxPIDController_AccelStrategy;
        }
        impl SparkMaxPIDController {
            #[inline]
            pub unsafe fn SetReference(
                &mut self,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: root::rev::SparkMaxPIDController_ArbFFUnits,
            ) -> root::rev::REVLibError {
                SparkMaxPIDController_SetReference(
                    self,
                    value,
                    ctrl,
                    pidSlot,
                    arbFeedforward,
                    arbFFUnits,
                )
            }
            #[inline]
            pub unsafe fn SetSmartMotionAccelStrategy(
                &mut self,
                accelStrategy: root::rev::SparkMaxPIDController_AccelStrategy,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                SparkMaxPIDController_SetSmartMotionAccelStrategy(self, accelStrategy, slotID)
            }
            #[inline]
            pub unsafe fn GetSmartMotionAccelStrategy(
                &self,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxPIDController_AccelStrategy {
                SparkMaxPIDController_GetSmartMotionAccelStrategy(self, slotID)
            }
        }
        extern "C" {
            #[doc = " Set the controller reference value based on the selected control mode."]
            #[doc = ""]
            #[doc = " @param value The value to set depending on the control mode. For basic"]
            #[doc = " duty cycle control this should be a value between -1 and 1"]
            #[doc = " Otherwise: Voltage Control: Voltage (volts) Velocity Control: Velocity"]
            #[doc = " (RPM) Position Control: Position (Rotations) Current Control: Current"]
            #[doc = " (Amps). The units can be changed for position and velocity by a scale"]
            #[doc = " factor using setPositionConversionFactor()."]
            #[doc = ""]
            #[doc = " @param ctrl Is the control type"]
            #[doc = ""]
            #[doc = " @param pidSlot for this command"]
            #[doc = ""]
            #[doc = " @param arbFeedforward A value from -32.0 to 32.0 which is a voltage"]
            #[doc = " applied to the motor after the result of the specified control mode. The"]
            #[doc = " units for the parameter is Volts. This value is set after the control"]
            #[doc = " mode, but before any current limits or ramp rates."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[doc = " @deprecated Use SparkMaxPIDController::SetReference(double,"]
            #[doc = " CANSparkMax::ControlType, int, double, SparkMaxPIDController::ArbFFUnits)"]
            #[doc = " instead"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController12SetReferenceEdNS_11ControlTypeEidNS_16CANPIDController10ArbFFUnitsE"]
            pub fn SparkMaxPIDController_SetReference1(
                this: *mut ::std::os::raw::c_void,
                value: f64,
                ctrl: root::rev::ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: root::rev::CANPIDController_ArbFFUnits,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Proportional Gain constant of the PIDF controller on the SPARK"]
            #[doc = " MAX. This uses the Set Parameter API and should be used infrequently. The"]
            #[doc = " parameter does not presist unless burnFlash() is called.  The recommended"]
            #[doc = " method to configure this parameter is use to SPARK MAX GUI to tune and"]
            #[doc = " save parameters."]
            #[doc = ""]
            #[doc = " @param gain The proportional gain value, must be positive"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController4SetPEdi"]
            pub fn SparkMaxPIDController_SetP(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Integral Gain constant of the PIDF controller on the SPARK MAX."]
            #[doc = " This uses the Set Parameter API and should be used infrequently. The"]
            #[doc = " parameter does not presist unless burnFlash() is called.  The recommended"]
            #[doc = " method to configure this parameter is use to SPARK MAX GUI to tune and"]
            #[doc = " save parameters."]
            #[doc = ""]
            #[doc = " @param gain The integral gain value, must be positive"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController4SetIEdi"]
            pub fn SparkMaxPIDController_SetI(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Derivative Gain constant of the PIDF controller on the SPARK MAX."]
            #[doc = " This uses the Set Parameter API and should be used infrequently. The"]
            #[doc = " parameter does not presist unless burnFlash() is called.  The recommended"]
            #[doc = " method to configure this parameter is use to SPARK MAX GUI to tune and"]
            #[doc = " save parameters."]
            #[doc = ""]
            #[doc = " @param gain The derivative gain value, must be positive"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController4SetDEdi"]
            pub fn SparkMaxPIDController_SetD(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Derivative Filter constant of the PIDF controller on the SPARK"]
            #[doc = " MAX. This uses the Set Parameter API and should be used infrequently. The"]
            #[doc = " parameter does not presist unless burnFlash() is called."]
            #[doc = ""]
            #[doc = " @param gain The derivative filter value, must be a positive number"]
            #[doc = " between 0 and 1"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController10SetDFilterEdi"]
            pub fn SparkMaxPIDController_SetDFilter(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Feed-froward Gain constant of the PIDF controller on the SPARK"]
            #[doc = " MAX. This uses the Set Parameter API and should be used infrequently. The"]
            #[doc = " parameter does not presist unless burnFlash() is called.  The recommended"]
            #[doc = " method to configure this parameter is use to SPARK MAX GUI to tune and"]
            #[doc = " save parameters."]
            #[doc = ""]
            #[doc = " @param gain The feed-forward gain value"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController5SetFFEdi"]
            pub fn SparkMaxPIDController_SetFF(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the IZone range of the PIDF controller on the SPARK MAX. This value"]
            #[doc = " specifies the range the |error| must be within for the integral constant"]
            #[doc = " to take effect."]
            #[doc = ""]
            #[doc = " This uses the Set Parameter API and should be used infrequently."]
            #[doc = " The parameter does not presist unless burnFlash() is called."]
            #[doc = " The recommended method to configure this parameter is to use the"]
            #[doc = " SPARK MAX GUI to tune and save parameters."]
            #[doc = ""]
            #[doc = " @param IZone The IZone value, must be positive. Set to 0 to disable"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController8SetIZoneEdi"]
            pub fn SparkMaxPIDController_SetIZone(
                this: *mut ::std::os::raw::c_void,
                IZone: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the min amd max output for the closed loop mode."]
            #[doc = ""]
            #[doc = " This uses the Set Parameter API and should be used infrequently."]
            #[doc = " The parameter does not presist unless burnFlash() is called."]
            #[doc = " The recommended method to configure this parameter is to use the"]
            #[doc = " SPARK MAX GUI to tune and save parameters."]
            #[doc = ""]
            #[doc = " @param min Reverse power minimum to allow the controller to output"]
            #[doc = ""]
            #[doc = " @param max Forward power maximum to allow the controller to output"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController14SetOutputRangeEddi"]
            pub fn SparkMaxPIDController_SetOutputRange(
                this: *mut ::std::os::raw::c_void,
                min: f64,
                max: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the Proportional Gain constant of the PIDF controller on the SPARK"]
            #[doc = " MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double P Gain value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController4GetPEi"]
            pub fn SparkMaxPIDController_GetP(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Integral Gain constant of the PIDF controller on the SPARK MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double I Gain value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController4GetIEi"]
            pub fn SparkMaxPIDController_GetI(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Derivative Gain constant of the PIDF controller on the SPARK MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double D Gain value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController4GetDEi"]
            pub fn SparkMaxPIDController_GetD(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Derivative Filter constant of the PIDF controller on the SPARK"]
            #[doc = " MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double D Filter value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController10GetDFilterEi"]
            pub fn SparkMaxPIDController_GetDFilter(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Feed-forward Gain constant of the PIDF controller on the SPARK"]
            #[doc = " MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double F Gain value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController5GetFFEi"]
            pub fn SparkMaxPIDController_GetFF(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the IZone constant of the PIDF controller on the SPARK MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double IZone value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController8GetIZoneEi"]
            pub fn SparkMaxPIDController_GetIZone(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the min output of the PIDF controller on the SPARK MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double min value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController12GetOutputMinEi"]
            pub fn SparkMaxPIDController_GetOutputMin(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the max output of the PIDF controller on the SPARK MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return double max value"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController12GetOutputMaxEi"]
            pub fn SparkMaxPIDController_GetOutputMax(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Configure the maximum velocity of the SmartMotion mode. This is the"]
            #[doc = " velocity that is reached in the middle of the profile and is what the"]
            #[doc = " motor should spend most of its time at"]
            #[doc = ""]
            #[doc = " @param maxVel The maxmimum cruise velocity for the motion profile in RPM"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController25SetSmartMotionMaxVelocityEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionMaxVelocity(
                this: *mut ::std::os::raw::c_void,
                maxVel: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Configure the maximum acceleration of the SmartMotion mode. This is the"]
            #[doc = " accleration that the motor velocity will increase at until the max"]
            #[doc = " velocity is reached"]
            #[doc = ""]
            #[doc = " @param maxAccel The maxmimum acceleration for the motion profile in RPM"]
            #[doc = " per second"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController22SetSmartMotionMaxAccelEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionMaxAccel(
                this: *mut ::std::os::raw::c_void,
                maxAccel: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Configure the mimimum velocity of the SmartMotion mode. Any requested"]
            #[doc = " velocities below this value will be set to 0."]
            #[doc = ""]
            #[doc = " @param minVel The minimum velocity for the motion profile in RPM"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController31SetSmartMotionMinOutputVelocityEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionMinOutputVelocity(
                this: *mut ::std::os::raw::c_void,
                minVel: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Configure the allowed closed loop error of SmartMotion mode. This value"]
            #[doc = " is how much deviation from your setpoint is tolerated and is useful in"]
            #[doc = " preventing oscillation around your setpoint."]
            #[doc = ""]
            #[doc = " @param allowedErr The allowed deviation for your setpoint vs actual"]
            #[doc = " position in rotations"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController36SetSmartMotionAllowedClosedLoopErrorEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionAllowedClosedLoopError(
                this: *mut ::std::os::raw::c_void,
                allowedErr: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " NOTE: As of the 2022 FRC season, the firmware only supports the"]
            #[doc = " trapezoidal motion profiling acceleration strategy."]
            #[doc = ""]
            #[doc = " Configure the acceleration strategy used to control acceleration on the"]
            #[doc = " motor."]
            #[doc = ""]
            #[doc = " @param accelStrategy The acceleration strategy to use for the"]
            #[doc = " automatically generated motion profile"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[doc = ""]
            #[doc = " @deprecated Use"]
            #[doc = " SetSmartMotionAccelStrategy(SparkMaxPIDController::AccelStrategy, int)"]
            #[doc = " instead"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController27SetSmartMotionAccelStrategyENS_16CANPIDController13AccelStrategyEi"]
            pub fn SparkMaxPIDController_SetSmartMotionAccelStrategy1(
                this: *mut ::std::os::raw::c_void,
                accelStrategy: root::rev::CANPIDController_AccelStrategy,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the maximum velocity of the SmartMotion mode. This is the velocity"]
            #[doc = " that is reached in the middle of the profile and is what the motor should"]
            #[doc = " spend most of its time at"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return The maxmimum cruise velocity for the motion profile in RPM"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController25GetSmartMotionMaxVelocityEi"]
            pub fn SparkMaxPIDController_GetSmartMotionMaxVelocity(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the maximum acceleration of the SmartMotion mode. This is the"]
            #[doc = " accleration that the motor velocity will increase at until the max"]
            #[doc = " velocity is reached"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return The maxmimum acceleration for the motion profile in RPM per"]
            #[doc = " second"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController22GetSmartMotionMaxAccelEi"]
            pub fn SparkMaxPIDController_GetSmartMotionMaxAccel(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the mimimum velocity of the SmartMotion mode. Any requested"]
            #[doc = " velocities below this value will be set to 0."]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return The minimum velocity for the motion profile in RPM"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController31GetSmartMotionMinOutputVelocityEi"]
            pub fn SparkMaxPIDController_GetSmartMotionMinOutputVelocity(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the allowed closed loop error of SmartMotion mode. This value is how"]
            #[doc = " much deviation from your setpoint is tolerated and is useful in"]
            #[doc = " preventing oscillation around your setpoint."]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return The allowed deviation for your setpoint vs actual position in"]
            #[doc = " rotations"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController36GetSmartMotionAllowedClosedLoopErrorEi"]
            pub fn SparkMaxPIDController_GetSmartMotionAllowedClosedLoopError(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Configure the maximum I accumulator of the PID controller. This value is"]
            #[doc = " used to constrain the I accumulator to help manage integral wind-up"]
            #[doc = ""]
            #[doc = " @param iMaxAccum The max value to contrain the I accumulator to"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController12SetIMaxAccumEdi"]
            pub fn SparkMaxPIDController_SetIMaxAccum(
                this: *mut ::std::os::raw::c_void,
                iMaxAccum: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the maximum I accumulator of the PID controller. This value is used"]
            #[doc = " to constrain the I accumulator to help manage integral wind-up"]
            #[doc = ""]
            #[doc = " @param slotID Is the gain schedule slot, the value is a number"]
            #[doc = " between 0 and 3. Each slot has its own set of gain values and"]
            #[doc = " can be changed in each control frame using SetReference()."]
            #[doc = ""]
            #[doc = " @return The max value to contrain the I accumulator to"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController12GetIMaxAccumEi"]
            pub fn SparkMaxPIDController_GetIMaxAccum(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the I accumulator of the PID controller. This is useful when wishing"]
            #[doc = " to force a reset on the I accumulator of the PID controller. You can also"]
            #[doc = " preset values to see how it will respond to certain I characteristics"]
            #[doc = ""]
            #[doc = " To use this function, the controller must be in a closed loop control"]
            #[doc = " mode by calling setReference()"]
            #[doc = ""]
            #[doc = " @param iAccum The value to set the I accumulator to"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController9SetIAccumEd"]
            pub fn SparkMaxPIDController_SetIAccum(
                this: *mut ::std::os::raw::c_void,
                iAccum: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the I accumulator of the PID controller. This is useful when wishing"]
            #[doc = " to see what the I accumulator value is to help with PID tuning"]
            #[doc = ""]
            #[doc = " @return The value of the I accumulator"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController9GetIAccumEv"]
            pub fn SparkMaxPIDController_GetIAccum(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the controller's feedback device."]
            #[doc = ""]
            #[doc = " The default feedback device is assumed to be the integrated encoder."]
            #[doc = " This is used to changed to another feedback device for the controller,"]
            #[doc = " such as an analog sensor."]
            #[doc = ""]
            #[doc = " If there is a limited range on the feedback sensor that should be"]
            #[doc = " observed by the PIDController, it can be set by calling"]
            #[doc = " SetFeedbackSensorRange() on the sensor object."]
            #[doc = ""]
            #[doc = " @param sensor The sensor to be used as a feedback device"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController17SetFeedbackDeviceERKNS_9CANSensorE"]
            pub fn SparkMaxPIDController_SetFeedbackDevice(
                this: *mut ::std::os::raw::c_void,
                sensor: *const root::rev::CANSensor,
            ) -> root::rev::REVLibError;
        }
        #[doc = " Get an instance of this class by using CANSparkMax::GetEncoder() or"]
        #[doc = " CANSparkMax::GetEncoder(SparkMaxRelativeEncoder::Type, int)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxRelativeEncoder {
            pub _base: root::rev::RelativeEncoder,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_countsPerRev: ::std::os::raw::c_int,
        }
        pub const SparkMaxRelativeEncoder_Type_kNoSensor: root::rev::SparkMaxRelativeEncoder_Type =
            0;
        pub const SparkMaxRelativeEncoder_Type_kHallSensor:
            root::rev::SparkMaxRelativeEncoder_Type = 1;
        pub const SparkMaxRelativeEncoder_Type_kQuadrature:
            root::rev::SparkMaxRelativeEncoder_Type = 2;
        #[doc = " The type of encoder connected to a SPARK MAX"]
        pub type SparkMaxRelativeEncoder_Type = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxRelativeEncoder() {
            assert_eq!(
                ::std::mem::size_of::<SparkMaxRelativeEncoder>(),
                24usize,
                concat!("Size of: ", stringify!(SparkMaxRelativeEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxRelativeEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxRelativeEncoder))
            );
            fn test_field_m_device() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxRelativeEncoder>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxRelativeEncoder),
                        "::",
                        stringify!(m_device)
                    )
                );
            }
            test_field_m_device();
            fn test_field_m_countsPerRev() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SparkMaxRelativeEncoder>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_countsPerRev) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparkMaxRelativeEncoder),
                        "::",
                        stringify!(m_countsPerRev)
                    )
                );
            }
            test_field_m_countsPerRev();
        }
        extern "C" {
            #[doc = " Get the position of the motor. This returns the native units"]
            #[doc = " of 'rotations' by default, and can be changed by a scale factor"]
            #[doc = " using setPositionConversionFactor()."]
            #[doc = ""]
            #[doc = " @return Number of rotations of the motor"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder11GetPositionEv"]
            pub fn SparkMaxRelativeEncoder_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the velocity of the motor. This returns the native units"]
            #[doc = " of 'RPM' by default, and can be changed by a scale factor"]
            #[doc = " using setVelocityConversionFactor()."]
            #[doc = ""]
            #[doc = " @return Number the RPM of the motor"]
            #[doc = ""]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder11GetVelocityEv"]
            pub fn SparkMaxRelativeEncoder_GetVelocity(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the position of the encoder."]
            #[doc = ""]
            #[doc = " @param position Number of rotations of the motor"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder11SetPositionEd"]
            pub fn SparkMaxRelativeEncoder_SetPosition(
                this: *mut ::std::os::raw::c_void,
                position: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for position of the encoder. Multiplied by the"]
            #[doc = " native output units to give you position"]
            #[doc = ""]
            #[doc = " @param factor The conversion factor to multiply the native units by"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder27SetPositionConversionFactorEd"]
            pub fn SparkMaxRelativeEncoder_SetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for velocity of the encoder. Multiplied by the"]
            #[doc = " native output units to give you velocity"]
            #[doc = ""]
            #[doc = " @param factor The conversion factor to multiply the native units by"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder27SetVelocityConversionFactorEd"]
            pub fn SparkMaxRelativeEncoder_SetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the conversion factor for position of the encoder. Multiplied by the"]
            #[doc = " native output units to give you position"]
            #[doc = ""]
            #[doc = " @return The conversion factor for position"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder27GetPositionConversionFactorEv"]
            pub fn SparkMaxRelativeEncoder_GetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the conversion factor for velocity of the encoder. Multiplied by the"]
            #[doc = " native output units to give you velocity"]
            #[doc = ""]
            #[doc = " @return The conversion factor for velocity"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder27GetVelocityConversionFactorEv"]
            pub fn SparkMaxRelativeEncoder_GetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the average sampling depth for a quadrature encoder. This value"]
            #[doc = " sets the number of samples in the average for velocity readings. This"]
            #[doc = " can be any value from 1 to 64."]
            #[doc = ""]
            #[doc = " When the SparkMax controller is in Brushless mode, this"]
            #[doc = " will not change any behavior."]
            #[doc = ""]
            #[doc = " @param depth The average sampling depth between 1 and 64 (default)"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder15SetAverageDepthEj"]
            pub fn SparkMaxRelativeEncoder_SetAverageDepth(
                this: *mut ::std::os::raw::c_void,
                depth: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the measurement period for velocity measurements of a quadrature"]
            #[doc = " encoder. When the SparkMax controller is in Brushless mode, this will not"]
            #[doc = " change any behavior."]
            #[doc = ""]
            #[doc = " The basic formula to calculate velocity is change in positon / change in"]
            #[doc = " time. This parameter sets the change in time for measurement."]
            #[doc = ""]
            #[doc = " @param period_ms Measurement period in milliseconds. This number may be"]
            #[doc = " between 1 and 100 (default)."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder20SetMeasurementPeriodEj"]
            pub fn SparkMaxRelativeEncoder_SetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
                period_ms: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the average sampling depth for a quadrature encoder."]
            #[doc = ""]
            #[doc = " @return The average sampling depth"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder15GetAverageDepthEv"]
            pub fn SparkMaxRelativeEncoder_GetAverageDepth(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the number of samples for reading from a quadrature encoder. This"]
            #[doc = " value sets the number of samples in the average for velocity readings."]
            #[doc = ""]
            #[doc = " @return Measurement period in microseconds"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder20GetMeasurementPeriodEv"]
            pub fn SparkMaxRelativeEncoder_GetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the counts per revolution of the quadrature encoder."]
            #[doc = ""]
            #[doc = " For a description on the difference between CPR, PPR, etc. go to"]
            #[doc = " https://www.cuidevices.com/blog/what-is-encoder-ppr-cpr-and-lpr"]
            #[doc = ""]
            #[doc = " @return Counts per revolution"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder22GetCountsPerRevolutionEv"]
            pub fn SparkMaxRelativeEncoder_GetCountsPerRevolution(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Set the phase of the MotorFeedbackSensor so that it is set to be in"]
            #[doc = " phase with the motor itself. This only works for quadrature"]
            #[doc = " encoders. This will throw an error if the user tries to set"]
            #[doc = " inverted while the SparkMax is Brushless and using the hall"]
            #[doc = " effect sensor."]
            #[doc = ""]
            #[doc = " @param inverted The phase of the encoder"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder11SetInvertedEb"]
            pub fn SparkMaxRelativeEncoder_SetInverted(
                this: *mut ::std::os::raw::c_void,
                inverted: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the phase of the MotorFeedbackSensor. This will just return false"]
            #[doc = " if the user tries to get inverted while the SparkMax is"]
            #[doc = " Brushless and using the hall effect sensor."]
            #[doc = ""]
            #[doc = " @return The phase of the encoder"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder11GetInvertedEv"]
            pub fn SparkMaxRelativeEncoder_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANSparkMax {
            pub _base: root::rev::CANSparkMaxLowLevel,
            pub m_setpoint: f64,
            pub m_relativeEncoderCreated: root::std::atomic<bool>,
            pub m_alternateEncoderCreated: root::std::atomic<bool>,
            pub m_analogSensorCreated: root::std::atomic<bool>,
            pub m_pidControllerCreated: root::std::atomic<bool>,
            pub m_forwardLimitSwitchCreated: root::std::atomic<bool>,
            pub m_reverseLimitSwitchCreated: root::std::atomic<bool>,
        }
        pub const CANSparkMax_IdleMode_kCoast: root::rev::CANSparkMax_IdleMode = 0;
        pub const CANSparkMax_IdleMode_kBrake: root::rev::CANSparkMax_IdleMode = 1;
        pub type CANSparkMax_IdleMode = ::std::os::raw::c_int;
        pub const CANSparkMax_InputMode_kPWM: root::rev::CANSparkMax_InputMode = 0;
        pub const CANSparkMax_InputMode_kCAN: root::rev::CANSparkMax_InputMode = 1;
        #[doc = " @deprecated You don't need this"]
        pub type CANSparkMax_InputMode = ::std::os::raw::c_int;
        pub const CANSparkMax_SoftLimitDirection_kForward:
            root::rev::CANSparkMax_SoftLimitDirection = 0;
        pub const CANSparkMax_SoftLimitDirection_kReverse:
            root::rev::CANSparkMax_SoftLimitDirection = 1;
        pub type CANSparkMax_SoftLimitDirection = ::std::os::raw::c_int;
        pub const CANSparkMax_FaultID_kBrownout: root::rev::CANSparkMax_FaultID = 0;
        pub const CANSparkMax_FaultID_kOvercurrent: root::rev::CANSparkMax_FaultID = 1;
        pub const CANSparkMax_FaultID_kIWDTReset: root::rev::CANSparkMax_FaultID = 2;
        pub const CANSparkMax_FaultID_kMotorFault: root::rev::CANSparkMax_FaultID = 3;
        pub const CANSparkMax_FaultID_kSensorFault: root::rev::CANSparkMax_FaultID = 4;
        pub const CANSparkMax_FaultID_kStall: root::rev::CANSparkMax_FaultID = 5;
        pub const CANSparkMax_FaultID_kEEPROMCRC: root::rev::CANSparkMax_FaultID = 6;
        pub const CANSparkMax_FaultID_kCANTX: root::rev::CANSparkMax_FaultID = 7;
        pub const CANSparkMax_FaultID_kCANRX: root::rev::CANSparkMax_FaultID = 8;
        pub const CANSparkMax_FaultID_kHasReset: root::rev::CANSparkMax_FaultID = 9;
        pub const CANSparkMax_FaultID_kDRVFault: root::rev::CANSparkMax_FaultID = 10;
        pub const CANSparkMax_FaultID_kOtherFault: root::rev::CANSparkMax_FaultID = 11;
        pub const CANSparkMax_FaultID_kSoftLimitFwd: root::rev::CANSparkMax_FaultID = 12;
        pub const CANSparkMax_FaultID_kSoftLimitRev: root::rev::CANSparkMax_FaultID = 13;
        pub const CANSparkMax_FaultID_kHardLimitFwd: root::rev::CANSparkMax_FaultID = 14;
        pub const CANSparkMax_FaultID_kHardLimitRev: root::rev::CANSparkMax_FaultID = 15;
        pub type CANSparkMax_FaultID = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMax_ExternalFollower {
            pub arbId: ::std::os::raw::c_int,
            pub configId: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMax_ExternalFollower() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMax_ExternalFollower>(),
                8usize,
                concat!("Size of: ", stringify!(CANSparkMax_ExternalFollower))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMax_ExternalFollower>(),
                4usize,
                concat!("Alignment of ", stringify!(CANSparkMax_ExternalFollower))
            );
            fn test_field_arbId() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMax_ExternalFollower>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).arbId) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax_ExternalFollower),
                        "::",
                        stringify!(arbId)
                    )
                );
            }
            test_field_arbId();
            fn test_field_configId() {
                assert_eq!(
                    unsafe {
                        let uninit =
                            ::std::mem::MaybeUninit::<CANSparkMax_ExternalFollower>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).configId) as usize - ptr as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax_ExternalFollower),
                        "::",
                        stringify!(configId)
                    )
                );
            }
            test_field_configId();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev11CANSparkMax17kFollowerDisabledE"]
            pub static CANSparkMax_kFollowerDisabled: root::rev::CANSparkMax_ExternalFollower;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev11CANSparkMax17kFollowerSparkMaxE"]
            pub static CANSparkMax_kFollowerSparkMax: root::rev::CANSparkMax_ExternalFollower;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16kFollowerPhoenixE"]
            pub static CANSparkMax_kFollowerPhoenix: root::rev::CANSparkMax_ExternalFollower;
        }
        #[test]
        fn bindgen_test_layout_CANSparkMax() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMax>(),
                48usize,
                concat!("Size of: ", stringify!(CANSparkMax))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMax>(),
                8usize,
                concat!("Alignment of ", stringify!(CANSparkMax))
            );
            fn test_field_m_setpoint() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_setpoint) as usize - ptr as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_setpoint)
                    )
                );
            }
            test_field_m_setpoint();
            fn test_field_m_relativeEncoderCreated() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_relativeEncoderCreated) as usize
                            - ptr as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_relativeEncoderCreated)
                    )
                );
            }
            test_field_m_relativeEncoderCreated();
            fn test_field_m_alternateEncoderCreated() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_alternateEncoderCreated) as usize
                            - ptr as usize
                    },
                    41usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_alternateEncoderCreated)
                    )
                );
            }
            test_field_m_alternateEncoderCreated();
            fn test_field_m_analogSensorCreated() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_analogSensorCreated) as usize - ptr as usize
                    },
                    42usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_analogSensorCreated)
                    )
                );
            }
            test_field_m_analogSensorCreated();
            fn test_field_m_pidControllerCreated() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_pidControllerCreated) as usize - ptr as usize
                    },
                    43usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_pidControllerCreated)
                    )
                );
            }
            test_field_m_pidControllerCreated();
            fn test_field_m_forwardLimitSwitchCreated() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_forwardLimitSwitchCreated) as usize
                            - ptr as usize
                    },
                    44usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_forwardLimitSwitchCreated)
                    )
                );
            }
            test_field_m_forwardLimitSwitchCreated();
            fn test_field_m_reverseLimitSwitchCreated() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CANSparkMax>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_reverseLimitSwitchCreated) as usize
                            - ptr as usize
                    },
                    45usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CANSparkMax),
                        "::",
                        stringify!(m_reverseLimitSwitchCreated)
                    )
                );
            }
            test_field_m_reverseLimitSwitchCreated();
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the encoder connected to the"]
            #[doc = " encoder pins or front port of the SPARK MAX."]
            #[doc = ""]
            #[doc = " The default encoder type is assumed to be the hall effect for brushless."]
            #[doc = " This can be modified for brushed DC to use an quadrature encoder."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10GetEncoderENS_23SparkMaxRelativeEncoder4TypeEi"]
            pub fn CANSparkMax_GetEncoder(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::SparkMaxRelativeEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the encoder connected to the"]
            #[doc = " encoder pins or front port of the SPARK MAX."]
            #[doc = ""]
            #[doc = " The default encoder type is assumed to be the hall effect for brushless."]
            #[doc = " This can be modified for brushed DC to use an quadrature encoder."]
            #[doc = ""]
            #[doc = " @deprecated Use CANSparkMax::GetEncoder(SparkMaxRelativeEncoder::Type,"]
            #[doc = " int) instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10GetEncoderENS_10CANEncoder11EncoderTypeEi"]
            pub fn CANSparkMax_GetEncoder1(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::CANEncoder_EncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a quadrature encoder connected to"]
            #[doc = " the alternate encoder mode data port pins. These are defined as:"]
            #[doc = ""]
            #[doc = " Pin 4 (Forward Limit Switch): Index"]
            #[doc = " Pin 6 (Multi-function): Encoder A"]
            #[doc = " Pin 8 (Reverse Limit Switch): Encoder B"]
            #[doc = ""]
            #[doc = " This call will disable support for the limit switch inputs."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetAlternateEncoderEi"]
            pub fn CANSparkMax_GetAlternateEncoder(
                this: *mut root::rev::CANSparkMax,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a quadrature encoder connected to"]
            #[doc = " the alternate encoder mode data port pins. These are defined as:"]
            #[doc = ""]
            #[doc = " Pin 4 (Forward Limit Switch): Index"]
            #[doc = " Pin 6 (Multi-function): Encoder A"]
            #[doc = " Pin 8 (Reverse Limit Switch): Encoder B"]
            #[doc = ""]
            #[doc = " This call will disable support for the limit switch inputs."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetAlternateEncoderENS_24SparkMaxAlternateEncoder4TypeEi"]
            pub fn CANSparkMax_GetAlternateEncoder1(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::SparkMaxAlternateEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a quadrature encoder connected to"]
            #[doc = " the alternate encoder mode data port pins. These are defined as:"]
            #[doc = ""]
            #[doc = " Pin 4 (Forward Limit Switch): Index"]
            #[doc = " Pin 6 (Multi-function): Encoder A"]
            #[doc = " Pin 8 (Reverse Limit Switch): Encoder B"]
            #[doc = ""]
            #[doc = " This call will disable support for the limit switch inputs."]
            #[doc = ""]
            #[doc = " @deprecated Use"]
            #[doc = " CANSparkMax::GetAlternateEncoder(SparkMaxAlternateEncoder::Type, int)"]
            #[doc = " instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetAlternateEncoderENS_10CANEncoder20AlternateEncoderTypeEi"]
            pub fn CANSparkMax_GetAlternateEncoder2(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::CANEncoder_AlternateEncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a connected analog sensor."]
            #[doc = " By default, the mode is set to kAbsolute, thus treating the"]
            #[doc = " sensor as an absolute sensor."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9GetAnalogENS_20SparkMaxAnalogSensor4ModeE"]
            pub fn CANSparkMax_GetAnalog(
                this: *mut root::rev::CANSparkMax,
                mode: root::rev::SparkMaxAnalogSensor_Mode,
            ) -> root::rev::SparkMaxAnalogSensor;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a connected analog sensor."]
            #[doc = ""]
            #[doc = " @deprecated Use GetAnalog(SparkMaxAnalogSensor::Mode) instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9GetAnalogENS_9CANAnalog10AnalogModeE"]
            pub fn CANSparkMax_GetAnalog1(
                this: *mut root::rev::CANSparkMax,
                mode: root::rev::CANAnalog_AnalogMode,
            ) -> root::rev::SparkMaxAnalogSensor;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the integrated PID controller."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16GetPIDControllerEv"]
            pub fn CANSparkMax_GetPIDController(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::SparkMaxPIDController;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the forward limit switch connected"]
            #[doc = " to the appropriate pins on the data port."]
            #[doc = ""]
            #[doc = " This call will disable support for the alternate encoder."]
            #[doc = ""]
            #[doc = " @param switchType Whether the limit switch is normally open or normally"]
            #[doc = " closed."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetForwardLimitSwitchENS_19SparkMaxLimitSwitch4TypeE"]
            pub fn CANSparkMax_GetForwardLimitSwitch(
                this: *mut root::rev::CANSparkMax,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the forward limit switch connected"]
            #[doc = " to the appropriate pins on the data port."]
            #[doc = ""]
            #[doc = " This call will disable support for the alternate encoder."]
            #[doc = ""]
            #[doc = " @param polarity Whether the limit switch is normally open or normally"]
            #[doc = " closed."]
            #[doc = ""]
            #[doc = " @deprecated Use"]
            #[doc = " GetForwardLimitSwitch(SparkMaxLimitSwitch::Type)"]
            #[doc = " instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetForwardLimitSwitchENS_15CANDigitalInput19LimitSwitchPolarityE"]
            pub fn CANSparkMax_GetForwardLimitSwitch1(
                this: *mut root::rev::CANSparkMax,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the reverse limit switch connected"]
            #[doc = " to the appropriate pins on the data port."]
            #[doc = ""]
            #[doc = " This call will disable support for the alternate encoder."]
            #[doc = ""]
            #[doc = " @param switchType Whether the limit switch is normally open or normally"]
            #[doc = " closed."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetReverseLimitSwitchENS_19SparkMaxLimitSwitch4TypeE"]
            pub fn CANSparkMax_GetReverseLimitSwitch(
                this: *mut root::rev::CANSparkMax,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the reverse limit switch connected"]
            #[doc = " to the appropriate pins on the data port."]
            #[doc = ""]
            #[doc = " This call will disable support for the alternate encoder."]
            #[doc = ""]
            #[doc = " @param polarity Whether the limit switch is normally open or normally"]
            #[doc = " closed."]
            #[doc = ""]
            #[doc = " @deprecated Use"]
            #[doc = " GetReverseLimitSwitch(SparkMaxLimitSwitch::Type)"]
            #[doc = " instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetReverseLimitSwitchENS_15CANDigitalInput19LimitSwitchPolarityE"]
            pub fn CANSparkMax_GetReverseLimitSwitch1(
                this: *mut root::rev::CANSparkMax,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Sets the current limit in Amps."]
            #[doc = ""]
            #[doc = " The motor controller will reduce the controller voltage output to avoid"]
            #[doc = " surpassing this limit. This limit is enabled by default and used for"]
            #[doc = " brushless only. This limit is highly recommended when using the NEO"]
            #[doc = " brushless motor."]
            #[doc = ""]
            #[doc = " The NEO Brushless Motor has a low internal resistance, which"]
            #[doc = " can mean large current spikes that could be enough to cause damage to"]
            #[doc = " the motor and controller. This current limit provides a smarter"]
            #[doc = " strategy to deal with high current draws and keep the motor and"]
            #[doc = " controller operating in a safe region."]
            #[doc = ""]
            #[doc = ""]
            #[doc = " @param limit      The current limit in Amps."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax20SetSmartCurrentLimitEj"]
            pub fn CANSparkMax_SetSmartCurrentLimit(
                this: *mut root::rev::CANSparkMax,
                limit: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the current limit in Amps."]
            #[doc = ""]
            #[doc = " The motor controller will reduce the controller voltage output to avoid"]
            #[doc = " surpassing this limit. This limit is enabled by default and used for"]
            #[doc = " brushless only. This limit is highly recommended when using the NEO"]
            #[doc = " brushless motor."]
            #[doc = ""]
            #[doc = " The NEO Brushless Motor has a low internal resistance, which"]
            #[doc = " can mean large current spikes that could be enough to cause damage to"]
            #[doc = " the motor and controller. This current limit provides a smarter"]
            #[doc = " strategy to deal with high current draws and keep the motor and"]
            #[doc = " controller operating in a safe region."]
            #[doc = ""]
            #[doc = " The controller can also limit the current based on the RPM of the motor"]
            #[doc = " in a linear fashion to help with controllability in closed loop control."]
            #[doc = " For a response that is linear the entire RPM range leave limit RPM at 0."]
            #[doc = ""]
            #[doc = ""]
            #[doc = " @param stallLimit The current limit in Amps at 0 RPM."]
            #[doc = " @param freeLimit The current limit at free speed (5700RPM for NEO)."]
            #[doc = " @param limitRPM RPM less than this value will be set to the stallLimit,"]
            #[doc = " RPM values greater than limitRPM will scale linearly to freeLimit"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax20SetSmartCurrentLimitEjjj"]
            pub fn CANSparkMax_SetSmartCurrentLimit1(
                this: *mut root::rev::CANSparkMax,
                stallLimit: ::std::os::raw::c_uint,
                freeLimit: ::std::os::raw::c_uint,
                limitRPM: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the secondary current limit in Amps."]
            #[doc = ""]
            #[doc = " The motor controller will disable the output of the controller briefly"]
            #[doc = " if the current limit is exceeded to reduce the current. This limit is"]
            #[doc = " a simplified 'on/off' controller. This limit is enabled by default"]
            #[doc = " but is set higher than the default Smart Current Limit."]
            #[doc = ""]
            #[doc = " The time the controller is off after the current limit is reached"]
            #[doc = " is determined by the parameter limitCycles, which is the number of"]
            #[doc = " PWM cycles (20kHz). The recommended value is the default of 0 which"]
            #[doc = " is the minimum time and is part of a PWM cycle from when the over"]
            #[doc = " current is detected. This allows the controller to regulate the current"]
            #[doc = " close to the limit value."]
            #[doc = ""]
            #[doc = " The total time is set by the equation"]
            #[doc = ""]
            #[doc = " @code t = (50us - t0) + 50us * limitCycles"]
            #[doc = " t = total off time after over current"]
            #[doc = " t0 = time from the start of the PWM cycle until over current is detected"]
            #[doc = " @endcode"]
            #[doc = ""]
            #[doc = ""]
            #[doc = " @param limit The current limit in Amps."]
            #[doc = " @param limitCycles The number of additional PWM cycles to turn"]
            #[doc = " the driver off after overcurrent is detected."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax24SetSecondaryCurrentLimitEdi"]
            pub fn CANSparkMax_SetSecondaryCurrentLimit(
                this: *mut root::rev::CANSparkMax,
                limit: f64,
                limitCycles: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the idle mode setting for the SPARK MAX."]
            #[doc = ""]
            #[doc = " @param mode Idle mode (coast or brake)."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11SetIdleModeENS0_8IdleModeE"]
            pub fn CANSparkMax_SetIdleMode(
                this: *mut root::rev::CANSparkMax,
                mode: root::rev::CANSparkMax_IdleMode,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Gets the idle mode setting for the SPARK MAX."]
            #[doc = ""]
            #[doc = " This uses the Get Parameter API and should be used infrequently. This"]
            #[doc = " function uses a non-blocking call and will return a cached value if the"]
            #[doc = " parameter is not returned by the timeout. The timeout can be changed by"]
            #[doc = " calling SetCANTimeout(int milliseconds)"]
            #[doc = ""]
            #[doc = " @return IdleMode Idle mode setting"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11GetIdleModeEv"]
            pub fn CANSparkMax_GetIdleMode(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::CANSparkMax_IdleMode;
        }
        extern "C" {
            #[doc = " Sets the voltage compensation setting for all modes on the SPARK MAX and"]
            #[doc = " enables voltage compensation."]
            #[doc = ""]
            #[doc = " @param nominalVoltage Nominal voltage to compensate output to"]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax25EnableVoltageCompensationEd"]
            pub fn CANSparkMax_EnableVoltageCompensation(
                this: *mut root::rev::CANSparkMax,
                nominalVoltage: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Disables the voltage compensation setting for all modes on the SPARK MAX."]
            #[doc = ""]
            #[doc = " @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax26DisableVoltageCompensationEv"]
            pub fn CANSparkMax_DisableVoltageCompensation(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the configured voltage compensation nominal voltage value"]
            #[doc = ""]
            #[doc = " @return The nominal voltage for voltage compensation mode."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax36GetVoltageCompensationNominalVoltageEv"]
            pub fn CANSparkMax_GetVoltageCompensationNominalVoltage(
                this: *mut root::rev::CANSparkMax,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Sets the ramp rate for open loop control modes."]
            #[doc = ""]
            #[doc = " This is the maximum rate at which the motor controller's output"]
            #[doc = " is allowed to change."]
            #[doc = ""]
            #[doc = " @param rate Time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19SetOpenLoopRampRateEd"]
            pub fn CANSparkMax_SetOpenLoopRampRate(
                this: *mut root::rev::CANSparkMax,
                rate: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the ramp rate for closed loop control modes."]
            #[doc = ""]
            #[doc = " This is the maximum rate at which the motor controller's output"]
            #[doc = " is allowed to change."]
            #[doc = ""]
            #[doc = " @param rate Time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21SetClosedLoopRampRateEd"]
            pub fn CANSparkMax_SetClosedLoopRampRate(
                this: *mut root::rev::CANSparkMax,
                rate: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the configured open loop ramp rate"]
            #[doc = ""]
            #[doc = " This is the maximum rate at which the motor controller's output"]
            #[doc = " is allowed to change."]
            #[doc = ""]
            #[doc = " @return rampte rate time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetOpenLoopRampRateEv"]
            pub fn CANSparkMax_GetOpenLoopRampRate(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Get the configured closed loop ramp rate"]
            #[doc = ""]
            #[doc = " This is the maximum rate at which the motor controller's output"]
            #[doc = " is allowed to change."]
            #[doc = ""]
            #[doc = " @return rampte rate time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetClosedLoopRampRateEv"]
            pub fn CANSparkMax_GetClosedLoopRampRate(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Causes this controller's output to mirror the provided leader."]
            #[doc = ""]
            #[doc = " Only voltage output is mirrored. Settings changed on the leader do not"]
            #[doc = " affect the follower."]
            #[doc = ""]
            #[doc = " Following anything other than a CAN SPARK MAX is not officially"]
            #[doc = " supported."]
            #[doc = ""]
            #[doc = " @param leader The motor controller to follow."]
            #[doc = ""]
            #[doc = " @param invert Set the follower to output opposite of the leader"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax6FollowERKS0_b"]
            pub fn CANSparkMax_Follow(
                this: *mut root::rev::CANSparkMax,
                leader: *const root::rev::CANSparkMax,
                invert: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Causes this controller's output to mirror the provided leader."]
            #[doc = ""]
            #[doc = " Only voltage output is mirrored. Settings changed on the leader do not"]
            #[doc = " affect the follower."]
            #[doc = ""]
            #[doc = " Following anything other than a CAN SPARK MAX is not officially"]
            #[doc = " supported."]
            #[doc = ""]
            #[doc = " @param leader   The type of motor controller to follow (Talon SRX, Spark"]
            #[doc = "                 Max, etc.)."]
            #[doc = " @param deviceID The CAN ID of the device to follow."]
            #[doc = ""]
            #[doc = " @param invert Set the follower to output opposite of the leader"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax6FollowENS0_16ExternalFollowerEib"]
            pub fn CANSparkMax_Follow1(
                this: *mut root::rev::CANSparkMax,
                leader: root::rev::CANSparkMax_ExternalFollower,
                deviceID: ::std::os::raw::c_int,
                invert: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Returns whether the controller is following another controller"]
            #[doc = ""]
            #[doc = " @return True if this device is following another controller"]
            #[doc = " false otherwise"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10IsFollowerEv"]
            pub fn CANSparkMax_IsFollower(this: *mut root::rev::CANSparkMax) -> bool;
        }
        extern "C" {
            #[doc = " Returns fault bits."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9GetFaultsEv"]
            pub fn CANSparkMax_GetFaults(this: *mut root::rev::CANSparkMax) -> u16;
        }
        extern "C" {
            #[doc = " Returns sticky fault bits."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax15GetStickyFaultsEv"]
            pub fn CANSparkMax_GetStickyFaults(this: *mut root::rev::CANSparkMax) -> u16;
        }
        extern "C" {
            #[doc = " Returns whether the fault with the given ID occurred."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax8GetFaultENS0_7FaultIDE"]
            pub fn CANSparkMax_GetFault(
                this: *const root::rev::CANSparkMax,
                faultID: root::rev::CANSparkMax_FaultID,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns whether the sticky fault with the given ID occurred."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax14GetStickyFaultENS0_7FaultIDE"]
            pub fn CANSparkMax_GetStickyFault(
                this: *const root::rev::CANSparkMax,
                faultID: root::rev::CANSparkMax_FaultID,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns the voltage fed into the motor controller."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax13GetBusVoltageEv"]
            pub fn CANSparkMax_GetBusVoltage(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Returns motor controller's output duty cycle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16GetAppliedOutputEv"]
            pub fn CANSparkMax_GetAppliedOutput(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Returns motor controller's output current in Amps."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16GetOutputCurrentEv"]
            pub fn CANSparkMax_GetOutputCurrent(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Returns the motor temperature in Celsius."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetMotorTemperatureEv"]
            pub fn CANSparkMax_GetMotorTemperature(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Clears all non-sticky faults."]
            #[doc = ""]
            #[doc = " Sticky faults must be cleared by resetting the motor controller."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11ClearFaultsEv"]
            pub fn CANSparkMax_ClearFaults(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Writes all settings to flash."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9BurnFlashEv"]
            pub fn CANSparkMax_BurnFlash(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets timeout for sending CAN messages. A timeout of 0 also means that"]
            #[doc = " error handling will be done automatically by registering calls and"]
            #[doc = " waiting for responses, rather than needing to call GetLastError()."]
            #[doc = ""]
            #[doc = " @param milliseconds The timeout in milliseconds."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax13SetCANTimeoutEi"]
            pub fn CANSparkMax_SetCANTimeout(
                this: *mut root::rev::CANSparkMax,
                milliseconds: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Enable soft limits"]
            #[doc = ""]
            #[doc = " @param direction the direction of motion to restrict"]
            #[doc = ""]
            #[doc = " @param enable set true to enable soft limits"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax15EnableSoftLimitENS0_18SoftLimitDirectionEb"]
            pub fn CANSparkMax_EnableSoftLimit(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                enable: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Returns true if the soft limit is enabled."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax18IsSoftLimitEnabledENS0_18SoftLimitDirectionE"]
            pub fn CANSparkMax_IsSoftLimitEnabled(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Set the soft limit based on position. The default unit is"]
            #[doc = " rotations, but will match the unit scaling set by the user."]
            #[doc = ""]
            #[doc = " Note that this value is not scaled internally so care must"]
            #[doc = " be taken to make sure these units match the desired conversion"]
            #[doc = ""]
            #[doc = " @param direction the direction of motion to restrict"]
            #[doc = ""]
            #[doc = " @param limit position soft limit of the controller"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax12SetSoftLimitENS0_18SoftLimitDirectionEd"]
            pub fn CANSparkMax_SetSoftLimit(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                limit: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the soft limit setting in the controller"]
            #[doc = ""]
            #[doc = " @param direction the direction of motion to restrict"]
            #[doc = ""]
            #[doc = " @return position soft limit setting of the controller"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax12GetSoftLimitENS0_18SoftLimitDirectionE"]
            pub fn CANSparkMax_GetSoftLimit(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> f64;
        }
        extern "C" {
            #[doc = " All device errors are tracked on a per thread basis for all"]
            #[doc = " devices in that thread. This is meant to be called"]
            #[doc = " immediately following another call that has the possibility"]
            #[doc = " of throwing an error to validate if an  error has occurred."]
            #[doc = ""]
            #[doc = " @return the last error that was generated."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax12GetLastErrorEv"]
            pub fn CANSparkMax_GetLastError(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Create a new object to control a SPARK MAX motor Controller"]
            #[doc = ""]
            #[doc = " @param deviceID The device ID."]
            #[doc = " @param type     The motor type connected to the controller. Brushless"]
            #[doc = "                 motor wires must be connected to their matching colors,"]
            #[doc = " and the hall sensor must be plugged in. Brushed motors must be connected"]
            #[doc = "                 to the Red and Black terminals only."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMaxC1EiNS_19CANSparkMaxLowLevel9MotorTypeE"]
            pub fn CANSparkMax_CANSparkMax(
                this: *mut root::rev::CANSparkMax,
                deviceID: ::std::os::raw::c_int,
                type_: root::rev::CANSparkMaxLowLevel_MotorType,
            );
        }
        impl CANSparkMax {
            #[inline]
            pub unsafe fn GetEncoder(
                &mut self,
                encoderType: root::rev::SparkMaxRelativeEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder {
                CANSparkMax_GetEncoder(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetEncoder1(
                &mut self,
                encoderType: root::rev::CANEncoder_EncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder {
                CANSparkMax_GetEncoder1(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAlternateEncoder(
                &mut self,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder {
                CANSparkMax_GetAlternateEncoder(self, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAlternateEncoder1(
                &mut self,
                encoderType: root::rev::SparkMaxAlternateEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder {
                CANSparkMax_GetAlternateEncoder1(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAlternateEncoder2(
                &mut self,
                encoderType: root::rev::CANEncoder_AlternateEncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder {
                CANSparkMax_GetAlternateEncoder2(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAnalog(
                &mut self,
                mode: root::rev::SparkMaxAnalogSensor_Mode,
            ) -> root::rev::SparkMaxAnalogSensor {
                CANSparkMax_GetAnalog(self, mode)
            }
            #[inline]
            pub unsafe fn GetAnalog1(
                &mut self,
                mode: root::rev::CANAnalog_AnalogMode,
            ) -> root::rev::SparkMaxAnalogSensor {
                CANSparkMax_GetAnalog1(self, mode)
            }
            #[inline]
            pub unsafe fn GetPIDController(&mut self) -> root::rev::SparkMaxPIDController {
                CANSparkMax_GetPIDController(self)
            }
            #[inline]
            pub unsafe fn GetForwardLimitSwitch(
                &mut self,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetForwardLimitSwitch(self, switchType)
            }
            #[inline]
            pub unsafe fn GetForwardLimitSwitch1(
                &mut self,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetForwardLimitSwitch1(self, polarity)
            }
            #[inline]
            pub unsafe fn GetReverseLimitSwitch(
                &mut self,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetReverseLimitSwitch(self, switchType)
            }
            #[inline]
            pub unsafe fn GetReverseLimitSwitch1(
                &mut self,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetReverseLimitSwitch1(self, polarity)
            }
            #[inline]
            pub unsafe fn SetSmartCurrentLimit(
                &mut self,
                limit: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSmartCurrentLimit(self, limit)
            }
            #[inline]
            pub unsafe fn SetSmartCurrentLimit1(
                &mut self,
                stallLimit: ::std::os::raw::c_uint,
                freeLimit: ::std::os::raw::c_uint,
                limitRPM: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSmartCurrentLimit1(self, stallLimit, freeLimit, limitRPM)
            }
            #[inline]
            pub unsafe fn SetSecondaryCurrentLimit(
                &mut self,
                limit: f64,
                limitCycles: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSecondaryCurrentLimit(self, limit, limitCycles)
            }
            #[inline]
            pub unsafe fn SetIdleMode(
                &mut self,
                mode: root::rev::CANSparkMax_IdleMode,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetIdleMode(self, mode)
            }
            #[inline]
            pub unsafe fn GetIdleMode(&mut self) -> root::rev::CANSparkMax_IdleMode {
                CANSparkMax_GetIdleMode(self)
            }
            #[inline]
            pub unsafe fn EnableVoltageCompensation(
                &mut self,
                nominalVoltage: f64,
            ) -> root::rev::REVLibError {
                CANSparkMax_EnableVoltageCompensation(self, nominalVoltage)
            }
            #[inline]
            pub unsafe fn DisableVoltageCompensation(&mut self) -> root::rev::REVLibError {
                CANSparkMax_DisableVoltageCompensation(self)
            }
            #[inline]
            pub unsafe fn GetVoltageCompensationNominalVoltage(&mut self) -> f64 {
                CANSparkMax_GetVoltageCompensationNominalVoltage(self)
            }
            #[inline]
            pub unsafe fn SetOpenLoopRampRate(&mut self, rate: f64) -> root::rev::REVLibError {
                CANSparkMax_SetOpenLoopRampRate(self, rate)
            }
            #[inline]
            pub unsafe fn SetClosedLoopRampRate(&mut self, rate: f64) -> root::rev::REVLibError {
                CANSparkMax_SetClosedLoopRampRate(self, rate)
            }
            #[inline]
            pub unsafe fn GetOpenLoopRampRate(&mut self) -> f64 {
                CANSparkMax_GetOpenLoopRampRate(self)
            }
            #[inline]
            pub unsafe fn GetClosedLoopRampRate(&mut self) -> f64 {
                CANSparkMax_GetClosedLoopRampRate(self)
            }
            #[inline]
            pub unsafe fn Follow(
                &mut self,
                leader: *const root::rev::CANSparkMax,
                invert: bool,
            ) -> root::rev::REVLibError {
                CANSparkMax_Follow(self, leader, invert)
            }
            #[inline]
            pub unsafe fn Follow1(
                &mut self,
                leader: root::rev::CANSparkMax_ExternalFollower,
                deviceID: ::std::os::raw::c_int,
                invert: bool,
            ) -> root::rev::REVLibError {
                CANSparkMax_Follow1(self, leader, deviceID, invert)
            }
            #[inline]
            pub unsafe fn IsFollower(&mut self) -> bool {
                CANSparkMax_IsFollower(self)
            }
            #[inline]
            pub unsafe fn GetFaults(&mut self) -> u16 {
                CANSparkMax_GetFaults(self)
            }
            #[inline]
            pub unsafe fn GetStickyFaults(&mut self) -> u16 {
                CANSparkMax_GetStickyFaults(self)
            }
            #[inline]
            pub unsafe fn GetFault(&self, faultID: root::rev::CANSparkMax_FaultID) -> bool {
                CANSparkMax_GetFault(self, faultID)
            }
            #[inline]
            pub unsafe fn GetStickyFault(&self, faultID: root::rev::CANSparkMax_FaultID) -> bool {
                CANSparkMax_GetStickyFault(self, faultID)
            }
            #[inline]
            pub unsafe fn GetBusVoltage(&mut self) -> f64 {
                CANSparkMax_GetBusVoltage(self)
            }
            #[inline]
            pub unsafe fn GetAppliedOutput(&mut self) -> f64 {
                CANSparkMax_GetAppliedOutput(self)
            }
            #[inline]
            pub unsafe fn GetOutputCurrent(&mut self) -> f64 {
                CANSparkMax_GetOutputCurrent(self)
            }
            #[inline]
            pub unsafe fn GetMotorTemperature(&mut self) -> f64 {
                CANSparkMax_GetMotorTemperature(self)
            }
            #[inline]
            pub unsafe fn ClearFaults(&mut self) -> root::rev::REVLibError {
                CANSparkMax_ClearFaults(self)
            }
            #[inline]
            pub unsafe fn BurnFlash(&mut self) -> root::rev::REVLibError {
                CANSparkMax_BurnFlash(self)
            }
            #[inline]
            pub unsafe fn SetCANTimeout(
                &mut self,
                milliseconds: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetCANTimeout(self, milliseconds)
            }
            #[inline]
            pub unsafe fn EnableSoftLimit(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                enable: bool,
            ) -> root::rev::REVLibError {
                CANSparkMax_EnableSoftLimit(self, direction, enable)
            }
            #[inline]
            pub unsafe fn IsSoftLimitEnabled(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> bool {
                CANSparkMax_IsSoftLimitEnabled(self, direction)
            }
            #[inline]
            pub unsafe fn SetSoftLimit(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                limit: f64,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSoftLimit(self, direction, limit)
            }
            #[inline]
            pub unsafe fn GetSoftLimit(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> f64 {
                CANSparkMax_GetSoftLimit(self, direction)
            }
            #[inline]
            pub unsafe fn GetLastError(&mut self) -> root::rev::REVLibError {
                CANSparkMax_GetLastError(self)
            }
            #[inline]
            pub unsafe fn new(
                deviceID: ::std::os::raw::c_int,
                type_: root::rev::CANSparkMaxLowLevel_MotorType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CANSparkMax_CANSparkMax(__bindgen_tmp.as_mut_ptr(), deviceID, type_);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[doc = " Speed Controller Interface ****/"]
            #[doc = " Common interface for setting the speed of a speed controller."]
            #[doc = ""]
            #[doc = " @param speed The speed to set.  Value should be between -1.0 and 1.0."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax3SetEd"]
            pub fn CANSparkMax_Set(this: *mut ::std::os::raw::c_void, speed: f64);
        }
        extern "C" {
            #[doc = " Sets the voltage output of the SpeedController.  This is equivalent to"]
            #[doc = " a call to SetReference(output, CANSparkMax::ControlType::kVoltage). The"]
            #[doc = " behavior of this call differs slightly from the WPILib documentation for"]
            #[doc = " this call since the device internally sets the desired voltage (not a"]
            #[doc = " compensation value). That means that this *can* be a 'set-and-forget'"]
            #[doc = " call."]
            #[doc = ""]
            #[doc = " @param output The voltage to output."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10SetVoltageEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl2ELl1EES5_S4_ILln3ELl1EES4_ILl0ELl1EES4_ILln1ELl1EES9_S9_S9_S9_EES9_S9_EEdNS1_12linear_scaleEEE"]
            pub fn CANSparkMax_SetVoltage(
                this: *mut ::std::os::raw::c_void,
                output: root::units::voltage::volt_t,
            );
        }
        extern "C" {
            #[doc = " Common interface for getting the current set speed of a speed controller."]
            #[doc = ""]
            #[doc = " @return The current set speed.  Value is between -1.0 and 1.0."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax3GetEv"]
            pub fn CANSparkMax_Get(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Common interface for inverting direction of a speed controller."]
            #[doc = ""]
            #[doc = " This call has no effect if the controller is a follower. To invert"]
            #[doc = " a follower, see the follow() method."]
            #[doc = ""]
            #[doc = " @param isInverted The state of inversion, true is inverted."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11SetInvertedEb"]
            pub fn CANSparkMax_SetInverted(this: *mut ::std::os::raw::c_void, isInverted: bool);
        }
        extern "C" {
            #[doc = " Common interface for returning the inversion state of a speed controller."]
            #[doc = ""]
            #[doc = " This call has no effect if the controller is a follower."]
            #[doc = ""]
            #[doc = " @return isInverted The state of inversion, true is inverted."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax11GetInvertedEv"]
            pub fn CANSparkMax_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            #[doc = " Common interface for disabling a motor."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax7DisableEv"]
            pub fn CANSparkMax_Disable(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Common interface to stop the motor until Set is called again."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9StopMotorEv"]
            pub fn CANSparkMax_StopMotor(this: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CIEColor {
            pub X: f64,
            pub Y: f64,
            pub Z: f64,
            pub mag: f64,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev8CIEColor13IlluminantD65E"]
            pub static CIEColor_IlluminantD65: [f64; 3usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev8CIEColor8XYZtoRGBE"]
            pub static CIEColor_XYZtoRGB: [f64; 9usize];
        }
        #[test]
        fn bindgen_test_layout_CIEColor() {
            assert_eq!(
                ::std::mem::size_of::<CIEColor>(),
                32usize,
                concat!("Size of: ", stringify!(CIEColor))
            );
            assert_eq!(
                ::std::mem::align_of::<CIEColor>(),
                8usize,
                concat!("Alignment of ", stringify!(CIEColor))
            );
            fn test_field_X() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CIEColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CIEColor),
                        "::",
                        stringify!(X)
                    )
                );
            }
            test_field_X();
            fn test_field_Y() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CIEColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CIEColor),
                        "::",
                        stringify!(Y)
                    )
                );
            }
            test_field_Y();
            fn test_field_Z() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CIEColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CIEColor),
                        "::",
                        stringify!(Z)
                    )
                );
            }
            test_field_Z();
            fn test_field_mag() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<CIEColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).mag) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CIEColor),
                        "::",
                        stringify!(mag)
                    )
                );
            }
            test_field_mag();
        }
        #[doc = " REV Robotics Color Sensor V3."]
        #[doc = ""]
        #[doc = " This class allows access to a REV Robotics color sensor V3 on an I2C bus."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ColorMatch {
            pub m_colorsToMatch: root::std::vector,
            pub m_confidenceLevel: f64,
        }
        #[test]
        fn bindgen_test_layout_ColorMatch() {
            assert_eq!(
                ::std::mem::size_of::<ColorMatch>(),
                32usize,
                concat!("Size of: ", stringify!(ColorMatch))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorMatch>(),
                8usize,
                concat!("Alignment of ", stringify!(ColorMatch))
            );
            fn test_field_m_colorsToMatch() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorMatch>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_colorsToMatch) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorMatch),
                        "::",
                        stringify!(m_colorsToMatch)
                    )
                );
            }
            test_field_m_colorsToMatch();
            fn test_field_m_confidenceLevel() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorMatch>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_confidenceLevel) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorMatch),
                        "::",
                        stringify!(m_confidenceLevel)
                    )
                );
            }
            test_field_m_confidenceLevel();
        }
        extern "C" {
            #[doc = " Add color to match object"]
            #[doc = ""]
            #[doc = " @param color color to add to matching"]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3rev10ColorMatch13AddColorMatchERKN3frc5ColorE"]
            pub fn ColorMatch_AddColorMatch(
                this: *mut root::rev::ColorMatch,
                color: *const root::frc::Color,
            );
        }
        extern "C" {
            #[doc = " Set the confidence interval for determining color. Defaults to 0.95"]
            #[doc = ""]
            #[doc = " @param confidence    A value between 0 and 1"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch22SetConfidenceThresholdEd"]
            pub fn ColorMatch_SetConfidenceThreshold(
                this: *mut root::rev::ColorMatch,
                confidence: f64,
            );
        }
        extern "C" {
            #[doc = " MatchColor uses euclidean distance to compare a given normalized RGB"]
            #[doc = " vector against stored values"]
            #[doc = ""]
            #[doc = " @param colorToMatch color to compare against stored colors"]
            #[doc = ""]
            #[doc = " @return  Matched color if detected"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch10MatchColorERKN3frc5ColorE"]
            pub fn ColorMatch_MatchColor(
                this: *mut root::rev::ColorMatch,
                colorToMatch: *const root::frc::Color,
            ) -> root::std::optional;
        }
        extern "C" {
            #[doc = " MatchColor uses euclidean distance to compare a given normalized RGB"]
            #[doc = " vector against stored values"]
            #[doc = ""]
            #[doc = " @param colorToMatch color to compare against stored colors"]
            #[doc = ""]
            #[doc = " @param confidence The confidence value for this match, this is"]
            #[doc = " simply 1 - euclidean distance of the two color vectors"]
            #[doc = ""]
            #[doc = " @return  Matched color if detected"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch10MatchColorERKN3frc5ColorERd"]
            pub fn ColorMatch_MatchColor1(
                this: *mut root::rev::ColorMatch,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::std::optional;
        }
        extern "C" {
            #[doc = " MatchColor uses euclidean distance to compare a given normalized RGB"]
            #[doc = " vector against stored values"]
            #[doc = ""]
            #[doc = " @param colorToMatch color to compare against stored colors"]
            #[doc = ""]
            #[doc = " @param confidence The confidence value for this match, this is"]
            #[doc = " simply 1 - euclidean distance of the two color vectors"]
            #[doc = ""]
            #[doc = " @return  Closest matching color"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch17MatchClosestColorERKN3frc5ColorERd"]
            pub fn ColorMatch_MatchClosestColor(
                this: *mut root::rev::ColorMatch,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::frc::Color;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev10ColorMatchC1Ev"]
            pub fn ColorMatch_ColorMatch(this: *mut root::rev::ColorMatch);
        }
        impl ColorMatch {
            #[inline]
            pub unsafe fn AddColorMatch(&mut self, color: *const root::frc::Color) {
                ColorMatch_AddColorMatch(self, color)
            }
            #[inline]
            pub unsafe fn SetConfidenceThreshold(&mut self, confidence: f64) {
                ColorMatch_SetConfidenceThreshold(self, confidence)
            }
            #[inline]
            pub unsafe fn MatchColor(
                &mut self,
                colorToMatch: *const root::frc::Color,
            ) -> root::std::optional {
                ColorMatch_MatchColor(self, colorToMatch)
            }
            #[inline]
            pub unsafe fn MatchColor1(
                &mut self,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::std::optional {
                ColorMatch_MatchColor1(self, colorToMatch, confidence)
            }
            #[inline]
            pub unsafe fn MatchClosestColor(
                &mut self,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::frc::Color {
                ColorMatch_MatchClosestColor(self, colorToMatch, confidence)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ColorMatch_ColorMatch(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " REV Robotics Color Sensor V3."]
        #[doc = ""]
        #[doc = " This class allows access to a REV Robotics color sensor V3 on an I2C bus."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ColorSensorV3 {
            pub m_i2c: root::frc::I2C,
            pub m_simDevice: root::hal::SimDevice,
            pub m_simR: root::hal::SimDouble,
            pub m_simG: root::hal::SimDouble,
            pub m_simB: root::hal::SimDouble,
            pub m_simIR: root::hal::SimDouble,
            pub m_simProx: root::hal::SimDouble,
        }
        pub const ColorSensorV3_GainFactor_k1x: root::rev::ColorSensorV3_GainFactor = 0;
        pub const ColorSensorV3_GainFactor_k3x: root::rev::ColorSensorV3_GainFactor = 1;
        pub const ColorSensorV3_GainFactor_k6x: root::rev::ColorSensorV3_GainFactor = 2;
        pub const ColorSensorV3_GainFactor_k9x: root::rev::ColorSensorV3_GainFactor = 3;
        pub const ColorSensorV3_GainFactor_k18x: root::rev::ColorSensorV3_GainFactor = 4;
        pub type ColorSensorV3_GainFactor = ::std::os::raw::c_int;
        pub const ColorSensorV3_LEDPulseFrequency_k60kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 24;
        pub const ColorSensorV3_LEDPulseFrequency_k70kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 64;
        pub const ColorSensorV3_LEDPulseFrequency_k80kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 40;
        pub const ColorSensorV3_LEDPulseFrequency_k90kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 48;
        pub const ColorSensorV3_LEDPulseFrequency_k100kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 56;
        pub type ColorSensorV3_LEDPulseFrequency = ::std::os::raw::c_int;
        pub const ColorSensorV3_LEDCurrent_kPulse2mA: root::rev::ColorSensorV3_LEDCurrent = 0;
        pub const ColorSensorV3_LEDCurrent_kPulse5mA: root::rev::ColorSensorV3_LEDCurrent = 1;
        pub const ColorSensorV3_LEDCurrent_kPulse10mA: root::rev::ColorSensorV3_LEDCurrent = 2;
        pub const ColorSensorV3_LEDCurrent_kPulse25mA: root::rev::ColorSensorV3_LEDCurrent = 3;
        pub const ColorSensorV3_LEDCurrent_kPulse50mA: root::rev::ColorSensorV3_LEDCurrent = 4;
        pub const ColorSensorV3_LEDCurrent_kPulse75mA: root::rev::ColorSensorV3_LEDCurrent = 5;
        pub const ColorSensorV3_LEDCurrent_kPulse100mA: root::rev::ColorSensorV3_LEDCurrent = 6;
        pub const ColorSensorV3_LEDCurrent_kPulse125mA: root::rev::ColorSensorV3_LEDCurrent = 7;
        pub type ColorSensorV3_LEDCurrent = ::std::os::raw::c_int;
        pub const ColorSensorV3_ProximityResolution_k8bit:
            root::rev::ColorSensorV3_ProximityResolution = 0;
        pub const ColorSensorV3_ProximityResolution_k9bit:
            root::rev::ColorSensorV3_ProximityResolution = 8;
        pub const ColorSensorV3_ProximityResolution_k10bit:
            root::rev::ColorSensorV3_ProximityResolution = 16;
        pub const ColorSensorV3_ProximityResolution_k11bit:
            root::rev::ColorSensorV3_ProximityResolution = 24;
        pub type ColorSensorV3_ProximityResolution = ::std::os::raw::c_int;
        pub const ColorSensorV3_ProximityMeasurementRate_k6ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 1;
        pub const ColorSensorV3_ProximityMeasurementRate_k12ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 2;
        pub const ColorSensorV3_ProximityMeasurementRate_k25ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 3;
        pub const ColorSensorV3_ProximityMeasurementRate_k50ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 4;
        pub const ColorSensorV3_ProximityMeasurementRate_k100ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 5;
        pub const ColorSensorV3_ProximityMeasurementRate_k200ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 6;
        pub const ColorSensorV3_ProximityMeasurementRate_k400ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 7;
        pub type ColorSensorV3_ProximityMeasurementRate = ::std::os::raw::c_int;
        pub const ColorSensorV3_ColorResolution_k20bit: root::rev::ColorSensorV3_ColorResolution =
            0;
        pub const ColorSensorV3_ColorResolution_k19bit: root::rev::ColorSensorV3_ColorResolution =
            16;
        pub const ColorSensorV3_ColorResolution_k18bit: root::rev::ColorSensorV3_ColorResolution =
            32;
        pub const ColorSensorV3_ColorResolution_k17bit: root::rev::ColorSensorV3_ColorResolution =
            48;
        pub const ColorSensorV3_ColorResolution_k16bit: root::rev::ColorSensorV3_ColorResolution =
            64;
        pub const ColorSensorV3_ColorResolution_k13bit: root::rev::ColorSensorV3_ColorResolution =
            80;
        pub type ColorSensorV3_ColorResolution = ::std::os::raw::c_int;
        pub const ColorSensorV3_ColorMeasurementRate_k25ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 0;
        pub const ColorSensorV3_ColorMeasurementRate_k50ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 1;
        pub const ColorSensorV3_ColorMeasurementRate_k100ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 2;
        pub const ColorSensorV3_ColorMeasurementRate_k200ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 3;
        pub const ColorSensorV3_ColorMeasurementRate_k500ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 4;
        pub const ColorSensorV3_ColorMeasurementRate_k1000ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 5;
        pub const ColorSensorV3_ColorMeasurementRate_k2000ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 7;
        pub type ColorSensorV3_ColorMeasurementRate = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ColorSensorV3_RawColor {
            pub red: u32,
            pub green: u32,
            pub blue: u32,
            pub ir: u32,
        }
        #[test]
        fn bindgen_test_layout_ColorSensorV3_RawColor() {
            assert_eq!(
                ::std::mem::size_of::<ColorSensorV3_RawColor>(),
                16usize,
                concat!("Size of: ", stringify!(ColorSensorV3_RawColor))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorSensorV3_RawColor>(),
                4usize,
                concat!("Alignment of ", stringify!(ColorSensorV3_RawColor))
            );
            fn test_field_red() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3_RawColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3_RawColor),
                        "::",
                        stringify!(red)
                    )
                );
            }
            test_field_red();
            fn test_field_green() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3_RawColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3_RawColor),
                        "::",
                        stringify!(green)
                    )
                );
            }
            test_field_green();
            fn test_field_blue() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3_RawColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3_RawColor),
                        "::",
                        stringify!(blue)
                    )
                );
            }
            test_field_blue();
            fn test_field_ir() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3_RawColor>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).ir) as usize - ptr as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3_RawColor),
                        "::",
                        stringify!(ir)
                    )
                );
            }
            test_field_ir();
        }
        pub const ColorSensorV3_Register_kMainCtrl: root::rev::ColorSensorV3_Register = 0;
        pub const ColorSensorV3_Register_kProximitySensorLED: root::rev::ColorSensorV3_Register = 1;
        pub const ColorSensorV3_Register_kProximitySensorPulses: root::rev::ColorSensorV3_Register =
            2;
        pub const ColorSensorV3_Register_kProximitySensorRate: root::rev::ColorSensorV3_Register =
            3;
        pub const ColorSensorV3_Register_kLightSensorMeasurementRate:
            root::rev::ColorSensorV3_Register = 4;
        pub const ColorSensorV3_Register_kLightSensorGain: root::rev::ColorSensorV3_Register = 5;
        pub const ColorSensorV3_Register_kPartID: root::rev::ColorSensorV3_Register = 6;
        pub const ColorSensorV3_Register_kMainStatus: root::rev::ColorSensorV3_Register = 7;
        pub const ColorSensorV3_Register_kProximityData: root::rev::ColorSensorV3_Register = 8;
        pub const ColorSensorV3_Register_kDataInfrared: root::rev::ColorSensorV3_Register = 10;
        pub const ColorSensorV3_Register_kDataGreen: root::rev::ColorSensorV3_Register = 13;
        pub const ColorSensorV3_Register_kDataBlue: root::rev::ColorSensorV3_Register = 16;
        pub const ColorSensorV3_Register_kDataRed: root::rev::ColorSensorV3_Register = 19;
        pub type ColorSensorV3_Register = ::std::os::raw::c_int;
        pub const ColorSensorV3_MainCtrlFields_kProximitySensorEnable:
            root::rev::ColorSensorV3_MainCtrlFields = 1;
        pub const ColorSensorV3_MainCtrlFields_kLightSensorEnable:
            root::rev::ColorSensorV3_MainCtrlFields = 2;
        pub const ColorSensorV3_MainCtrlFields_kRGBMode: root::rev::ColorSensorV3_MainCtrlFields =
            4;
        pub type ColorSensorV3_MainCtrlFields = ::std::os::raw::c_int;
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct ColorSensorV3_MainStatus {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        }
        #[test]
        fn bindgen_test_layout_ColorSensorV3_MainStatus() {
            assert_eq!(
                ::std::mem::size_of::<ColorSensorV3_MainStatus>(),
                1usize,
                concat!("Size of: ", stringify!(ColorSensorV3_MainStatus))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorSensorV3_MainStatus>(),
                1usize,
                concat!("Alignment of ", stringify!(ColorSensorV3_MainStatus))
            );
        }
        impl ColorSensorV3_MainStatus {
            #[inline]
            pub fn PSDataStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PSDataStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn PSInterruptStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PSInterruptStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn PSLogicStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PSLogicStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn LSDataStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_LSDataStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn LSInterruptStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_LSInterruptStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn PowerOnStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PowerOnStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                PSDataStatus: u8,
                PSInterruptStatus: u8,
                PSLogicStatus: u8,
                LSDataStatus: u8,
                LSInterruptStatus: u8,
                PowerOnStatus: u8,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let PSDataStatus: u8 = unsafe { ::std::mem::transmute(PSDataStatus) };
                    PSDataStatus as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let PSInterruptStatus: u8 = unsafe { ::std::mem::transmute(PSInterruptStatus) };
                    PSInterruptStatus as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let PSLogicStatus: u8 = unsafe { ::std::mem::transmute(PSLogicStatus) };
                    PSLogicStatus as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let LSDataStatus: u8 = unsafe { ::std::mem::transmute(LSDataStatus) };
                    LSDataStatus as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let LSInterruptStatus: u8 = unsafe { ::std::mem::transmute(LSInterruptStatus) };
                    LSInterruptStatus as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let PowerOnStatus: u8 = unsafe { ::std::mem::transmute(PowerOnStatus) };
                    PowerOnStatus as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev13ColorSensorV37CmatrixE"]
            pub static ColorSensorV3_Cmatrix: [f64; 9usize];
        }
        #[test]
        fn bindgen_test_layout_ColorSensorV3() {
            assert_eq!(
                ::std::mem::size_of::<ColorSensorV3>(),
                32usize,
                concat!("Size of: ", stringify!(ColorSensorV3))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorSensorV3>(),
                4usize,
                concat!("Alignment of ", stringify!(ColorSensorV3))
            );
            fn test_field_m_i2c() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_i2c) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_i2c)
                    )
                );
            }
            test_field_m_i2c();
            fn test_field_m_simDevice() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_simDevice)
                    )
                );
            }
            test_field_m_simDevice();
            fn test_field_m_simR() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_simR) as usize - ptr as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_simR)
                    )
                );
            }
            test_field_m_simR();
            fn test_field_m_simG() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_simG) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_simG)
                    )
                );
            }
            test_field_m_simG();
            fn test_field_m_simB() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_simB) as usize - ptr as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_simB)
                    )
                );
            }
            test_field_m_simB();
            fn test_field_m_simIR() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_simIR) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_simIR)
                    )
                );
            }
            test_field_m_simIR();
            fn test_field_m_simProx() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<ColorSensorV3>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_simProx) as usize - ptr as usize
                    },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ColorSensorV3),
                        "::",
                        stringify!(m_simProx)
                    )
                );
            }
            test_field_m_simProx();
        }
        extern "C" {
            #[doc = " Get the normalized RGB color from the sensor (normalized based on"]
            #[doc = " total R + G + B)"]
            #[doc = ""]
            #[doc = " @return  frc::Color class with normalized sRGB values"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV38GetColorEv"]
            pub fn ColorSensorV3_GetColor(this: *mut root::rev::ColorSensorV3) -> root::frc::Color;
        }
        extern "C" {
            #[doc = " Get the raw color value from the sensor."]
            #[doc = ""]
            #[doc = " @return  Raw color values from sensopr"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV311GetRawColorEv"]
            pub fn ColorSensorV3_GetRawColor(
                this: *mut root::rev::ColorSensorV3,
            ) -> root::rev::ColorSensorV3_RawColor;
        }
        extern "C" {
            #[doc = " Get the color converted to CIE XYZ color space using factory"]
            #[doc = " calibrated constants."]
            #[doc = ""]
            #[doc = " https://en.wikipedia.org/wiki/CIE_1931_color_space"]
            #[doc = ""]
            #[doc = " @return  CIEColor value from sensor"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV311GetCIEColorEv"]
            pub fn ColorSensorV3_GetCIEColor(
                this: *mut root::rev::ColorSensorV3,
            ) -> root::rev::CIEColor;
        }
        extern "C" {
            #[doc = " Get the normalzied IR value from the sensor. Works best when within 2"]
            #[doc = " inches and perpendicular to surface of interest."]
            #[doc = ""]
            #[doc = " @return  Color class with normalized values"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV35GetIREv"]
            pub fn ColorSensorV3_GetIR(this: *mut root::rev::ColorSensorV3) -> f64;
        }
        extern "C" {
            #[doc = " Get the raw proximity value from the sensor ADC. This value is largest"]
            #[doc = " when an object is close to the sensor and smallest when"]
            #[doc = " far away."]
            #[doc = ""]
            #[doc = " @return  Proximity measurement value, ranging from 0 to 2047 in"]
            #[doc = "          default configuration"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV312GetProximityEv"]
            pub fn ColorSensorV3_GetProximity(this: *mut root::rev::ColorSensorV3) -> u32;
        }
        extern "C" {
            #[doc = " Set the gain factor applied to color ADC measurements."]
            #[doc = ""]
            #[doc = " By default, the gain is set to 3x."]
            #[doc = ""]
            #[doc = " @param gain  Gain factor applied to color ADC measurements"]
            #[doc = "              measurements"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV37SetGainENS0_10GainFactorE"]
            pub fn ColorSensorV3_SetGain(
                this: *mut root::rev::ColorSensorV3,
                gain: root::rev::ColorSensorV3_GainFactor,
            );
        }
        extern "C" {
            #[doc = " Configure the the IR LED used by the proximity sensor."]
            #[doc = ""]
            #[doc = " These settings are only needed for advanced users, the defaults"]
            #[doc = " will work fine for most teams. Consult the APDS-9151 for more"]
            #[doc = " information on these configuration settings and how they will affect"]
            #[doc = " proximity sensor measurements."]
            #[doc = ""]
            #[doc = " @param freq      The pulse modulation frequency for the proximity"]
            #[doc = "                  sensor LED"]
            #[doc = " @param curr      The pulse current for the proximity sensor LED"]
            #[doc = " @param pulses    The number of pulses per measurement of the"]
            #[doc = "                  proximity sensor LED"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV327ConfigureProximitySensorLEDENS0_17LEDPulseFrequencyENS0_10LEDCurrentEh"]
            pub fn ColorSensorV3_ConfigureProximitySensorLED(
                this: *mut root::rev::ColorSensorV3,
                freq: root::rev::ColorSensorV3_LEDPulseFrequency,
                current: root::rev::ColorSensorV3_LEDCurrent,
                pulses: u8,
            );
        }
        extern "C" {
            #[doc = " Configure the proximity sensor."]
            #[doc = ""]
            #[doc = " These settings are only needed for advanced users, the defaults"]
            #[doc = " will work fine for most teams. Consult the APDS-9151 for more"]
            #[doc = " information on these configuration settings and how they will affect"]
            #[doc = " proximity sensor measurements."]
            #[doc = ""]
            #[doc = " @param res   Bit resolution output by the proximity sensor ADC."]
            #[doc = " @param rate  Measurement rate of the proximity sensor"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV324ConfigureProximitySensorENS0_19ProximityResolutionENS0_24ProximityMeasurementRateE"]
            pub fn ColorSensorV3_ConfigureProximitySensor(
                this: *mut root::rev::ColorSensorV3,
                res: root::rev::ColorSensorV3_ProximityResolution,
                rate: root::rev::ColorSensorV3_ProximityMeasurementRate,
            );
        }
        extern "C" {
            #[doc = " Configure the color sensor."]
            #[doc = ""]
            #[doc = " These settings are only needed for advanced users, the defaults"]
            #[doc = " will work fine for most teams. Consult the APDS-9151 for more"]
            #[doc = " information on these configuration settings and how they will affect"]
            #[doc = " color sensor measurements."]
            #[doc = ""]
            #[doc = " @param res   Bit resolution output by the respective light sensor ADCs"]
            #[doc = " @param rate  Measurement rate of the light sensor"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV320ConfigureColorSensorENS0_15ColorResolutionENS0_20ColorMeasurementRateE"]
            pub fn ColorSensorV3_ConfigureColorSensor(
                this: *mut root::rev::ColorSensorV3,
                res: root::rev::ColorSensorV3_ColorResolution,
                rate: root::rev::ColorSensorV3_ColorMeasurementRate,
            );
        }
        extern "C" {
            #[doc = " Indicates if the device reset. Based on the power on status flag in the"]
            #[doc = " status register. Per the datasheet:"]
            #[doc = ""]
            #[doc = " Part went through a power-up event, either because the part was turned"]
            #[doc = " on or because there was power supply voltage disturbance (default at"]
            #[doc = " first register read)."]
            #[doc = ""]
            #[doc = " This flag is self clearing"]
            #[doc = ""]
            #[doc = " @return  true if the device was reset"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV38HasResetEv"]
            pub fn ColorSensorV3_HasReset(this: *mut root::rev::ColorSensorV3) -> bool;
        }
        extern "C" {
            #[doc = " Indicates if the device can currently be communicated with."]
            #[doc = ""]
            #[doc = " @return  true if the device is currently connected and responsive"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV311IsConnectedEv"]
            pub fn ColorSensorV3_IsConnected(this: *mut root::rev::ColorSensorV3) -> bool;
        }
        extern "C" {
            #[doc = " Constructs a ColorSensorV3."]
            #[doc = ""]
            #[doc = " Note that the REV Color Sensor is really two devices in one package:"]
            #[doc = " a color sensor providing red, green, blue and IR values, and a proximity"]
            #[doc = " sensor."]
            #[doc = ""]
            #[doc = " @param port  The I2C port the color sensor is attached to"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV3C1EN3frc3I2C4PortE"]
            pub fn ColorSensorV3_ColorSensorV3(
                this: *mut root::rev::ColorSensorV3,
                port: root::frc::I2C_Port,
            );
        }
        impl ColorSensorV3 {
            #[inline]
            pub unsafe fn GetColor(&mut self) -> root::frc::Color {
                ColorSensorV3_GetColor(self)
            }
            #[inline]
            pub unsafe fn GetRawColor(&mut self) -> root::rev::ColorSensorV3_RawColor {
                ColorSensorV3_GetRawColor(self)
            }
            #[inline]
            pub unsafe fn GetCIEColor(&mut self) -> root::rev::CIEColor {
                ColorSensorV3_GetCIEColor(self)
            }
            #[inline]
            pub unsafe fn GetIR(&mut self) -> f64 {
                ColorSensorV3_GetIR(self)
            }
            #[inline]
            pub unsafe fn GetProximity(&mut self) -> u32 {
                ColorSensorV3_GetProximity(self)
            }
            #[inline]
            pub unsafe fn SetGain(&mut self, gain: root::rev::ColorSensorV3_GainFactor) {
                ColorSensorV3_SetGain(self, gain)
            }
            #[inline]
            pub unsafe fn ConfigureProximitySensorLED(
                &mut self,
                freq: root::rev::ColorSensorV3_LEDPulseFrequency,
                current: root::rev::ColorSensorV3_LEDCurrent,
                pulses: u8,
            ) {
                ColorSensorV3_ConfigureProximitySensorLED(self, freq, current, pulses)
            }
            #[inline]
            pub unsafe fn ConfigureProximitySensor(
                &mut self,
                res: root::rev::ColorSensorV3_ProximityResolution,
                rate: root::rev::ColorSensorV3_ProximityMeasurementRate,
            ) {
                ColorSensorV3_ConfigureProximitySensor(self, res, rate)
            }
            #[inline]
            pub unsafe fn ConfigureColorSensor(
                &mut self,
                res: root::rev::ColorSensorV3_ColorResolution,
                rate: root::rev::ColorSensorV3_ColorMeasurementRate,
            ) {
                ColorSensorV3_ConfigureColorSensor(self, res, rate)
            }
            #[inline]
            pub unsafe fn HasReset(&mut self) -> bool {
                ColorSensorV3_HasReset(self)
            }
            #[inline]
            pub unsafe fn IsConnected(&mut self) -> bool {
                ColorSensorV3_IsConnected(self)
            }
            #[inline]
            pub unsafe fn new(port: root::frc::I2C_Port) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ColorSensorV3_ColorSensorV3(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type size_t = ::std::os::raw::c_ulong;
        #[repr(C)]
        pub struct basic_string<_CharT> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider,
            pub _M_string_length: root::std::basic_string_size_type,
            pub __bindgen_anon_1: root::std::basic_string__bindgen_ty_2<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string__Char_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::basic_string__Char_alloc_type;
        pub type basic_string_size_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_difference_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::basic_string_const_iterator;
        pub type basic_string___sv_type<_CharT> = root::std::basic_string_view<_CharT>;
        pub type basic_string__If_sv = root::std::enable_if_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___sv_wrapper<_CharT> {
            pub _M_sv: root::std::basic_string___sv_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::basic_string_pointer,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: *mut _CharT,
            pub _M_allocated_capacity: root::std::basic_string_size_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type __bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __not_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_same {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut ::std::os::raw::c_uchar,
            pub __align: root::std::aligned_storage_type__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_aligned_storage_type() {
            assert_eq!(
                ::std::mem::size_of::<aligned_storage_type>(),
                8usize,
                concat!("Size of: ", stringify!(aligned_storage_type))
            );
            assert_eq!(
                ::std::mem::align_of::<aligned_storage_type>(),
                8usize,
                concat!("Alignment of ", stringify!(aligned_storage_type))
            );
        }
        pub type __remove_cvref_t = root::std::remove_cv;
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_elem_1 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_elem {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_difference_type = root::std::__detected_or_t;
        pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct atomic<_Tp> {
            pub _M_i: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        pub type atomic_value_type<_Tp> = _Tp;
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_size_type = root::std::size_t;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_t {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_in_place_t() {
            assert_eq!(
                ::std::mem::size_of::<in_place_t>(),
                1usize,
                concat!("Size of: ", stringify!(in_place_t))
            );
            assert_eq!(
                ::std::mem::align_of::<in_place_t>(),
                1usize,
                concat!("Alignment of ", stringify!(in_place_t))
            );
        }
        pub type string = root::std::basic_string<::std::os::raw::c_char>;
        pub type streamoff = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        pub type streampos = root::std::fpos<root::mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: root::std::size_t,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> =
            *mut root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_pointer<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_reference<_CharT> =
            *mut root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_reference<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_iterator<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_iterator<_CharT> =
            root::std::basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            root::std::reverse_iterator<root::std::basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            root::std::basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = root::std::size_t;
        pub type basic_string_view_difference_type = isize;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = root::std::size_t;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut root::std::vector,
            pub __buf: u8,
        }
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::intmax_t;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::intmax_t;
        }
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional__Base = u8;
        pub type optional___not_self = root::std::__not_;
        pub type optional___not_tag = root::std::__not_;
        pub type optional__Requires = root::std::enable_if_t;
        pub type optional_value_type<_Tp> = _Tp;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_value_type<_Tp> = _Tp;
        pub type new_allocator_size_type = root::std::size_t;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: root::__mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        fn test_field___wch() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__mbstate_t__bindgen_ty_1),
                    "::",
                    stringify!(__wch)
                )
            );
        }
        test_field___wch();
        fn test_field___wchb() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__mbstate_t__bindgen_ty_1),
                    "::",
                    stringify!(__wchb)
                )
            );
        }
        test_field___wchb();
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        fn test_field___count() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__mbstate_t),
                    "::",
                    stringify!(__count)
                )
            );
        }
        test_field___count();
        fn test_field___value() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__mbstate_t),
                    "::",
                    stringify!(__value)
                )
            );
        }
        test_field___value();
    }
    pub type mbstate_t = root::__mbstate_t;
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod fmt {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod units {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @brief\t\thelper type to identify base units."]
            #[doc = " @details\t\tA non-templated base class for `base_unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _base_unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__base_unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_base_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_base_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_base_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_base_unit_t))
                );
            }
            #[doc = " @brief\t\thelper type to identify units."]
            #[doc = " @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_unit_t))
                );
            }
        }
        pub mod constants {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod traits {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[doc = " @ingroup\t\tUnitTypes"]
        #[doc = " @brief\t\tClass representing SI base unit types."]
        #[doc = " @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each"]
        #[doc = "\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second"]
        #[doc = "\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:"]
        #[doc = "\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`"]
        #[doc = " @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters."]
        #[doc = " @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms."]
        #[doc = " @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds."]
        #[doc = " @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars."]
        #[doc = " @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes."]
        #[doc = " @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin."]
        #[doc = " @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles."]
        #[doc = " @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas."]
        #[doc = " @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes."]
        #[doc = " @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct base_unit {
            pub _address: u8,
        }
        pub type base_unit_meter_ratio<Meter> = Meter;
        pub type base_unit_kilogram_ratio<Kilogram> = Kilogram;
        pub type base_unit_second_ratio<Second> = Second;
        pub type base_unit_radian_ratio<Radian> = Radian;
        pub type base_unit_ampere_ratio<Ampere> = Ampere;
        pub type base_unit_kelvin_ratio<Kelvin> = Kelvin;
        pub type base_unit_mole_ratio<Mole> = Mole;
        pub type base_unit_candela_ratio<Candela> = Candela;
        pub type base_unit_byte_ratio<Byte> = Byte;
        pub mod category {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type voltage_unit = root::units::base_unit;
        }
        #[doc = " @ingroup\t\tUnitContainers"]
        #[doc = " @brief\t\tContainer for values which represent quantities of a given unit."]
        #[doc = " @details\t\tStores a value which represents a quantity in the given units. Unit containers"]
        #[doc = "\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to"]
        #[doc = "\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly"]
        #[doc = "\t\t\t\tconvertible to other compatible unit container types. Unit containers support"]
        #[doc = "\t\t\t\tvarious types of arithmetic operations, depending on their scale type."]
        #[doc = ""]
        #[doc = "\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment"]
        #[doc = "\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed"]
        #[doc = "\t\t\t\tusing `operator()`: @code"]
        #[doc = "\t\t\t\tmeter_t m(5.0);"]
        #[doc = "\t\t\t\tdouble val = m(); // val == 5.0\t@endcode."]
        #[doc = " @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)"]
        #[doc = " @tparam\t\tT underlying type of the storage. Defaults to double."]
        #[doc = " @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does"]
        #[doc = "\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,"]
        #[doc = "\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale"]
        #[doc = "\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`."]
        #[doc = " @sa"]
        #[doc = "\t\t\t\t- \\ref lengthContainers \"length unit containers\""]
        #[doc = "\t\t\t\t- \\ref massContainers \"mass unit containers\""]
        #[doc = "\t\t\t\t- \\ref timeContainers \"time unit containers\""]
        #[doc = "\t\t\t\t- \\ref angleContainers \"angle unit containers\""]
        #[doc = "\t\t\t\t- \\ref currentContainers \"current unit containers\""]
        #[doc = "\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\""]
        #[doc = "\t\t\t\t- \\ref substanceContainers \"substance unit containers\""]
        #[doc = "\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\""]
        #[doc = "\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\""]
        #[doc = "\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\""]
        #[doc = "\t\t\t\t- \\ref velocityContainers \"velocity unit containers\""]
        #[doc = "\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\""]
        #[doc = "\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\""]
        #[doc = "\t\t\t\t- \\ref forceContainers \"force unit containers\""]
        #[doc = "\t\t\t\t- \\ref pressureContainers \"pressure unit containers\""]
        #[doc = "\t\t\t\t- \\ref chargeContainers \"charge unit containers\""]
        #[doc = "\t\t\t\t- \\ref energyContainers \"energy unit containers\""]
        #[doc = "\t\t\t\t- \\ref powerContainers \"power unit containers\""]
        #[doc = "\t\t\t\t- \\ref voltageContainers \"voltage unit containers\""]
        #[doc = "\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\""]
        #[doc = "\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\""]
        #[doc = "\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\""]
        #[doc = "\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\""]
        #[doc = "\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\""]
        #[doc = "\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\""]
        #[doc = "\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\""]
        #[doc = "\t\t\t\t- \\ref radiationContainers \"radiation unit containers\""]
        #[doc = "\t\t\t\t- \\ref torqueContainers \"torque unit containers\""]
        #[doc = "\t\t\t\t- \\ref areaContainers \"area unit containers\""]
        #[doc = "\t\t\t\t- \\ref volumeContainers \"volume unit containers\""]
        #[doc = "\t\t\t\t- \\ref densityContainers \"density unit containers\""]
        #[doc = "\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\""]
        #[doc = "\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
        #[repr(C)]
        pub struct unit_t {
            pub _base: root::units::linear_scale<[u8; 0usize]>,
        }
        pub type unit_t_nls = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_non_linear_scale_type = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_underlying_type<T> = T;
        pub type unit_t_value_type<T> = T;
        pub type unit_t_unit_type<Units> = Units;
        #[doc = " @cond"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct linear_scale<T> {
            #[doc = "< linearized value."]
            pub m_value: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub mod voltage {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type volts = u8;
            pub type volt = root::units::voltage::volts;
            #[doc = " @ingroup\t\tUnitContainers"]
            #[doc = " @brief\t\tContainer for values which represent quantities of a given unit."]
            #[doc = " @details\t\tStores a value which represents a quantity in the given units. Unit containers"]
            #[doc = "\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to"]
            #[doc = "\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly"]
            #[doc = "\t\t\t\tconvertible to other compatible unit container types. Unit containers support"]
            #[doc = "\t\t\t\tvarious types of arithmetic operations, depending on their scale type."]
            #[doc = ""]
            #[doc = "\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment"]
            #[doc = "\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed"]
            #[doc = "\t\t\t\tusing `operator()`: @code"]
            #[doc = "\t\t\t\tmeter_t m(5.0);"]
            #[doc = "\t\t\t\tdouble val = m(); // val == 5.0\t@endcode."]
            #[doc = " @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)"]
            #[doc = " @tparam\t\tT underlying type of the storage. Defaults to double."]
            #[doc = " @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does"]
            #[doc = "\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,"]
            #[doc = "\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale"]
            #[doc = "\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`."]
            #[doc = " @sa"]
            #[doc = "\t\t\t\t- \\ref lengthContainers \"length unit containers\""]
            #[doc = "\t\t\t\t- \\ref massContainers \"mass unit containers\""]
            #[doc = "\t\t\t\t- \\ref timeContainers \"time unit containers\""]
            #[doc = "\t\t\t\t- \\ref angleContainers \"angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref currentContainers \"current unit containers\""]
            #[doc = "\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\""]
            #[doc = "\t\t\t\t- \\ref substanceContainers \"substance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\""]
            #[doc = "\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\""]
            #[doc = "\t\t\t\t- \\ref velocityContainers \"velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\""]
            #[doc = "\t\t\t\t- \\ref forceContainers \"force unit containers\""]
            #[doc = "\t\t\t\t- \\ref pressureContainers \"pressure unit containers\""]
            #[doc = "\t\t\t\t- \\ref chargeContainers \"charge unit containers\""]
            #[doc = "\t\t\t\t- \\ref energyContainers \"energy unit containers\""]
            #[doc = "\t\t\t\t- \\ref powerContainers \"power unit containers\""]
            #[doc = "\t\t\t\t- \\ref voltageContainers \"voltage unit containers\""]
            #[doc = "\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\""]
            #[doc = "\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\""]
            #[doc = "\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\""]
            #[doc = "\t\t\t\t- \\ref radiationContainers \"radiation unit containers\""]
            #[doc = "\t\t\t\t- \\ref torqueContainers \"torque unit containers\""]
            #[doc = "\t\t\t\t- \\ref areaContainers \"area unit containers\""]
            #[doc = "\t\t\t\t- \\ref volumeContainers \"volume unit containers\""]
            #[doc = "\t\t\t\t- \\ref densityContainers \"density unit containers\""]
            #[doc = "\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\""]
            #[doc = "\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
            pub type volt_t = root::units::unit_t;
        }
    }
    pub mod frc {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct SpeedController__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface for speed controlling devices."]
        #[doc = ""]
        #[doc = " @deprecated Use MotorController."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SpeedController {
            pub vtable_: *const SpeedController__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_SpeedController() {
            assert_eq!(
                ::std::mem::size_of::<SpeedController>(),
                8usize,
                concat!("Size of: ", stringify!(SpeedController))
            );
            assert_eq!(
                ::std::mem::align_of::<SpeedController>(),
                8usize,
                concat!("Alignment of ", stringify!(SpeedController))
            );
        }
        extern "C" {
            #[doc = " Sets the voltage output of the SpeedController.  Compensates for"]
            #[doc = " the current bus voltage to ensure that the desired voltage is output even"]
            #[doc = " if the battery voltage is below 12V - highly useful when the voltage"]
            #[doc = " outputs are \"meaningful\" (e.g. they come from a feedforward calculation)."]
            #[doc = ""]
            #[doc = " <p>NOTE: This function *must* be called regularly in order for voltage"]
            #[doc = " compensation to work properly - unlike the ordinary set function, it is not"]
            #[doc = " \"set it and forget it.\""]
            #[doc = ""]
            #[doc = " @param output The voltage to output."]
            #[link_name = "\u{1}_ZN3frc15SpeedController10SetVoltageEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl2ELl1EES5_S4_ILln3ELl1EES4_ILl0ELl1EES4_ILln1ELl1EES9_S9_S9_S9_EES9_S9_EEdNS1_12linear_scaleEEE"]
            pub fn SpeedController_SetVoltage(
                this: *mut ::std::os::raw::c_void,
                output: root::units::voltage::volt_t,
            );
        }
        #[doc = " Interface for motor controlling devices."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct MotorController {
            pub _base: root::frc::SpeedController,
        }
        #[test]
        fn bindgen_test_layout_MotorController() {
            assert_eq!(
                ::std::mem::size_of::<MotorController>(),
                8usize,
                concat!("Size of: ", stringify!(MotorController))
            );
            assert_eq!(
                ::std::mem::align_of::<MotorController>(),
                8usize,
                concat!("Alignment of ", stringify!(MotorController))
            );
        }
        #[doc = " Represents colors that can be used with Addressable LEDs."]
        #[doc = ""]
        #[doc = " Limited to 12 bits of precision."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Color {
            pub red: f64,
            pub green: f64,
            pub blue: f64,
        }
        extern "C" {
            #[doc = " 0x1560BD."]
            #[link_name = "\u{1}_ZN3frc5Color6kDenimE"]
            pub static Color_kDenim: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x0066B3."]
            #[link_name = "\u{1}_ZN3frc5Color10kFirstBlueE"]
            pub static Color_kFirstBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xED1C24."]
            #[link_name = "\u{1}_ZN3frc5Color9kFirstRedE"]
            pub static Color_kFirstRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0F8FF."]
            #[link_name = "\u{1}_ZN3frc5Color10kAliceBlueE"]
            pub static Color_kAliceBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFAEBD7."]
            #[link_name = "\u{1}_ZN3frc5Color13kAntiqueWhiteE"]
            pub static Color_kAntiqueWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color5kAquaE"]
            pub static Color_kAqua: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7FFFD4."]
            #[link_name = "\u{1}_ZN3frc5Color11kAquamarineE"]
            pub static Color_kAquamarine: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color6kAzureE"]
            pub static Color_kAzure: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5F5DC."]
            #[link_name = "\u{1}_ZN3frc5Color6kBeigeE"]
            pub static Color_kBeige: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFE4C4."]
            #[link_name = "\u{1}_ZN3frc5Color7kBisqueE"]
            pub static Color_kBisque: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x000000."]
            #[link_name = "\u{1}_ZN3frc5Color6kBlackE"]
            pub static Color_kBlack: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFEBCD."]
            #[link_name = "\u{1}_ZN3frc5Color15kBlanchedAlmondE"]
            pub static Color_kBlanchedAlmond: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x0000FF."]
            #[link_name = "\u{1}_ZN3frc5Color5kBlueE"]
            pub static Color_kBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8A2BE2."]
            #[link_name = "\u{1}_ZN3frc5Color11kBlueVioletE"]
            pub static Color_kBlueViolet: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xA52A2A."]
            #[link_name = "\u{1}_ZN3frc5Color6kBrownE"]
            pub static Color_kBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDEB887."]
            #[link_name = "\u{1}_ZN3frc5Color10kBurlywoodE"]
            pub static Color_kBurlywood: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x5F9EA0."]
            #[link_name = "\u{1}_ZN3frc5Color10kCadetBlueE"]
            pub static Color_kCadetBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7FFF00."]
            #[link_name = "\u{1}_ZN3frc5Color11kChartreuseE"]
            pub static Color_kChartreuse: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD2691E."]
            #[link_name = "\u{1}_ZN3frc5Color10kChocolateE"]
            pub static Color_kChocolate: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF7F50."]
            #[link_name = "\u{1}_ZN3frc5Color6kCoralE"]
            pub static Color_kCoral: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x6495ED."]
            #[link_name = "\u{1}_ZN3frc5Color15kCornflowerBlueE"]
            pub static Color_kCornflowerBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFF8DC."]
            #[link_name = "\u{1}_ZN3frc5Color9kCornsilkE"]
            pub static Color_kCornsilk: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDC143C."]
            #[link_name = "\u{1}_ZN3frc5Color8kCrimsonE"]
            pub static Color_kCrimson: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color5kCyanE"]
            pub static Color_kCyan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00008B."]
            #[link_name = "\u{1}_ZN3frc5Color9kDarkBlueE"]
            pub static Color_kDarkBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x008B8B."]
            #[link_name = "\u{1}_ZN3frc5Color9kDarkCyanE"]
            pub static Color_kDarkCyan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB8860B."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkGoldenrodE"]
            pub static Color_kDarkGoldenrod: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xA9A9A9."]
            #[link_name = "\u{1}_ZN3frc5Color9kDarkGrayE"]
            pub static Color_kDarkGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x006400."]
            #[link_name = "\u{1}_ZN3frc5Color10kDarkGreenE"]
            pub static Color_kDarkGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xBDB76B."]
            #[link_name = "\u{1}_ZN3frc5Color10kDarkKhakiE"]
            pub static Color_kDarkKhaki: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8B008B."]
            #[link_name = "\u{1}_ZN3frc5Color12kDarkMagentaE"]
            pub static Color_kDarkMagenta: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x556B2F."]
            #[link_name = "\u{1}_ZN3frc5Color15kDarkOliveGreenE"]
            pub static Color_kDarkOliveGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF8C00."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkOrangeE"]
            pub static Color_kDarkOrange: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9932CC."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkOrchidE"]
            pub static Color_kDarkOrchid: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8B0000."]
            #[link_name = "\u{1}_ZN3frc5Color8kDarkRedE"]
            pub static Color_kDarkRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xE9967A."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkSalmonE"]
            pub static Color_kDarkSalmon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8FBC8F."]
            #[link_name = "\u{1}_ZN3frc5Color13kDarkSeaGreenE"]
            pub static Color_kDarkSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x483D8B."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkSlateBlueE"]
            pub static Color_kDarkSlateBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x2F4F4F."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkSlateGrayE"]
            pub static Color_kDarkSlateGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00CED1."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkTurquoiseE"]
            pub static Color_kDarkTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9400D3."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkVioletE"]
            pub static Color_kDarkViolet: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF1493."]
            #[link_name = "\u{1}_ZN3frc5Color9kDeepPinkE"]
            pub static Color_kDeepPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00BFFF."]
            #[link_name = "\u{1}_ZN3frc5Color12kDeepSkyBlueE"]
            pub static Color_kDeepSkyBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x696969."]
            #[link_name = "\u{1}_ZN3frc5Color8kDimGrayE"]
            pub static Color_kDimGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x1E90FF."]
            #[link_name = "\u{1}_ZN3frc5Color11kDodgerBlueE"]
            pub static Color_kDodgerBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB22222."]
            #[link_name = "\u{1}_ZN3frc5Color10kFirebrickE"]
            pub static Color_kFirebrick: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFAF0."]
            #[link_name = "\u{1}_ZN3frc5Color12kFloralWhiteE"]
            pub static Color_kFloralWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x228B22."]
            #[link_name = "\u{1}_ZN3frc5Color12kForestGreenE"]
            pub static Color_kForestGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF00FF."]
            #[link_name = "\u{1}_ZN3frc5Color8kFuchsiaE"]
            pub static Color_kFuchsia: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDCDCDC."]
            #[link_name = "\u{1}_ZN3frc5Color10kGainsboroE"]
            pub static Color_kGainsboro: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF8F8FF."]
            #[link_name = "\u{1}_ZN3frc5Color11kGhostWhiteE"]
            pub static Color_kGhostWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFD700."]
            #[link_name = "\u{1}_ZN3frc5Color5kGoldE"]
            pub static Color_kGold: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDAA520."]
            #[link_name = "\u{1}_ZN3frc5Color10kGoldenrodE"]
            pub static Color_kGoldenrod: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x808080."]
            #[link_name = "\u{1}_ZN3frc5Color5kGrayE"]
            pub static Color_kGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x008000."]
            #[link_name = "\u{1}_ZN3frc5Color6kGreenE"]
            pub static Color_kGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xADFF2F."]
            #[link_name = "\u{1}_ZN3frc5Color12kGreenYellowE"]
            pub static Color_kGreenYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0FFF0."]
            #[link_name = "\u{1}_ZN3frc5Color9kHoneydewE"]
            pub static Color_kHoneydew: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF69B4."]
            #[link_name = "\u{1}_ZN3frc5Color8kHotPinkE"]
            pub static Color_kHotPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xCD5C5C."]
            #[link_name = "\u{1}_ZN3frc5Color10kIndianRedE"]
            pub static Color_kIndianRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x4B0082."]
            #[link_name = "\u{1}_ZN3frc5Color7kIndigoE"]
            pub static Color_kIndigo: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFFF0."]
            #[link_name = "\u{1}_ZN3frc5Color6kIvoryE"]
            pub static Color_kIvory: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0E68C."]
            #[link_name = "\u{1}_ZN3frc5Color6kKhakiE"]
            pub static Color_kKhaki: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xE6E6FA."]
            #[link_name = "\u{1}_ZN3frc5Color9kLavenderE"]
            pub static Color_kLavender: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFF0F5."]
            #[link_name = "\u{1}_ZN3frc5Color14kLavenderBlushE"]
            pub static Color_kLavenderBlush: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7CFC00."]
            #[link_name = "\u{1}_ZN3frc5Color10kLawnGreenE"]
            pub static Color_kLawnGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFACD."]
            #[link_name = "\u{1}_ZN3frc5Color13kLemonChiffonE"]
            pub static Color_kLemonChiffon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xADD8E6."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightBlueE"]
            pub static Color_kLightBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF08080."]
            #[link_name = "\u{1}_ZN3frc5Color11kLightCoralE"]
            pub static Color_kLightCoral: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xE0FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightCyanE"]
            pub static Color_kLightCyan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFAFAD2."]
            #[link_name = "\u{1}_ZN3frc5Color21kLightGoldenrodYellowE"]
            pub static Color_kLightGoldenrodYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD3D3D3."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightGrayE"]
            pub static Color_kLightGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x90EE90."]
            #[link_name = "\u{1}_ZN3frc5Color11kLightGreenE"]
            pub static Color_kLightGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFB6C1."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightPinkE"]
            pub static Color_kLightPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFA07A."]
            #[link_name = "\u{1}_ZN3frc5Color12kLightSalmonE"]
            pub static Color_kLightSalmon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x20B2AA."]
            #[link_name = "\u{1}_ZN3frc5Color14kLightSeaGreenE"]
            pub static Color_kLightSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x87CEFA."]
            #[link_name = "\u{1}_ZN3frc5Color13kLightSkyBlueE"]
            pub static Color_kLightSkyBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x778899."]
            #[link_name = "\u{1}_ZN3frc5Color15kLightSlateGrayE"]
            pub static Color_kLightSlateGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB0C4DE."]
            #[link_name = "\u{1}_ZN3frc5Color15kLightSteelBlueE"]
            pub static Color_kLightSteelBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFFE0."]
            #[link_name = "\u{1}_ZN3frc5Color12kLightYellowE"]
            pub static Color_kLightYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FF00."]
            #[link_name = "\u{1}_ZN3frc5Color5kLimeE"]
            pub static Color_kLime: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x32CD32."]
            #[link_name = "\u{1}_ZN3frc5Color10kLimeGreenE"]
            pub static Color_kLimeGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFAF0E6."]
            #[link_name = "\u{1}_ZN3frc5Color6kLinenE"]
            pub static Color_kLinen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF00FF."]
            #[link_name = "\u{1}_ZN3frc5Color8kMagentaE"]
            pub static Color_kMagenta: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x800000."]
            #[link_name = "\u{1}_ZN3frc5Color7kMaroonE"]
            pub static Color_kMaroon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x66CDAA."]
            #[link_name = "\u{1}_ZN3frc5Color17kMediumAquamarineE"]
            pub static Color_kMediumAquamarine: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x0000CD."]
            #[link_name = "\u{1}_ZN3frc5Color11kMediumBlueE"]
            pub static Color_kMediumBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xBA55D3."]
            #[link_name = "\u{1}_ZN3frc5Color13kMediumOrchidE"]
            pub static Color_kMediumOrchid: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9370DB."]
            #[link_name = "\u{1}_ZN3frc5Color13kMediumPurpleE"]
            pub static Color_kMediumPurple: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x3CB371."]
            #[link_name = "\u{1}_ZN3frc5Color15kMediumSeaGreenE"]
            pub static Color_kMediumSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7B68EE."]
            #[link_name = "\u{1}_ZN3frc5Color16kMediumSlateBlueE"]
            pub static Color_kMediumSlateBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FA9A."]
            #[link_name = "\u{1}_ZN3frc5Color18kMediumSpringGreenE"]
            pub static Color_kMediumSpringGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x48D1CC."]
            #[link_name = "\u{1}_ZN3frc5Color16kMediumTurquoiseE"]
            pub static Color_kMediumTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xC71585."]
            #[link_name = "\u{1}_ZN3frc5Color16kMediumVioletRedE"]
            pub static Color_kMediumVioletRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x191970."]
            #[link_name = "\u{1}_ZN3frc5Color13kMidnightBlueE"]
            pub static Color_kMidnightBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5FFFA."]
            #[link_name = "\u{1}_ZN3frc5Color10kMintcreamE"]
            pub static Color_kMintcream: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFE4E1."]
            #[link_name = "\u{1}_ZN3frc5Color10kMistyRoseE"]
            pub static Color_kMistyRose: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFE4B5."]
            #[link_name = "\u{1}_ZN3frc5Color9kMoccasinE"]
            pub static Color_kMoccasin: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFDEAD."]
            #[link_name = "\u{1}_ZN3frc5Color12kNavajoWhiteE"]
            pub static Color_kNavajoWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x000080."]
            #[link_name = "\u{1}_ZN3frc5Color5kNavyE"]
            pub static Color_kNavy: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFDF5E6."]
            #[link_name = "\u{1}_ZN3frc5Color8kOldLaceE"]
            pub static Color_kOldLace: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x808000."]
            #[link_name = "\u{1}_ZN3frc5Color6kOliveE"]
            pub static Color_kOlive: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x6B8E23."]
            #[link_name = "\u{1}_ZN3frc5Color10kOliveDrabE"]
            pub static Color_kOliveDrab: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFA500."]
            #[link_name = "\u{1}_ZN3frc5Color7kOrangeE"]
            pub static Color_kOrange: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF4500."]
            #[link_name = "\u{1}_ZN3frc5Color10kOrangeRedE"]
            pub static Color_kOrangeRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDA70D6."]
            #[link_name = "\u{1}_ZN3frc5Color7kOrchidE"]
            pub static Color_kOrchid: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xEEE8AA."]
            #[link_name = "\u{1}_ZN3frc5Color14kPaleGoldenrodE"]
            pub static Color_kPaleGoldenrod: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x98FB98."]
            #[link_name = "\u{1}_ZN3frc5Color10kPaleGreenE"]
            pub static Color_kPaleGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xAFEEEE."]
            #[link_name = "\u{1}_ZN3frc5Color14kPaleTurquoiseE"]
            pub static Color_kPaleTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDB7093."]
            #[link_name = "\u{1}_ZN3frc5Color14kPaleVioletRedE"]
            pub static Color_kPaleVioletRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFEFD5."]
            #[link_name = "\u{1}_ZN3frc5Color11kPapayaWhipE"]
            pub static Color_kPapayaWhip: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFDAB9."]
            #[link_name = "\u{1}_ZN3frc5Color10kPeachPuffE"]
            pub static Color_kPeachPuff: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xCD853F."]
            #[link_name = "\u{1}_ZN3frc5Color5kPeruE"]
            pub static Color_kPeru: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFC0CB."]
            #[link_name = "\u{1}_ZN3frc5Color5kPinkE"]
            pub static Color_kPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDDA0DD."]
            #[link_name = "\u{1}_ZN3frc5Color5kPlumE"]
            pub static Color_kPlum: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB0E0E6."]
            #[link_name = "\u{1}_ZN3frc5Color11kPowderBlueE"]
            pub static Color_kPowderBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x800080."]
            #[link_name = "\u{1}_ZN3frc5Color7kPurpleE"]
            pub static Color_kPurple: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF0000."]
            #[link_name = "\u{1}_ZN3frc5Color4kRedE"]
            pub static Color_kRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xBC8F8F."]
            #[link_name = "\u{1}_ZN3frc5Color10kRosyBrownE"]
            pub static Color_kRosyBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x4169E1."]
            #[link_name = "\u{1}_ZN3frc5Color10kRoyalBlueE"]
            pub static Color_kRoyalBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8B4513."]
            #[link_name = "\u{1}_ZN3frc5Color12kSaddleBrownE"]
            pub static Color_kSaddleBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFA8072."]
            #[link_name = "\u{1}_ZN3frc5Color7kSalmonE"]
            pub static Color_kSalmon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF4A460."]
            #[link_name = "\u{1}_ZN3frc5Color11kSandyBrownE"]
            pub static Color_kSandyBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x2E8B57."]
            #[link_name = "\u{1}_ZN3frc5Color9kSeaGreenE"]
            pub static Color_kSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFF5EE."]
            #[link_name = "\u{1}_ZN3frc5Color9kSeashellE"]
            pub static Color_kSeashell: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xA0522D."]
            #[link_name = "\u{1}_ZN3frc5Color7kSiennaE"]
            pub static Color_kSienna: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xC0C0C0."]
            #[link_name = "\u{1}_ZN3frc5Color7kSilverE"]
            pub static Color_kSilver: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x87CEEB."]
            #[link_name = "\u{1}_ZN3frc5Color8kSkyBlueE"]
            pub static Color_kSkyBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x6A5ACD."]
            #[link_name = "\u{1}_ZN3frc5Color10kSlateBlueE"]
            pub static Color_kSlateBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x708090."]
            #[link_name = "\u{1}_ZN3frc5Color10kSlateGrayE"]
            pub static Color_kSlateGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFAFA."]
            #[link_name = "\u{1}_ZN3frc5Color5kSnowE"]
            pub static Color_kSnow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FF7F."]
            #[link_name = "\u{1}_ZN3frc5Color12kSpringGreenE"]
            pub static Color_kSpringGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x4682B4."]
            #[link_name = "\u{1}_ZN3frc5Color10kSteelBlueE"]
            pub static Color_kSteelBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD2B48C."]
            #[link_name = "\u{1}_ZN3frc5Color4kTanE"]
            pub static Color_kTan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x008080."]
            #[link_name = "\u{1}_ZN3frc5Color5kTealE"]
            pub static Color_kTeal: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD8BFD8."]
            #[link_name = "\u{1}_ZN3frc5Color8kThistleE"]
            pub static Color_kThistle: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF6347."]
            #[link_name = "\u{1}_ZN3frc5Color7kTomatoE"]
            pub static Color_kTomato: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x40E0D0."]
            #[link_name = "\u{1}_ZN3frc5Color10kTurquoiseE"]
            pub static Color_kTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xEE82EE."]
            #[link_name = "\u{1}_ZN3frc5Color7kVioletE"]
            pub static Color_kViolet: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5DEB3."]
            #[link_name = "\u{1}_ZN3frc5Color6kWheatE"]
            pub static Color_kWheat: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFFFF."]
            #[link_name = "\u{1}_ZN3frc5Color6kWhiteE"]
            pub static Color_kWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5F5F5."]
            #[link_name = "\u{1}_ZN3frc5Color11kWhiteSmokeE"]
            pub static Color_kWhiteSmoke: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFF00."]
            #[link_name = "\u{1}_ZN3frc5Color7kYellowE"]
            pub static Color_kYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9ACD32."]
            #[link_name = "\u{1}_ZN3frc5Color12kYellowGreenE"]
            pub static Color_kYellowGreen: root::frc::Color;
        }
        pub const Color_kPrecision: f64 = 0.000244140625;
        #[test]
        fn bindgen_test_layout_Color() {
            assert_eq!(
                ::std::mem::size_of::<Color>(),
                24usize,
                concat!("Size of: ", stringify!(Color))
            );
            assert_eq!(
                ::std::mem::align_of::<Color>(),
                8usize,
                concat!("Alignment of ", stringify!(Color))
            );
            fn test_field_red() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<Color>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color),
                        "::",
                        stringify!(red)
                    )
                );
            }
            test_field_red();
            fn test_field_green() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<Color>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color),
                        "::",
                        stringify!(green)
                    )
                );
            }
            test_field_green();
            fn test_field_blue() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<Color>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color),
                        "::",
                        stringify!(blue)
                    )
                );
            }
            test_field_blue();
        }
        #[doc = " I2C bus interface class."]
        #[doc = ""]
        #[doc = " This class is intended to be used by sensor (and other I2C device) drivers."]
        #[doc = " It probably should not be used directly."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct I2C {
            pub m_port: root::hal::I2CPort,
            pub m_deviceAddress: ::std::os::raw::c_int,
        }
        pub const I2C_Port_kOnboard: root::frc::I2C_Port = 0;
        pub const I2C_Port_kMXP: root::frc::I2C_Port = 1;
        pub type I2C_Port = ::std::os::raw::c_uint;
        #[test]
        fn bindgen_test_layout_I2C() {
            assert_eq!(
                ::std::mem::size_of::<I2C>(),
                8usize,
                concat!("Size of: ", stringify!(I2C))
            );
            assert_eq!(
                ::std::mem::align_of::<I2C>(),
                4usize,
                concat!("Alignment of ", stringify!(I2C))
            );
            fn test_field_m_port() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<I2C>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(I2C),
                        "::",
                        stringify!(m_port)
                    )
                );
            }
            test_field_m_port();
            fn test_field_m_deviceAddress() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<I2C>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_deviceAddress) as usize - ptr as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(I2C),
                        "::",
                        stringify!(m_deviceAddress)
                    )
                );
            }
            test_field_m_deviceAddress();
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK3frc3I2C7GetPortEv"]
            pub fn I2C_GetPort(this: *const root::frc::I2C) -> root::frc::I2C_Port;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK3frc3I2C16GetDeviceAddressEv"]
            pub fn I2C_GetDeviceAddress(this: *const root::frc::I2C) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Generic transaction."]
            #[doc = ""]
            #[doc = " This is a lower-level interface to the I2C hardware giving you more control"]
            #[doc = " over each transaction. If you intend to write multiple bytes in the same"]
            #[doc = " transaction and do not plan to receive anything back, use writeBulk()"]
            #[doc = " instead. Calling this with a receiveSize of 0 will result in an error."]
            #[doc = ""]
            #[doc = " @param dataToSend   Buffer of data to send as part of the transaction."]
            #[doc = " @param sendSize     Number of bytes to send as part of the transaction."]
            #[doc = " @param dataReceived Buffer to read data into."]
            #[doc = " @param receiveSize  Number of bytes to read from the device."]
            #[doc = " @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C11TransactionEPhiS1_i"]
            pub fn I2C_Transaction(
                this: *mut root::frc::I2C,
                dataToSend: *mut u8,
                sendSize: ::std::os::raw::c_int,
                dataReceived: *mut u8,
                receiveSize: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Attempt to address a device on the I2C bus."]
            #[doc = ""]
            #[doc = " This allows you to figure out if there is a device on the I2C bus that"]
            #[doc = " responds to the address specified in the constructor."]
            #[doc = ""]
            #[doc = " @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C11AddressOnlyEv"]
            pub fn I2C_AddressOnly(this: *mut root::frc::I2C) -> bool;
        }
        extern "C" {
            #[doc = " Execute a write transaction with the device."]
            #[doc = ""]
            #[doc = " Write a single byte to a register on a device and wait until the"]
            #[doc = "   transaction is complete."]
            #[doc = ""]
            #[doc = " @param registerAddress The address of the register on the device to be"]
            #[doc = "                        written."]
            #[doc = " @param data            The byte to write to the register on the device."]
            #[doc = " @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C5WriteEih"]
            pub fn I2C_Write(
                this: *mut root::frc::I2C,
                registerAddress: ::std::os::raw::c_int,
                data: u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a bulk write transaction with the device."]
            #[doc = ""]
            #[doc = " Write multiple bytes to a device and wait until the"]
            #[doc = "   transaction is complete."]
            #[doc = ""]
            #[doc = " @param data  The data to write to the register on the device."]
            #[doc = " @param count The number of bytes to be written."]
            #[doc = " @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C9WriteBulkEPhi"]
            pub fn I2C_WriteBulk(
                this: *mut root::frc::I2C,
                data: *mut u8,
                count: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a read transaction with the device."]
            #[doc = ""]
            #[doc = " Read bytes from a device."]
            #[doc = " Most I2C devices will auto-increment the register pointer internally"]
            #[doc = " allowing you to read consecutive registers on a device in a single"]
            #[doc = " transaction."]
            #[doc = ""]
            #[doc = " @param registerAddress The register to read first in the transaction."]
            #[doc = " @param count           The number of bytes to read in the transaction."]
            #[doc = " @param data            A pointer to the array of bytes to store the data"]
            #[doc = "                        read from the device."]
            #[doc = " @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C4ReadEiiPh"]
            pub fn I2C_Read(
                this: *mut root::frc::I2C,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                data: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a read only transaction with the device."]
            #[doc = ""]
            #[doc = " Read bytes from a device. This method does not write any data to prompt the"]
            #[doc = " device."]
            #[doc = ""]
            #[doc = " @param buffer A pointer to the array of bytes to store the data read from"]
            #[doc = "               the device."]
            #[doc = " @param count  The number of bytes to read in the transaction."]
            #[doc = " @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C8ReadOnlyEiPh"]
            pub fn I2C_ReadOnly(
                this: *mut root::frc::I2C,
                count: ::std::os::raw::c_int,
                buffer: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Verify that a device's registers contain expected values."]
            #[doc = ""]
            #[doc = " Most devices will have a set of registers that contain a known value that"]
            #[doc = " can be used to identify them.  This allows an I2C device driver to easily"]
            #[doc = " verify that the device contains the expected value."]
            #[doc = ""]
            #[doc = " @pre The device must support and be configured to use register"]
            #[doc = " auto-increment."]
            #[doc = ""]
            #[doc = " @param registerAddress The base register to start reading from the device."]
            #[doc = " @param count           The size of the field to be verified."]
            #[doc = " @param expected        A buffer containing the values expected from the"]
            #[doc = "                        device."]
            #[link_name = "\u{1}_ZN3frc3I2C12VerifySensorEiiPKh"]
            pub fn I2C_VerifySensor(
                this: *mut root::frc::I2C,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                expected: *const u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Constructor."]
            #[doc = ""]
            #[doc = " @param port          The I2C port to which the device is connected."]
            #[doc = " @param deviceAddress The address of the device on the I2C bus."]
            #[link_name = "\u{1}_ZN3frc3I2CC1ENS0_4PortEi"]
            pub fn I2C_I2C(
                this: *mut root::frc::I2C,
                port: root::frc::I2C_Port,
                deviceAddress: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc3I2CD1Ev"]
            pub fn I2C_I2C_destructor(this: *mut root::frc::I2C);
        }
        impl I2C {
            #[inline]
            pub unsafe fn GetPort(&self) -> root::frc::I2C_Port {
                I2C_GetPort(self)
            }
            #[inline]
            pub unsafe fn GetDeviceAddress(&self) -> ::std::os::raw::c_int {
                I2C_GetDeviceAddress(self)
            }
            #[inline]
            pub unsafe fn Transaction(
                &mut self,
                dataToSend: *mut u8,
                sendSize: ::std::os::raw::c_int,
                dataReceived: *mut u8,
                receiveSize: ::std::os::raw::c_int,
            ) -> bool {
                I2C_Transaction(self, dataToSend, sendSize, dataReceived, receiveSize)
            }
            #[inline]
            pub unsafe fn AddressOnly(&mut self) -> bool {
                I2C_AddressOnly(self)
            }
            #[inline]
            pub unsafe fn Write(
                &mut self,
                registerAddress: ::std::os::raw::c_int,
                data: u8,
            ) -> bool {
                I2C_Write(self, registerAddress, data)
            }
            #[inline]
            pub unsafe fn WriteBulk(
                &mut self,
                data: *mut u8,
                count: ::std::os::raw::c_int,
            ) -> bool {
                I2C_WriteBulk(self, data, count)
            }
            #[inline]
            pub unsafe fn Read(
                &mut self,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                data: *mut u8,
            ) -> bool {
                I2C_Read(self, registerAddress, count, data)
            }
            #[inline]
            pub unsafe fn ReadOnly(
                &mut self,
                count: ::std::os::raw::c_int,
                buffer: *mut u8,
            ) -> bool {
                I2C_ReadOnly(self, count, buffer)
            }
            #[inline]
            pub unsafe fn VerifySensor(
                &mut self,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                expected: *const u8,
            ) -> bool {
                I2C_VerifySensor(self, registerAddress, count, expected)
            }
            #[inline]
            pub unsafe fn new(
                port: root::frc::I2C_Port,
                deviceAddress: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                I2C_I2C(__bindgen_tmp.as_mut_ptr(), port, deviceAddress);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                I2C_I2C_destructor(self)
            }
        }
    }
    pub type HAL_Handle = i32;
    pub type HAL_SimDeviceHandle = root::HAL_Handle;
    pub type HAL_SimValueHandle = root::HAL_Handle;
    pub mod hal {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " A move-only C++ wrapper around a HAL handle."]
        #[doc = " Does not ensure destruction."]
        pub type I2CPort = u32;
        #[doc = " C++ wrapper around a HAL simulator value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimValue {
            pub m_handle: root::HAL_SimValueHandle,
        }
        #[test]
        fn bindgen_test_layout_SimValue() {
            assert_eq!(
                ::std::mem::size_of::<SimValue>(),
                4usize,
                concat!("Size of: ", stringify!(SimValue))
            );
            assert_eq!(
                ::std::mem::align_of::<SimValue>(),
                4usize,
                concat!("Alignment of ", stringify!(SimValue))
            );
            fn test_field_m_handle() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SimValue>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SimValue),
                        "::",
                        stringify!(m_handle)
                    )
                );
            }
            test_field_m_handle();
        }
        #[doc = " C++ wrapper around a HAL simulator double value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimDouble {
            pub _base: root::hal::SimValue,
        }
        #[test]
        fn bindgen_test_layout_SimDouble() {
            assert_eq!(
                ::std::mem::size_of::<SimDouble>(),
                4usize,
                concat!("Size of: ", stringify!(SimDouble))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDouble>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDouble))
            );
        }
        #[doc = " A move-only C++ wrapper around a HAL simulator device handle."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SimDevice {
            pub m_handle: root::HAL_SimDeviceHandle,
        }
        pub const SimDevice_Direction_kInput: root::hal::SimDevice_Direction = 0;
        pub const SimDevice_Direction_kOutput: root::hal::SimDevice_Direction = 1;
        pub const SimDevice_Direction_kBidir: root::hal::SimDevice_Direction = 2;
        #[doc = " Direction of a simulated value (from the perspective of user code)."]
        pub type SimDevice_Direction = ::std::os::raw::c_uint;
        #[test]
        fn bindgen_test_layout_SimDevice() {
            assert_eq!(
                ::std::mem::size_of::<SimDevice>(),
                4usize,
                concat!("Size of: ", stringify!(SimDevice))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDevice>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDevice))
            );
            fn test_field_m_handle() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SimDevice>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SimDevice),
                        "::",
                        stringify!(m_handle)
                    )
                );
            }
            test_field_m_handle();
        }
        extern "C" {
            #[doc = " Creates a simulated device."]
            #[doc = ""]
            #[doc = " The device name must be unique.  Returns null if the device name"]
            #[doc = " already exists.  This is a convenience method that appends index in"]
            #[doc = " brackets to the device name, e.g. passing index=1 results in \"device[1]\""]
            #[doc = " for the device name."]
            #[doc = ""]
            #[doc = " If not in simulation, results in an \"empty\" object that evaluates to false"]
            #[doc = " in a boolean context."]
            #[doc = ""]
            #[doc = " @param name device name"]
            #[doc = " @param index device index number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKci"]
            pub fn SimDevice_SimDevice(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Creates a simulated device."]
            #[doc = ""]
            #[doc = " The device name must be unique.  Returns null if the device name"]
            #[doc = " already exists.  This is a convenience method that appends index and"]
            #[doc = " channel in brackets to the device name, e.g. passing index=1 and channel=2"]
            #[doc = " results in \"device[1,2]\" for the device name."]
            #[doc = ""]
            #[doc = " If not in simulation, results in an \"empty\" object that evaluates to false"]
            #[doc = " in a boolean context."]
            #[doc = ""]
            #[doc = " @param name device name"]
            #[doc = " @param index device index number to append to name"]
            #[doc = " @param channel device channel number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKcii"]
            pub fn SimDevice_SimDevice1(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            );
        }
        impl SimDevice {
            #[inline]
            pub unsafe fn new(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice(__bindgen_tmp.as_mut_ptr(), name, index);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice1(__bindgen_tmp.as_mut_ptr(), name, index, channel);
                __bindgen_tmp.assume_init()
            }
        }
    }
    pub const HAL_I2CPort_HAL_I2C_kInvalid: root::HAL_I2CPort = -1;
    pub const HAL_I2CPort_HAL_I2C_kOnboard: root::HAL_I2CPort = 0;
    pub const HAL_I2CPort_HAL_I2C_kMXP: root::HAL_I2CPort = 1;
    #[doc = " @defgroup hal_i2c I2C Functions"]
    #[doc = " @ingroup hal_capi"]
    #[doc = " @{"]
    pub type HAL_I2CPort = i32;
    pub mod wpi {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_t_open0_volt_double_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_Color_allocator_open1_Color_close1_close0_instantiation()
    {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_Color_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
}
