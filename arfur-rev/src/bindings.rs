/* automatically generated by rust-bindgen 0.66.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub type __intmax_t = ::std::os::raw::c_long;
    pub type intmax_t = root::__intmax_t;
    pub mod rev {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const REVLibError_kOk: root::rev::REVLibError = 0;
        pub const REVLibError_kError: root::rev::REVLibError = 1;
        pub const REVLibError_kTimeout: root::rev::REVLibError = 2;
        pub const REVLibError_kNotImplemented: root::rev::REVLibError = 3;
        pub const REVLibError_kHALError: root::rev::REVLibError = 4;
        pub const REVLibError_kCantFindFirmware: root::rev::REVLibError = 5;
        pub const REVLibError_kFirmwareTooOld: root::rev::REVLibError = 6;
        pub const REVLibError_kFirmwareTooNew: root::rev::REVLibError = 7;
        pub const REVLibError_kParamInvalidID: root::rev::REVLibError = 8;
        pub const REVLibError_kParamMismatchType: root::rev::REVLibError = 9;
        pub const REVLibError_kParamAccessMode: root::rev::REVLibError = 10;
        pub const REVLibError_kParamInvalid: root::rev::REVLibError = 11;
        pub const REVLibError_kParamNotImplementedDeprecated: root::rev::REVLibError = 12;
        pub const REVLibError_kFollowConfigMismatch: root::rev::REVLibError = 13;
        pub const REVLibError_kInvalid: root::rev::REVLibError = 14;
        pub const REVLibError_kSetpointOutOfRange: root::rev::REVLibError = 15;
        pub const REVLibError_kUnknown: root::rev::REVLibError = 16;
        pub const REVLibError_kCANDisconnected: root::rev::REVLibError = 17;
        pub const REVLibError_kDuplicateCANId: root::rev::REVLibError = 18;
        pub const REVLibError_kInvalidCANId: root::rev::REVLibError = 19;
        pub const REVLibError_kSparkMaxDataPortAlreadyConfiguredDifferently:
            root::rev::REVLibError = 20;
        pub type REVLibError = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct AnalogInput__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Get an instance of AnalogInput by using\n CANSparkMax::GetAnalog(SparkMaxAnalogSensor::Mode)}."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AnalogInput {
            pub vtable_: *const AnalogInput__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_AnalogInput() {
            assert_eq!(
                ::std::mem::size_of::<AnalogInput>(),
                8usize,
                concat!("Size of: ", stringify!(AnalogInput))
            );
            assert_eq!(
                ::std::mem::align_of::<AnalogInput>(),
                8usize,
                concat!("Alignment of ", stringify!(AnalogInput))
            );
        }
        #[repr(C)]
        pub struct CANSensor__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " @deprecated Use MotorFeedbackSensor instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANSensor {
            pub vtable_: *const CANSensor__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CANSensor() {
            assert_eq!(
                ::std::mem::size_of::<CANSensor>(),
                8usize,
                concat!("Size of: ", stringify!(CANSensor))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSensor>(),
                8usize,
                concat!("Alignment of ", stringify!(CANSensor))
            );
        }
        #[doc = " A sensor that can be used to provide rotational feedback to a motor\n controller"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct MotorFeedbackSensor {
            pub _base: root::rev::CANSensor,
        }
        #[test]
        fn bindgen_test_layout_MotorFeedbackSensor() {
            assert_eq!(
                ::std::mem::size_of::<MotorFeedbackSensor>(),
                8usize,
                concat!("Size of: ", stringify!(MotorFeedbackSensor))
            );
            assert_eq!(
                ::std::mem::align_of::<MotorFeedbackSensor>(),
                8usize,
                concat!("Alignment of ", stringify!(MotorFeedbackSensor))
            );
        }
        #[doc = " @deprecated Use SparkMaxAnalogSensor instead."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANAnalog {
            pub _base: root::rev::MotorFeedbackSensor,
        }
        pub const CANAnalog_AnalogMode_kAbsolute: root::rev::CANAnalog_AnalogMode = 0;
        pub const CANAnalog_AnalogMode_kRelative: root::rev::CANAnalog_AnalogMode = 1;
        #[doc = " Analog sensors have the ability to either be absolute or relative.\n By default, GetAnalog() will return an absolute analog sensor, but\n it can also be configured to be a relative sensor instead.\n\n @deprecated Use SparkMaxAnalogSensor::Mode instead"]
        pub type CANAnalog_AnalogMode = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANAnalog() {
            assert_eq!(
                ::std::mem::size_of::<CANAnalog>(),
                8usize,
                concat!("Size of: ", stringify!(CANAnalog))
            );
            assert_eq!(
                ::std::mem::align_of::<CANAnalog>(),
                8usize,
                concat!("Alignment of ", stringify!(CANAnalog))
            );
        }
        #[repr(C)]
        pub struct CANDigitalInput__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " @deprecated Use SparkMaxLimitSwitch instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANDigitalInput {
            pub vtable_: *const CANDigitalInput__bindgen_vtable,
        }
        pub const CANDigitalInput_LimitSwitchPolarity_kNormallyOpen:
            root::rev::CANDigitalInput_LimitSwitchPolarity = 0;
        pub const CANDigitalInput_LimitSwitchPolarity_kNormallyClosed:
            root::rev::CANDigitalInput_LimitSwitchPolarity = 1;
        #[doc = " @deprecated Use SparkMaxLimitSwitch::Type instead"]
        pub type CANDigitalInput_LimitSwitchPolarity = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANDigitalInput() {
            assert_eq!(
                ::std::mem::size_of::<CANDigitalInput>(),
                8usize,
                concat!("Size of: ", stringify!(CANDigitalInput))
            );
            assert_eq!(
                ::std::mem::align_of::<CANDigitalInput>(),
                8usize,
                concat!("Alignment of ", stringify!(CANDigitalInput))
            );
        }
        #[doc = " @deprecated Use SparkMaxRelativeEncoder or SparkMaxAlternateEncoder instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANEncoder {
            pub _base: root::rev::MotorFeedbackSensor,
        }
        pub const CANEncoder_EncoderType_kNoSensor: root::rev::CANEncoder_EncoderType = 0;
        pub const CANEncoder_EncoderType_kHallSensor: root::rev::CANEncoder_EncoderType = 1;
        pub const CANEncoder_EncoderType_kQuadrature: root::rev::CANEncoder_EncoderType = 2;
        #[doc = " @deprecated Use SparkMaxRelativeEncoder::Type instead"]
        pub type CANEncoder_EncoderType = ::std::os::raw::c_int;
        pub const CANEncoder_AlternateEncoderType_kQuadrature:
            root::rev::CANEncoder_AlternateEncoderType = 0;
        #[doc = " @deprecated Use SparkMaxAlternateEncoder::Type instead"]
        pub type CANEncoder_AlternateEncoderType = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANEncoder() {
            assert_eq!(
                ::std::mem::size_of::<CANEncoder>(),
                8usize,
                concat!("Size of: ", stringify!(CANEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<CANEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(CANEncoder))
            );
        }
        pub const ControlType_kDutyCycle: root::rev::ControlType = 0;
        pub const ControlType_kVelocity: root::rev::ControlType = 1;
        pub const ControlType_kVoltage: root::rev::ControlType = 2;
        pub const ControlType_kPosition: root::rev::ControlType = 3;
        pub const ControlType_kSmartMotion: root::rev::ControlType = 4;
        pub const ControlType_kCurrent: root::rev::ControlType = 5;
        pub const ControlType_kSmartVelocity: root::rev::ControlType = 6;
        #[doc = " @deprecated Use CANSparkMax::ControlType instead"]
        pub type ControlType = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct CANPIDController__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " @deprecated Use SparkMaxPIDController instead"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANPIDController {
            pub vtable_: *const CANPIDController__bindgen_vtable,
        }
        pub const CANPIDController_AccelStrategy_kTrapezoidal:
            root::rev::CANPIDController_AccelStrategy = 0;
        pub const CANPIDController_AccelStrategy_kSCurve:
            root::rev::CANPIDController_AccelStrategy = 1;
        #[doc = " @deprecated Use SparkMaxPIDController::AccelStrategy instead"]
        pub type CANPIDController_AccelStrategy = ::std::os::raw::c_int;
        pub const CANPIDController_ArbFFUnits_kVoltage: root::rev::CANPIDController_ArbFFUnits = 0;
        pub const CANPIDController_ArbFFUnits_kPercentOut: root::rev::CANPIDController_ArbFFUnits =
            1;
        #[doc = " @deprecated Use SparkMaxPIDController::ArbFFUnits instead"]
        pub type CANPIDController_ArbFFUnits = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_CANPIDController() {
            assert_eq!(
                ::std::mem::size_of::<CANPIDController>(),
                8usize,
                concat!("Size of: ", stringify!(CANPIDController))
            );
            assert_eq!(
                ::std::mem::align_of::<CANPIDController>(),
                8usize,
                concat!("Alignment of ", stringify!(CANPIDController))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANSparkMaxLowLevel {
            pub _base: root::frc::MotorController,
            pub m_motorType: root::rev::CANSparkMaxLowLevel_MotorType,
            pub m_sparkMaxHandle: *mut ::std::os::raw::c_void,
            pub m_deviceID: ::std::os::raw::c_int,
        }
        pub const CANSparkMaxLowLevel_MotorType_kBrushed: root::rev::CANSparkMaxLowLevel_MotorType =
            0;
        pub const CANSparkMaxLowLevel_MotorType_kBrushless:
            root::rev::CANSparkMaxLowLevel_MotorType = 1;
        pub type CANSparkMaxLowLevel_MotorType = ::std::os::raw::c_int;
        pub const CANSparkMaxLowLevel_ControlType_kDutyCycle:
            root::rev::CANSparkMaxLowLevel_ControlType = 0;
        pub const CANSparkMaxLowLevel_ControlType_kVelocity:
            root::rev::CANSparkMaxLowLevel_ControlType = 1;
        pub const CANSparkMaxLowLevel_ControlType_kVoltage:
            root::rev::CANSparkMaxLowLevel_ControlType = 2;
        pub const CANSparkMaxLowLevel_ControlType_kPosition:
            root::rev::CANSparkMaxLowLevel_ControlType = 3;
        pub const CANSparkMaxLowLevel_ControlType_kSmartMotion:
            root::rev::CANSparkMaxLowLevel_ControlType = 4;
        pub const CANSparkMaxLowLevel_ControlType_kCurrent:
            root::rev::CANSparkMaxLowLevel_ControlType = 5;
        pub const CANSparkMaxLowLevel_ControlType_kSmartVelocity:
            root::rev::CANSparkMaxLowLevel_ControlType = 6;
        pub type CANSparkMaxLowLevel_ControlType = ::std::os::raw::c_int;
        pub const CANSparkMaxLowLevel_ParameterStatus_kOK:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 0;
        pub const CANSparkMaxLowLevel_ParameterStatus_kInvalidID:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 1;
        pub const CANSparkMaxLowLevel_ParameterStatus_kMismatchType:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 2;
        pub const CANSparkMaxLowLevel_ParameterStatus_kAccessMode:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 3;
        pub const CANSparkMaxLowLevel_ParameterStatus_kInvalid:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 4;
        pub const CANSparkMaxLowLevel_ParameterStatus_kNotImplementedDeprecated:
            root::rev::CANSparkMaxLowLevel_ParameterStatus = 5;
        pub type CANSparkMaxLowLevel_ParameterStatus = ::std::os::raw::c_int;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus0:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 0;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus1:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 1;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus2:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 2;
        pub const CANSparkMaxLowLevel_PeriodicFrame_kStatus3:
            root::rev::CANSparkMaxLowLevel_PeriodicFrame = 3;
        pub type CANSparkMaxLowLevel_PeriodicFrame = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_PeriodicStatus0 {
            pub appliedOutput: f64,
            pub faults: u16,
            pub stickyFaults: u16,
            pub motorType: root::rev::CANSparkMaxLowLevel_MotorType,
            pub isFollower: bool,
            pub lock: u8,
            pub roboRIO: u8,
            pub isInverted: u8,
            pub timestamp: u64,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_PeriodicStatus0() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMaxLowLevel_PeriodicStatus0> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_PeriodicStatus0>(),
                32usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_PeriodicStatus0))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_PeriodicStatus0>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).appliedOutput) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(appliedOutput)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).faults) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(faults)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).stickyFaults) as usize - ptr as usize },
                10usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(stickyFaults)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).motorType) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(motorType)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isFollower) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(isFollower)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
                17usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(lock)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).roboRIO) as usize - ptr as usize },
                18usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(roboRIO)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).isInverted) as usize - ptr as usize },
                19usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(isInverted)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus0),
                    "::",
                    stringify!(timestamp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_PeriodicStatus1 {
            pub sensorVelocity: f64,
            pub motorTemperature: u8,
            pub busVoltage: f64,
            pub outputCurrent: f64,
            pub timestamp: u64,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_PeriodicStatus1() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMaxLowLevel_PeriodicStatus1> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_PeriodicStatus1>(),
                40usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_PeriodicStatus1))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_PeriodicStatus1>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sensorVelocity) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                    "::",
                    stringify!(sensorVelocity)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).motorTemperature) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                    "::",
                    stringify!(motorTemperature)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).busVoltage) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                    "::",
                    stringify!(busVoltage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).outputCurrent) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                    "::",
                    stringify!(outputCurrent)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus1),
                    "::",
                    stringify!(timestamp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_PeriodicStatus2 {
            pub sensorPosition: f64,
            pub iAccum: f64,
            pub timestamp: u64,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_PeriodicStatus2() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMaxLowLevel_PeriodicStatus2> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_PeriodicStatus2>(),
                24usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_PeriodicStatus2))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_PeriodicStatus2>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus2)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sensorPosition) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus2),
                    "::",
                    stringify!(sensorPosition)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).iAccum) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus2),
                    "::",
                    stringify!(iAccum)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_PeriodicStatus2),
                    "::",
                    stringify!(timestamp)
                )
            );
        }
        pub const CANSparkMaxLowLevel_TelemetryID_kBusVoltage:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 0;
        pub const CANSparkMaxLowLevel_TelemetryID_kOutputCurrent:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 1;
        pub const CANSparkMaxLowLevel_TelemetryID_kVelocity:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 2;
        pub const CANSparkMaxLowLevel_TelemetryID_kPosition:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 3;
        pub const CANSparkMaxLowLevel_TelemetryID_kIAccum:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 4;
        pub const CANSparkMaxLowLevel_TelemetryID_kAppliedOutput:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 5;
        pub const CANSparkMaxLowLevel_TelemetryID_kMotorTemp:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 6;
        pub const CANSparkMaxLowLevel_TelemetryID_kFaults:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 7;
        pub const CANSparkMaxLowLevel_TelemetryID_kStickyFaults:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 8;
        pub const CANSparkMaxLowLevel_TelemetryID_kAnalogVoltage:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 9;
        pub const CANSparkMaxLowLevel_TelemetryID_kAnalogPosition:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 10;
        pub const CANSparkMaxLowLevel_TelemetryID_kAnalogVelocity:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 11;
        pub const CANSparkMaxLowLevel_TelemetryID_kAltEncPosition:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 12;
        pub const CANSparkMaxLowLevel_TelemetryID_kAltEncVelocity:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 13;
        pub const CANSparkMaxLowLevel_TelemetryID_kTotalStreams:
            root::rev::CANSparkMaxLowLevel_TelemetryID = 14;
        pub type CANSparkMaxLowLevel_TelemetryID = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_TelemetryMessage {
            pub id: root::rev::CANSparkMaxLowLevel_TelemetryID,
            pub value: f32,
            pub timestamp: u64,
            pub name: *const ::std::os::raw::c_char,
            pub units: *const ::std::os::raw::c_char,
            pub lowerBnd: f32,
            pub upperBnd: f32,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_TelemetryMessage() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMaxLowLevel_TelemetryMessage> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_TelemetryMessage>(),
                40usize,
                concat!(
                    "Size of: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_TelemetryMessage>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(id)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(value)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(timestamp)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(name)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(units)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).lowerBnd) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(lowerBnd)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).upperBnd) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_TelemetryMessage),
                    "::",
                    stringify!(upperBnd)
                )
            );
        }
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kNoSensor:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 0;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kHallSensor:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 1;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kQuadrature:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 2;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kSensorless:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 3;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kAnalog:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 4;
        pub const CANSparkMaxLowLevel_FeedbackSensorType_kAltQuadrature:
            root::rev::CANSparkMaxLowLevel_FeedbackSensorType = 5;
        pub type CANSparkMaxLowLevel_FeedbackSensorType = ::std::os::raw::c_int;
        #[repr(C)]
        #[repr(align(4))]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMaxLowLevel_FollowConfigBits {
            pub _bitfield_align_1: [u32; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_FollowConfigBits() {
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_FollowConfigBits>(),
                4usize,
                concat!(
                    "Size of: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfigBits)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_FollowConfigBits>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_FollowConfigBits)
                )
            );
        }
        impl CANSparkMaxLowLevel_FollowConfigBits {
            #[inline]
            pub fn rsvd1(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
            }
            #[inline]
            pub fn set_rsvd1(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 18u8, val as u64)
                }
            }
            #[inline]
            pub fn invert(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
            }
            #[inline]
            pub fn set_invert(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rsvd2(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
            }
            #[inline]
            pub fn set_rsvd2(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(19usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn predefined(&self) -> u32 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
            }
            #[inline]
            pub fn set_predefined(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::std::mem::transmute(val);
                    self._bitfield_1.set(24usize, 8u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                rsvd1: u32,
                invert: u32,
                rsvd2: u32,
                predefined: u32,
            ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 18u8, {
                    let rsvd1: u32 = unsafe { ::std::mem::transmute(rsvd1) };
                    rsvd1 as u64
                });
                __bindgen_bitfield_unit.set(18usize, 1u8, {
                    let invert: u32 = unsafe { ::std::mem::transmute(invert) };
                    invert as u64
                });
                __bindgen_bitfield_unit.set(19usize, 5u8, {
                    let rsvd2: u32 = unsafe { ::std::mem::transmute(rsvd2) };
                    rsvd2 as u64
                });
                __bindgen_bitfield_unit.set(24usize, 8u8, {
                    let predefined: u32 = unsafe { ::std::mem::transmute(predefined) };
                    predefined as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct CANSparkMaxLowLevel_FollowConfig {
            pub leaderArbId: u32,
            pub config: root::rev::CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion {
            pub value: u32,
            pub bits: root::rev::CANSparkMaxLowLevel_FollowConfigBits,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion() {
            const UNINIT: ::std::mem::MaybeUninit<
                CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion,
            > = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion>(),
                4usize,
                concat!(
                    "Size of: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion),
                    "::",
                    stringify!(value)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig_FollowConfigUnion),
                    "::",
                    stringify!(bits)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel_FollowConfig() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMaxLowLevel_FollowConfig> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel_FollowConfig>(),
                8usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel_FollowConfig))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel_FollowConfig>(),
                4usize,
                concat!(
                    "Alignment of ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).leaderArbId) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig),
                    "::",
                    stringify!(leaderArbId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel_FollowConfig),
                    "::",
                    stringify!(config)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel16kAPIMajorVersionE"]
            pub static CANSparkMaxLowLevel_kAPIMajorVersion: u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel16kAPIMinorVersionE"]
            pub static CANSparkMaxLowLevel_kAPIMinorVersion: u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel16kAPIBuildVersionE"]
            pub static CANSparkMaxLowLevel_kAPIBuildVersion: u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel11kAPIVersionE"]
            pub static CANSparkMaxLowLevel_kAPIVersion: u32;
        }
        #[test]
        fn bindgen_test_layout_CANSparkMaxLowLevel() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMaxLowLevel> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMaxLowLevel>(),
                32usize,
                concat!("Size of: ", stringify!(CANSparkMaxLowLevel))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMaxLowLevel>(),
                8usize,
                concat!("Alignment of ", stringify!(CANSparkMaxLowLevel))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_motorType) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel),
                    "::",
                    stringify!(m_motorType)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sparkMaxHandle) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel),
                    "::",
                    stringify!(m_sparkMaxHandle)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_deviceID) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMaxLowLevel),
                    "::",
                    stringify!(m_deviceID)
                )
            );
        }
        extern "C" {
            #[doc = " Get the firmware version of the SPARK MAX.\n\n @return uint32_t Firmware version integer. Value is represented as 4\n bytes, Major.Minor.Build H.Build L\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetFirmwareVersionEv"]
            pub fn CANSparkMaxLowLevel_GetFirmwareVersion(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetFirmwareVersionERb"]
            pub fn CANSparkMaxLowLevel_GetFirmwareVersion1(
                this: *mut root::rev::CANSparkMaxLowLevel,
                isDebugBuild: *mut bool,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the firmware version of the SPARK MAX as a string.\n\n @return std::string Human readable firmware version string\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel17GetFirmwareStringB5cxx11Ev"]
            pub fn CANSparkMaxLowLevel_GetFirmwareString(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::std::string;
        }
        extern "C" {
            #[doc = " Get the unique serial number of the SPARK MAX. Currently not implemented.\n\n @return std::vector<uint8_t> Vector of bytes representig the unique\n serial number\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel15GetSerialNumberEv"]
            pub fn CANSparkMaxLowLevel_GetSerialNumber(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::std::vector;
        }
        extern "C" {
            #[doc = " Get the configured Device ID of the SPARK MAX.\n\n @return int device ID\n"]
            #[link_name = "\u{1}_ZNK3rev19CANSparkMaxLowLevel11GetDeviceIdEv"]
            pub fn CANSparkMaxLowLevel_GetDeviceId(
                this: *const root::rev::CANSparkMaxLowLevel,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the motor type setting from when the SparkMax was created.\n\n This does not use the Get Parameter API which means it does not read\n what motor type is stored on the SparkMax itself. Instead, it reads\n the stored motor type from when the SparkMax object was first created.\n\n @return MotorType Motor type setting\n\n @deprecated Use GetMotorType() instead"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel19GetInitialMotorTypeEv"]
            pub fn CANSparkMaxLowLevel_GetInitialMotorType(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_MotorType;
        }
        extern "C" {
            #[doc = " Get the motor type setting for the SPARK MAX.\n\n @return MotorType Motor type setting\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel12GetMotorTypeEv"]
            pub fn CANSparkMaxLowLevel_GetMotorType(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_MotorType;
        }
        extern "C" {
            #[doc = " Set the rate of transmission for periodic frames from the SPARK MAX\n\n Each motor controller sends back three status frames with different\n data at set rates. Use this function to change the default rates.\n\n Defaults:\n Status0 - 10ms\n Status1 - 20ms\n Status2 - 50ms\n\n This value is not stored in the FLASH after calling burnFlash()\n and is reset on powerup.\n\n Refer to the SPARK MAX reference manual on details for how and when\n to configure this parameter.\n\n @param frameID   The frame ID can be one of PeriodicFrame type\n @param periodMs The rate the controller sends the frame to the\n controller.\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel22SetPeriodicFramePeriodENS0_13PeriodicFrameEi"]
            pub fn CANSparkMaxLowLevel_SetPeriodicFramePeriod(
                this: *mut root::rev::CANSparkMaxLowLevel,
                frame: root::rev::CANSparkMaxLowLevel_PeriodicFrame,
                periodMs: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the control frame send period for the native CAN Send thread. To\n disable periodic sends, set periodMs to 0.\n\n @param periodMs The send period in milliseconds between 1ms and 100ms\n or set to 0 to disable periodic sends. Note this is not updated until\n the next call to Set() or SetReference().\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel23SetControlFramePeriodMsEi"]
            pub fn CANSparkMaxLowLevel_SetControlFramePeriodMs(
                this: *mut root::rev::CANSparkMaxLowLevel,
                periodMs: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Restore motor controller parameters to factory default\n\n @param persist If true, burn the flash with the factory default\n parameters\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel22RestoreFactoryDefaultsEb"]
            pub fn CANSparkMaxLowLevel_RestoreFactoryDefaults(
                this: *mut root::rev::CANSparkMaxLowLevel,
                persist: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Allow external controllers to recieve control commands over USB.\n For example, a configuration where the heartbeat (and enable/disable)\n is sent by the main controller, but control frames are sent by\n other CAN devices over USB.\n\n This is global for all controllers on the same bus.\n\n This does not disable sending control frames from this device. To prevent\n conflicts, do not enable this feature and also send Set() for\n SetReference() from the controllers you wish to control.\n\n @param enable Enable or disable external control\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel24EnableExternalUSBControlEb"]
            pub fn CANSparkMaxLowLevel_EnableExternalUSBControl(enable: bool);
        }
        extern "C" {
            #[doc = " Send enabled or disabled command to controllers. This is global for all\n controllers on the same bus, and will only work for non-roboRIO targets\n in non-competiton use. This function will also not work if a roboRIO is\n present on the CAN bus.\n\n This does not disable sending control frames from this device. To prevent\n conflicts, do not enable this feature and also send Set() for\n SetReference() from the controllers you wish to control.\n\n @param enable Enable or disable external control\n"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel9SetEnableEb"]
            pub fn CANSparkMaxLowLevel_SetEnable(enable: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetPeriodicStatus0Ev"]
            pub fn CANSparkMaxLowLevel_GetPeriodicStatus0(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus0;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetPeriodicStatus1Ev"]
            pub fn CANSparkMaxLowLevel_GetPeriodicStatus1(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus1;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel18GetPeriodicStatus2Ev"]
            pub fn CANSparkMaxLowLevel_GetPeriodicStatus2(
                this: *mut root::rev::CANSparkMaxLowLevel,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus2;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel9SetFollowENS0_12FollowConfigE"]
            pub fn CANSparkMaxLowLevel_SetFollow(
                this: *mut root::rev::CANSparkMaxLowLevel,
                config: root::rev::CANSparkMaxLowLevel_FollowConfig,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel15SetpointCommandEdNS0_11ControlTypeEidi"]
            pub fn CANSparkMaxLowLevel_SetpointCommand(
                this: *mut root::rev::CANSparkMaxLowLevel,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevel12GetSafeFloatEf"]
            pub fn CANSparkMaxLowLevel_GetSafeFloat(
                this: *mut root::rev::CANSparkMaxLowLevel,
                f: f32,
            ) -> f32;
        }
        impl CANSparkMaxLowLevel {
            #[inline]
            pub unsafe fn GetFirmwareVersion(&mut self) -> u32 {
                CANSparkMaxLowLevel_GetFirmwareVersion(self)
            }
            #[inline]
            pub unsafe fn GetFirmwareVersion1(&mut self, isDebugBuild: *mut bool) -> u32 {
                CANSparkMaxLowLevel_GetFirmwareVersion1(self, isDebugBuild)
            }
            #[inline]
            pub unsafe fn GetFirmwareString(&mut self) -> root::std::string {
                CANSparkMaxLowLevel_GetFirmwareString(self)
            }
            #[inline]
            pub unsafe fn GetSerialNumber(&mut self) -> root::std::vector {
                CANSparkMaxLowLevel_GetSerialNumber(self)
            }
            #[inline]
            pub unsafe fn GetDeviceId(&self) -> ::std::os::raw::c_int {
                CANSparkMaxLowLevel_GetDeviceId(self)
            }
            #[inline]
            pub unsafe fn GetInitialMotorType(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_MotorType {
                CANSparkMaxLowLevel_GetInitialMotorType(self)
            }
            #[inline]
            pub unsafe fn GetMotorType(&mut self) -> root::rev::CANSparkMaxLowLevel_MotorType {
                CANSparkMaxLowLevel_GetMotorType(self)
            }
            #[inline]
            pub unsafe fn SetPeriodicFramePeriod(
                &mut self,
                frame: root::rev::CANSparkMaxLowLevel_PeriodicFrame,
                periodMs: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_SetPeriodicFramePeriod(self, frame, periodMs)
            }
            #[inline]
            pub unsafe fn SetControlFramePeriodMs(&mut self, periodMs: ::std::os::raw::c_int) {
                CANSparkMaxLowLevel_SetControlFramePeriodMs(self, periodMs)
            }
            #[inline]
            pub unsafe fn RestoreFactoryDefaults(
                &mut self,
                persist: bool,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_RestoreFactoryDefaults(self, persist)
            }
            #[inline]
            pub unsafe fn EnableExternalUSBControl(enable: bool) {
                CANSparkMaxLowLevel_EnableExternalUSBControl(enable)
            }
            #[inline]
            pub unsafe fn SetEnable(enable: bool) {
                CANSparkMaxLowLevel_SetEnable(enable)
            }
            #[inline]
            pub unsafe fn GetPeriodicStatus0(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus0 {
                CANSparkMaxLowLevel_GetPeriodicStatus0(self)
            }
            #[inline]
            pub unsafe fn GetPeriodicStatus1(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus1 {
                CANSparkMaxLowLevel_GetPeriodicStatus1(self)
            }
            #[inline]
            pub unsafe fn GetPeriodicStatus2(
                &mut self,
            ) -> root::rev::CANSparkMaxLowLevel_PeriodicStatus2 {
                CANSparkMaxLowLevel_GetPeriodicStatus2(self)
            }
            #[inline]
            pub unsafe fn SetFollow(
                &mut self,
                config: root::rev::CANSparkMaxLowLevel_FollowConfig,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_SetFollow(self, config)
            }
            #[inline]
            pub unsafe fn SetpointCommand(
                &mut self,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMaxLowLevel_SetpointCommand(
                    self,
                    value,
                    ctrl,
                    pidSlot,
                    arbFeedforward,
                    arbFFUnits,
                )
            }
            #[inline]
            pub unsafe fn GetSafeFloat(&mut self, f: f32) -> f32 {
                CANSparkMaxLowLevel_GetSafeFloat(self, f)
            }
        }
        extern "C" {
            #[doc = " Closes the SPARK MAX Controller"]
            #[link_name = "\u{1}_ZN3rev19CANSparkMaxLowLevelD1Ev"]
            pub fn CANSparkMaxLowLevel_CANSparkMaxLowLevel_destructor(
                this: *mut root::rev::CANSparkMaxLowLevel,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RelativeEncoder {
            pub _base: root::rev::CANEncoder,
        }
        #[test]
        fn bindgen_test_layout_RelativeEncoder() {
            assert_eq!(
                ::std::mem::size_of::<RelativeEncoder>(),
                8usize,
                concat!("Size of: ", stringify!(RelativeEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<RelativeEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(RelativeEncoder))
            );
        }
        #[doc = " Get an instance of this class by using CANSparkMax::GetEncoder() or\n CANSparkMax::GetEncoder(CANSparkMax::EncoderType, int)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxAlternateEncoder {
            pub _base: root::rev::RelativeEncoder,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_countsPerRev: ::std::os::raw::c_int,
        }
        pub const SparkMaxAlternateEncoder_Type_kQuadrature:
            root::rev::SparkMaxAlternateEncoder_Type = 0;
        #[doc = " The type of encoder wired as an Alternate Encoder on a SPARK MAX"]
        pub type SparkMaxAlternateEncoder_Type = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxAlternateEncoder() {
            const UNINIT: ::std::mem::MaybeUninit<SparkMaxAlternateEncoder> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SparkMaxAlternateEncoder>(),
                24usize,
                concat!("Size of: ", stringify!(SparkMaxAlternateEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxAlternateEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxAlternateEncoder))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxAlternateEncoder),
                    "::",
                    stringify!(m_device)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_countsPerRev) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxAlternateEncoder),
                    "::",
                    stringify!(m_countsPerRev)
                )
            );
        }
        extern "C" {
            #[doc = " Get the position of the motor. This returns the native units\n of 'rotations' by default, and can be changed by a scale factor\n using setPositionConversionFactor().\n\n @return Number of rotations of the motor\n"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder11GetPositionEv"]
            pub fn SparkMaxAlternateEncoder_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the velocity of the motor. This returns the native units\n of 'RPM' by default, and can be changed by a scale factor\n using setVelocityConversionFactor().\n\n @return Number the RPM of the motor\n"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder11GetVelocityEv"]
            pub fn SparkMaxAlternateEncoder_GetVelocity(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the position of the encoder.\n\n @param position Number of rotations of the motor\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder11SetPositionEd"]
            pub fn SparkMaxAlternateEncoder_SetPosition(
                this: *mut ::std::os::raw::c_void,
                position: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for position of the encoder. Multiplied by the\n native output units to give you position\n\n @param factor The conversion factor to multiply the native units by\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder27SetPositionConversionFactorEd"]
            pub fn SparkMaxAlternateEncoder_SetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for velocity of the encoder. Multiplied by the\n native output units to give you velocity\n\n @param factor The conversion factor to multiply the native units by\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder27SetVelocityConversionFactorEd"]
            pub fn SparkMaxAlternateEncoder_SetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the conversion factor for position of the encoder. Multiplied by the\n native output units to give you position\n\n @return The conversion factor for position"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder27GetPositionConversionFactorEv"]
            pub fn SparkMaxAlternateEncoder_GetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the conversion factor for velocity of the encoder. Multiplied by the\n native output units to give you velocity\n\n @return The conversion factor for velocity"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder27GetVelocityConversionFactorEv"]
            pub fn SparkMaxAlternateEncoder_GetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the average sampling depth for a quadrature encoder. This value\n sets the number of samples in the average for velocity readings. This\n can be any value from 1 to 64.\n\n @param depth The average sampling depth between 1 and 64 (default)\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder15SetAverageDepthEj"]
            pub fn SparkMaxAlternateEncoder_SetAverageDepth(
                this: *mut ::std::os::raw::c_void,
                depth: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the measurement period for velocity measurements of a quadrature\n encoder.\n\n The basic formula to calculate velocity is change in position / change in\n time. This parameter sets the change in time for measurement.\n\n @param period_us Measurement period in milliseconds. This number may be\n between 1 and 100 (default).\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder20SetMeasurementPeriodEj"]
            pub fn SparkMaxAlternateEncoder_SetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
                period_ms: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the average sampling depth for a quadrature encoder.\n\n @return The average sampling depth"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder15GetAverageDepthEv"]
            pub fn SparkMaxAlternateEncoder_GetAverageDepth(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the number of samples for reading from a quadrature encoder. This\n value sets the number of samples in the average for velocity readings.\n\n @return Measurement period in microseconds"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder20GetMeasurementPeriodEv"]
            pub fn SparkMaxAlternateEncoder_GetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the counts per revolution of the quadrature encoder.\n\n For a description on the difference between CPR, PPR, etc. go to\n https://www.cuidevices.com/blog/what-is-encoder-ppr-cpr-and-lpr\n\n @return Counts per revolution"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder22GetCountsPerRevolutionEv"]
            pub fn SparkMaxAlternateEncoder_GetCountsPerRevolution(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Set the phase of the MotorFeedbackSensor so that it is set to be in\n phase with the motor itself. This only works for quadrature\n encoders.\n\n @param inverted The phase of the encoder\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev24SparkMaxAlternateEncoder11SetInvertedEb"]
            pub fn SparkMaxAlternateEncoder_SetInverted(
                this: *mut ::std::os::raw::c_void,
                inverted: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the phase of the MotorFeedbackSensor. This will just return false\n if the user tries to get inverted while the SparkMax is\n Brushless and using the hall effect sensor.\n\n @return The phase of the encoder"]
            #[link_name = "\u{1}_ZNK3rev24SparkMaxAlternateEncoder11GetInvertedEv"]
            pub fn SparkMaxAlternateEncoder_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxAnalogSensor {
            pub _base: root::rev::AnalogInput,
            pub _base_1: root::rev::CANAnalog,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_mode: root::rev::SparkMaxAnalogSensor_Mode,
        }
        pub const SparkMaxAnalogSensor_Mode_kAbsolute: root::rev::SparkMaxAnalogSensor_Mode = 0;
        pub const SparkMaxAnalogSensor_Mode_kRelative: root::rev::SparkMaxAnalogSensor_Mode = 1;
        #[doc = " Analog sensors have the ability to either be absolute or relative.\n By default, CANSparkMax::GetAnalog() will return an absolute analog\n sensor, but it can also be configured to be a relative sensor instead."]
        pub type SparkMaxAnalogSensor_Mode = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxAnalogSensor() {
            const UNINIT: ::std::mem::MaybeUninit<SparkMaxAnalogSensor> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SparkMaxAnalogSensor>(),
                32usize,
                concat!("Size of: ", stringify!(SparkMaxAnalogSensor))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxAnalogSensor>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxAnalogSensor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxAnalogSensor),
                    "::",
                    stringify!(m_device)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_mode) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxAnalogSensor),
                    "::",
                    stringify!(m_mode)
                )
            );
        }
        extern "C" {
            #[doc = " Get the voltage of the analog sensor.\n\n @return Voltage of the sensor"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor10GetVoltageEv"]
            pub fn SparkMaxAnalogSensor_GetVoltage(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the position of the sensor. Returns value in the native unit\n of 'volt' by default, and can be changed by a scale factor\n using setPositionConversionFactor().\n\n @return Position of the sensor in volts"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor11GetPositionEv"]
            pub fn SparkMaxAnalogSensor_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the velocity of the sensor. Returns value in the native units of\n 'volts per second' by default, and can be changed by a\n scale factor using setVelocityConversionFactor().\n\n @return Velocity of the sensor in volts per second"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor11GetVelocityEv"]
            pub fn SparkMaxAnalogSensor_GetVelocity(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the conversion factor for the position of the analog sensor.\n By default, revolutions per volt is 1. Changing the position conversion\n factor will also change the position units.\n\n @param factor The conversion factor which will be multiplied by volts\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor27SetPositionConversionFactorEd"]
            pub fn SparkMaxAnalogSensor_SetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the current conversion factor for the position of the analog\n sensor.\n\n @return Analog position conversion factor"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor27GetPositionConversionFactorEv"]
            pub fn SparkMaxAnalogSensor_GetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the conversion factor for the velocity of the analog sensor.\n By default, revolutions per volt second is 1. Changing the velocity\n conversion factor will also change the velocity units.\n\n @param factor The conversion factor which will be multipled by volts per\n second\n\n @return REVLibError::kOk is successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor27SetVelocityConversionFactorEd"]
            pub fn SparkMaxAnalogSensor_SetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the current conversion factor for the velocity of the analog\n sensor.\n\n @return Analog velocity conversion factor"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor27GetVelocityConversionFactorEv"]
            pub fn SparkMaxAnalogSensor_GetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the number of samples in the average for velocity readings. This\n can be any value from 1 to 64.\n\n When the SparkMax controller is in Brushless mode, this\n will not change any behavior.\n\n @param depth The average sampling depth between 1 and 64 (default)\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor15SetAverageDepthEj"]
            pub fn SparkMaxAnalogSensor_SetAverageDepth(
                this: *mut ::std::os::raw::c_void,
                depth: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the measurement period for velocity readings.\n\n The basic formula to calculate velocity is change in position / change in\n time. This parameter sets the change in time for measurement.\n\n @param period_us Measurement period in milliseconds. This number may be\n between 1 and 100 (default).\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor20SetMeasurementPeriodEj"]
            pub fn SparkMaxAnalogSensor_SetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
                period_ms: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the number of samples included in the average for velocity readings.\n\n @return The average sampling depth"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor15GetAverageDepthEv"]
            pub fn SparkMaxAnalogSensor_GetAverageDepth(this: *mut ::std::os::raw::c_void) -> u32;
        }
        extern "C" {
            #[doc = " Get the measurement period used for velocity readings.\n\n @return Measurement period in microseconds"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor20GetMeasurementPeriodEv"]
            pub fn SparkMaxAnalogSensor_GetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Set the phase of the MotorFeedbackSensor so that it is set to be in\n phase with the motor itself. This only works for quadrature\n encoders. This will throw an error if the user tries to set\n inverted while the SparkMax is Brushless and using the hall\n effect sensor.\n\n @param inverted The phase of the encoder\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZThn8_N3rev20SparkMaxAnalogSensor11SetInvertedEb"]
            pub fn SparkMaxAnalogSensor_SetInverted(
                this: *mut ::std::os::raw::c_void,
                inverted: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the phase of the MotorFeedbackSensor. This will just return false\n if the user tries to get inverted while the SparkMax is\n Brushless and using the hall effect sensor.\n\n @return The phase of the encoder"]
            #[link_name = "\u{1}_ZThn8_NK3rev20SparkMaxAnalogSensor11GetInvertedEv"]
            pub fn SparkMaxAnalogSensor_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxLimitSwitch {
            pub _base: root::rev::CANDigitalInput,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_direction: root::rev::SparkMaxLimitSwitch_Direction,
        }
        pub const SparkMaxLimitSwitch_Type_kNormallyOpen: root::rev::SparkMaxLimitSwitch_Type = 0;
        pub const SparkMaxLimitSwitch_Type_kNormallyClosed: root::rev::SparkMaxLimitSwitch_Type = 1;
        #[doc = " Represents whether the circuit is open or closed when the switch is not\n being pressed"]
        pub type SparkMaxLimitSwitch_Type = ::std::os::raw::c_int;
        pub const SparkMaxLimitSwitch_Direction_kForward: root::rev::SparkMaxLimitSwitch_Direction =
            0;
        pub const SparkMaxLimitSwitch_Direction_kReverse: root::rev::SparkMaxLimitSwitch_Direction =
            1;
        pub type SparkMaxLimitSwitch_Direction = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxLimitSwitch() {
            const UNINIT: ::std::mem::MaybeUninit<SparkMaxLimitSwitch> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SparkMaxLimitSwitch>(),
                24usize,
                concat!("Size of: ", stringify!(SparkMaxLimitSwitch))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxLimitSwitch>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxLimitSwitch))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxLimitSwitch),
                    "::",
                    stringify!(m_device)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_direction) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxLimitSwitch),
                    "::",
                    stringify!(m_direction)
                )
            );
        }
        extern "C" {
            #[doc = " Get the state of the limit switch, whether or not it is enabled\n (limiting the rotation of the motor)."]
            #[link_name = "\u{1}_ZNK3rev19SparkMaxLimitSwitch3GetEv"]
            pub fn SparkMaxLimitSwitch_Get(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            #[doc = " Enables or disables controller shutdown based on limit switch."]
            #[link_name = "\u{1}_ZN3rev19SparkMaxLimitSwitch17EnableLimitSwitchEb"]
            pub fn SparkMaxLimitSwitch_EnableLimitSwitch(
                this: *mut ::std::os::raw::c_void,
                enable: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Returns true if limit switch is enabled."]
            #[link_name = "\u{1}_ZNK3rev19SparkMaxLimitSwitch20IsLimitSwitchEnabledEv"]
            pub fn SparkMaxLimitSwitch_IsLimitSwitchEnabled(
                this: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxPIDController {
            pub _base: root::rev::CANPIDController,
            pub m_device: *mut root::rev::CANSparkMax,
        }
        pub const SparkMaxPIDController_AccelStrategy_kTrapezoidal:
            root::rev::SparkMaxPIDController_AccelStrategy = 0;
        pub const SparkMaxPIDController_AccelStrategy_kSCurve:
            root::rev::SparkMaxPIDController_AccelStrategy = 1;
        #[doc = " Acceleration strategy used by Smart Motion"]
        pub type SparkMaxPIDController_AccelStrategy = ::std::os::raw::c_int;
        pub const SparkMaxPIDController_ArbFFUnits_kVoltage:
            root::rev::SparkMaxPIDController_ArbFFUnits = 0;
        pub const SparkMaxPIDController_ArbFFUnits_kPercentOut:
            root::rev::SparkMaxPIDController_ArbFFUnits = 1;
        #[doc = " Units for arbitrary feed-forward"]
        pub type SparkMaxPIDController_ArbFFUnits = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxPIDController() {
            const UNINIT: ::std::mem::MaybeUninit<SparkMaxPIDController> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SparkMaxPIDController>(),
                16usize,
                concat!("Size of: ", stringify!(SparkMaxPIDController))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxPIDController>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxPIDController))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxPIDController),
                    "::",
                    stringify!(m_device)
                )
            );
        }
        extern "C" {
            #[doc = " Set the controller reference value based on the selected control mode.\n\n @param value The value to set depending on the control mode. For basic\n duty cycle control this should be a value between -1 and 1\n Otherwise: Voltage Control: Voltage (volts) Velocity Control: Velocity\n (RPM) Position Control: Position (Rotations) Current Control: Current\n (Amps). The units can be changed for position and velocity by a scale\n factor using setPositionConversionFactor().\n\n @param ctrl Is the control type\n\n @param pidSlot for this command\n\n @param arbFeedforward A value from -32.0 to 32.0 which is a voltage\n applied to the motor after the result of the specified control mode. The\n units for the parameter is Volts. This value is set after the control\n mode, but before any current limits or ramp rates.\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController12SetReferenceEdNS_19CANSparkMaxLowLevel11ControlTypeEidNS0_10ArbFFUnitsE"]
            pub fn SparkMaxPIDController_SetReference(
                this: *mut root::rev::SparkMaxPIDController,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: root::rev::SparkMaxPIDController_ArbFFUnits,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " NOTE: As of the 2022 FRC season, the firmware only supports the\n trapezoidal motion profiling acceleration strategy.\n\n Configure the acceleration strategy used to control acceleration on the\n motor.\n\n @param accelStrategy The acceleration strategy to use for the\n automatically generated motion profile\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController27SetSmartMotionAccelStrategyENS0_13AccelStrategyEi"]
            pub fn SparkMaxPIDController_SetSmartMotionAccelStrategy(
                this: *mut root::rev::SparkMaxPIDController,
                accelStrategy: root::rev::SparkMaxPIDController_AccelStrategy,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the acceleration strategy used to control acceleration on the motor.\n The current strategy is trapezoidal motion profiling.\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return The acceleration strategy to use for the automatically generated\n motion profile"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController27GetSmartMotionAccelStrategyEi"]
            pub fn SparkMaxPIDController_GetSmartMotionAccelStrategy(
                this: *const root::rev::SparkMaxPIDController,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxPIDController_AccelStrategy;
        }
        impl SparkMaxPIDController {
            #[inline]
            pub unsafe fn SetReference(
                &mut self,
                value: f64,
                ctrl: root::rev::CANSparkMaxLowLevel_ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: root::rev::SparkMaxPIDController_ArbFFUnits,
            ) -> root::rev::REVLibError {
                SparkMaxPIDController_SetReference(
                    self,
                    value,
                    ctrl,
                    pidSlot,
                    arbFeedforward,
                    arbFFUnits,
                )
            }
            #[inline]
            pub unsafe fn SetSmartMotionAccelStrategy(
                &mut self,
                accelStrategy: root::rev::SparkMaxPIDController_AccelStrategy,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                SparkMaxPIDController_SetSmartMotionAccelStrategy(self, accelStrategy, slotID)
            }
            #[inline]
            pub unsafe fn GetSmartMotionAccelStrategy(
                &self,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxPIDController_AccelStrategy {
                SparkMaxPIDController_GetSmartMotionAccelStrategy(self, slotID)
            }
        }
        extern "C" {
            #[doc = " Set the controller reference value based on the selected control mode.\n\n @param value The value to set depending on the control mode. For basic\n duty cycle control this should be a value between -1 and 1\n Otherwise: Voltage Control: Voltage (volts) Velocity Control: Velocity\n (RPM) Position Control: Position (Rotations) Current Control: Current\n (Amps). The units can be changed for position and velocity by a scale\n factor using setPositionConversionFactor().\n\n @param ctrl Is the control type\n\n @param pidSlot for this command\n\n @param arbFeedforward A value from -32.0 to 32.0 which is a voltage\n applied to the motor after the result of the specified control mode. The\n units for the parameter is Volts. This value is set after the control\n mode, but before any current limits or ramp rates.\n\n @return REVLibError::kOk if successful\n\n @deprecated Use SparkMaxPIDController::SetReference(double,\n CANSparkMax::ControlType, int, double, SparkMaxPIDController::ArbFFUnits)\n instead\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController12SetReferenceEdNS_11ControlTypeEidNS_16CANPIDController10ArbFFUnitsE"]
            pub fn SparkMaxPIDController_SetReference1(
                this: *mut ::std::os::raw::c_void,
                value: f64,
                ctrl: root::rev::ControlType,
                pidSlot: ::std::os::raw::c_int,
                arbFeedforward: f64,
                arbFFUnits: root::rev::CANPIDController_ArbFFUnits,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Proportional Gain constant of the PIDF controller on the SPARK\n MAX. This uses the Set Parameter API and should be used infrequently. The\n parameter does not presist unless burnFlash() is called.  The recommended\n method to configure this parameter is use to SPARK MAX GUI to tune and\n save parameters.\n\n @param gain The proportional gain value, must be positive\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController4SetPEdi"]
            pub fn SparkMaxPIDController_SetP(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Integral Gain constant of the PIDF controller on the SPARK MAX.\n This uses the Set Parameter API and should be used infrequently. The\n parameter does not presist unless burnFlash() is called.  The recommended\n method to configure this parameter is use to SPARK MAX GUI to tune and\n save parameters.\n\n @param gain The integral gain value, must be positive\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController4SetIEdi"]
            pub fn SparkMaxPIDController_SetI(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Derivative Gain constant of the PIDF controller on the SPARK MAX.\n This uses the Set Parameter API and should be used infrequently. The\n parameter does not presist unless burnFlash() is called.  The recommended\n method to configure this parameter is use to SPARK MAX GUI to tune and\n save parameters.\n\n @param gain The derivative gain value, must be positive\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController4SetDEdi"]
            pub fn SparkMaxPIDController_SetD(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Derivative Filter constant of the PIDF controller on the SPARK\n MAX. This uses the Set Parameter API and should be used infrequently. The\n parameter does not presist unless burnFlash() is called.\n\n @param gain The derivative filter value, must be a positive number\n between 0 and 1\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController10SetDFilterEdi"]
            pub fn SparkMaxPIDController_SetDFilter(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the Feed-froward Gain constant of the PIDF controller on the SPARK\n MAX. This uses the Set Parameter API and should be used infrequently. The\n parameter does not presist unless burnFlash() is called.  The recommended\n method to configure this parameter is use to SPARK MAX GUI to tune and\n save parameters.\n\n @param gain The feed-forward gain value\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController5SetFFEdi"]
            pub fn SparkMaxPIDController_SetFF(
                this: *mut ::std::os::raw::c_void,
                gain: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the IZone range of the PIDF controller on the SPARK MAX. This value\n specifies the range the |error| must be within for the integral constant\n to take effect.\n\n This uses the Set Parameter API and should be used infrequently.\n The parameter does not presist unless burnFlash() is called.\n The recommended method to configure this parameter is to use the\n SPARK MAX GUI to tune and save parameters.\n\n @param gain The IZone value, must be positive. Set to 0 to disable\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController8SetIZoneEdi"]
            pub fn SparkMaxPIDController_SetIZone(
                this: *mut ::std::os::raw::c_void,
                IZone: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the min amd max output for the closed loop mode.\n\n This uses the Set Parameter API and should be used infrequently.\n The parameter does not presist unless burnFlash() is called.\n The recommended method to configure this parameter is to use the\n SPARK MAX GUI to tune and save parameters.\n\n @param min Reverse power minimum to allow the controller to output\n\n @param max Forward power maximum to allow the controller to output\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController14SetOutputRangeEddi"]
            pub fn SparkMaxPIDController_SetOutputRange(
                this: *mut ::std::os::raw::c_void,
                min: f64,
                max: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the Proportional Gain constant of the PIDF controller on the SPARK\n MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double P Gain value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController4GetPEi"]
            pub fn SparkMaxPIDController_GetP(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Integral Gain constant of the PIDF controller on the SPARK MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double I Gain value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController4GetIEi"]
            pub fn SparkMaxPIDController_GetI(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Derivative Gain constant of the PIDF controller on the SPARK MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double D Gain value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController4GetDEi"]
            pub fn SparkMaxPIDController_GetD(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Derivative Filter constant of the PIDF controller on the SPARK\n MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double D Filter value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController10GetDFilterEi"]
            pub fn SparkMaxPIDController_GetDFilter(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the Feed-forward Gain constant of the PIDF controller on the SPARK\n MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double F Gain value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController5GetFFEi"]
            pub fn SparkMaxPIDController_GetFF(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the IZone constant of the PIDF controller on the SPARK MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double IZone value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController8GetIZoneEi"]
            pub fn SparkMaxPIDController_GetIZone(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the min output of the PIDF controller on the SPARK MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double min value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController12GetOutputMinEi"]
            pub fn SparkMaxPIDController_GetOutputMin(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the max output of the PIDF controller on the SPARK MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return double max value\n"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController12GetOutputMaxEi"]
            pub fn SparkMaxPIDController_GetOutputMax(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Configure the maximum velocity of the SmartMotion mode. This is the\n velocity that is reached in the middle of the profile and is what the\n motor should spend most of its time at\n\n @param maxVel The maxmimum cruise velocity for the motion profile in RPM\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController25SetSmartMotionMaxVelocityEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionMaxVelocity(
                this: *mut ::std::os::raw::c_void,
                maxVel: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Configure the maximum acceleration of the SmartMotion mode. This is the\n accleration that the motor velocity will increase at until the max\n velocity is reached\n\n @param maxAccel The maxmimum acceleration for the motion profile in RPM\n per second\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController22SetSmartMotionMaxAccelEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionMaxAccel(
                this: *mut ::std::os::raw::c_void,
                maxAccel: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Configure the mimimum velocity of the SmartMotion mode. Any requested\n velocities below this value will be set to 0.\n\n @param minVel The minimum velocity for the motion profile in RPM\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController31SetSmartMotionMinOutputVelocityEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionMinOutputVelocity(
                this: *mut ::std::os::raw::c_void,
                minVel: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Configure the allowed closed loop error of SmartMotion mode. This value\n is how much deviation from your setpoint is tolerated and is useful in\n preventing oscillation around your setpoint.\n\n @param allowedErr The allowed deviation for your setpoint vs actual\n position in rotations\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController36SetSmartMotionAllowedClosedLoopErrorEdi"]
            pub fn SparkMaxPIDController_SetSmartMotionAllowedClosedLoopError(
                this: *mut ::std::os::raw::c_void,
                allowedErr: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " NOTE: As of the 2022 FRC season, the firmware only supports the\n trapezoidal motion profiling acceleration strategy.\n\n Configure the acceleration strategy used to control acceleration on the\n motor.\n\n @param accelStrategy The acceleration strategy to use for the\n automatically generated motion profile\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful\n\n @deprecated Use\n SetSmartMotionAccelStrategy(SparkMaxPIDController::AccelStrategy, int)\n instead"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController27SetSmartMotionAccelStrategyENS_16CANPIDController13AccelStrategyEi"]
            pub fn SparkMaxPIDController_SetSmartMotionAccelStrategy1(
                this: *mut ::std::os::raw::c_void,
                accelStrategy: root::rev::CANPIDController_AccelStrategy,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the maximum velocity of the SmartMotion mode. This is the velocity\n that is reached in the middle of the profile and is what the motor should\n spend most of its time at\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return The maxmimum cruise velocity for the motion profile in RPM"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController25GetSmartMotionMaxVelocityEi"]
            pub fn SparkMaxPIDController_GetSmartMotionMaxVelocity(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the maximum acceleration of the SmartMotion mode. This is the\n accleration that the motor velocity will increase at until the max\n velocity is reached\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return The maxmimum acceleration for the motion profile in RPM per\n second"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController22GetSmartMotionMaxAccelEi"]
            pub fn SparkMaxPIDController_GetSmartMotionMaxAccel(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the mimimum velocity of the SmartMotion mode. Any requested\n velocities below this value will be set to 0.\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return The minimum velocity for the motion profile in RPM"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController31GetSmartMotionMinOutputVelocityEi"]
            pub fn SparkMaxPIDController_GetSmartMotionMinOutputVelocity(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the allowed closed loop error of SmartMotion mode. This value is how\n much deviation from your setpoint is tolerated and is useful in\n preventing oscillation around your setpoint.\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return The allowed deviation for your setpoint vs actual position in\n rotations"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController36GetSmartMotionAllowedClosedLoopErrorEi"]
            pub fn SparkMaxPIDController_GetSmartMotionAllowedClosedLoopError(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Configure the maximum I accumulator of the PID controller. This value is\n used to constrain the I accumulator to help manage integral wind-up\n\n @param iMaxAccum The max value to contrain the I accumulator to\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController12SetIMaxAccumEdi"]
            pub fn SparkMaxPIDController_SetIMaxAccum(
                this: *mut ::std::os::raw::c_void,
                iMaxAccum: f64,
                slotID: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the maximum I accumulator of the PID controller. This value is used\n to constrain the I accumulator to help manage integral wind-up\n\n @param slotID Is the gain schedule slot, the value is a number\n between 0 and 3. Each slot has its own set of gain values and\n can be changed in each control frame using SetReference().\n\n @return The max value to contrain the I accumulator to"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController12GetIMaxAccumEi"]
            pub fn SparkMaxPIDController_GetIMaxAccum(
                this: *mut ::std::os::raw::c_void,
                slotID: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the I accumulator of the PID controller. This is useful when wishing\n to force a reset on the I accumulator of the PID controller. You can also\n preset values to see how it will respond to certain I characteristics\n\n To use this function, the controller must be in a closed loop control\n mode by calling setReference()\n\n @param iAccum The value to set the I accumulator to\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController9SetIAccumEd"]
            pub fn SparkMaxPIDController_SetIAccum(
                this: *mut ::std::os::raw::c_void,
                iAccum: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the I accumulator of the PID controller. This is useful when wishing\n to see what the I accumulator value is to help with PID tuning\n\n @return The value of the I accumulator"]
            #[link_name = "\u{1}_ZNK3rev21SparkMaxPIDController9GetIAccumEv"]
            pub fn SparkMaxPIDController_GetIAccum(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the controller's feedback device.\n\n The default feedback device is assumed to be the integrated encoder.\n This is used to changed to another feedback device for the controller,\n such as an analog sensor.\n\n If there is a limited range on the feedback sensor that should be\n observed by the PIDController, it can be set by calling\n SetFeedbackSensorRange() on the sensor object.\n\n @param sensor The sensor to be used as a feedback device\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev21SparkMaxPIDController17SetFeedbackDeviceERKNS_9CANSensorE"]
            pub fn SparkMaxPIDController_SetFeedbackDevice(
                this: *mut ::std::os::raw::c_void,
                sensor: *const root::rev::CANSensor,
            ) -> root::rev::REVLibError;
        }
        #[doc = " Get an instance of this class by using CANSparkMax::GetEncoder() or\n CANSparkMax::GetEncoder(SparkMaxRelativeEncoder::Type, int)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SparkMaxRelativeEncoder {
            pub _base: root::rev::RelativeEncoder,
            pub m_device: *mut root::rev::CANSparkMax,
            pub m_countsPerRev: ::std::os::raw::c_int,
        }
        pub const SparkMaxRelativeEncoder_Type_kNoSensor: root::rev::SparkMaxRelativeEncoder_Type =
            0;
        pub const SparkMaxRelativeEncoder_Type_kHallSensor:
            root::rev::SparkMaxRelativeEncoder_Type = 1;
        pub const SparkMaxRelativeEncoder_Type_kQuadrature:
            root::rev::SparkMaxRelativeEncoder_Type = 2;
        #[doc = " The type of encoder connected to a SPARK MAX"]
        pub type SparkMaxRelativeEncoder_Type = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_SparkMaxRelativeEncoder() {
            const UNINIT: ::std::mem::MaybeUninit<SparkMaxRelativeEncoder> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SparkMaxRelativeEncoder>(),
                24usize,
                concat!("Size of: ", stringify!(SparkMaxRelativeEncoder))
            );
            assert_eq!(
                ::std::mem::align_of::<SparkMaxRelativeEncoder>(),
                8usize,
                concat!("Alignment of ", stringify!(SparkMaxRelativeEncoder))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_device) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxRelativeEncoder),
                    "::",
                    stringify!(m_device)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_countsPerRev) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SparkMaxRelativeEncoder),
                    "::",
                    stringify!(m_countsPerRev)
                )
            );
        }
        extern "C" {
            #[doc = " Get the position of the motor. This returns the native units\n of 'rotations' by default, and can be changed by a scale factor\n using setPositionConversionFactor().\n\n @return Number of rotations of the motor\n"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder11GetPositionEv"]
            pub fn SparkMaxRelativeEncoder_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Get the velocity of the motor. This returns the native units\n of 'RPM' by default, and can be changed by a scale factor\n using setVelocityConversionFactor().\n\n @return Number the RPM of the motor\n"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder11GetVelocityEv"]
            pub fn SparkMaxRelativeEncoder_GetVelocity(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Set the position of the encoder.\n\n @param position Number of rotations of the motor\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder11SetPositionEd"]
            pub fn SparkMaxRelativeEncoder_SetPosition(
                this: *mut ::std::os::raw::c_void,
                position: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for position of the encoder. Multiplied by the\n native output units to give you position\n\n @param factor The conversion factor to multiply the native units by\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder27SetPositionConversionFactorEd"]
            pub fn SparkMaxRelativeEncoder_SetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the conversion factor for velocity of the encoder. Multiplied by the\n native output units to give you velocity\n\n @param factor The conversion factor to multiply the native units by\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder27SetVelocityConversionFactorEd"]
            pub fn SparkMaxRelativeEncoder_SetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
                factor: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the conversion factor for position of the encoder. Multiplied by the\n native output units to give you position\n\n @return The conversion factor for position"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder27GetPositionConversionFactorEv"]
            pub fn SparkMaxRelativeEncoder_GetPositionConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the conversion factor for velocity of the encoder. Multiplied by the\n native output units to give you velocity\n\n @return The conversion factor for velocity"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder27GetVelocityConversionFactorEv"]
            pub fn SparkMaxRelativeEncoder_GetVelocityConversionFactor(
                this: *mut ::std::os::raw::c_void,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Set the average sampling depth for a quadrature encoder. This value\n sets the number of samples in the average for velocity readings. This\n can be any value from 1 to 64.\n\n When the SparkMax controller is in Brushless mode, this\n will not change any behavior.\n\n @param depth The average sampling depth between 1 and 64 (default)\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder15SetAverageDepthEj"]
            pub fn SparkMaxRelativeEncoder_SetAverageDepth(
                this: *mut ::std::os::raw::c_void,
                depth: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Set the measurement period for velocity measurements of a quadrature\n encoder. When the SparkMax controller is in Brushless mode, this will not\n change any behavior.\n\n The basic formula to calculate velocity is change in positon / change in\n time. This parameter sets the change in time for measurement.\n\n @param period_us Measurement period in milliseconds. This number may be\n between 1 and 100 (default).\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder20SetMeasurementPeriodEj"]
            pub fn SparkMaxRelativeEncoder_SetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
                period_ms: u32,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the average sampling depth for a quadrature encoder.\n\n @return The average sampling depth"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder15GetAverageDepthEv"]
            pub fn SparkMaxRelativeEncoder_GetAverageDepth(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the number of samples for reading from a quadrature encoder. This\n value sets the number of samples in the average for velocity readings.\n\n @return Measurement period in microseconds"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder20GetMeasurementPeriodEv"]
            pub fn SparkMaxRelativeEncoder_GetMeasurementPeriod(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Get the counts per revolution of the quadrature encoder.\n\n For a description on the difference between CPR, PPR, etc. go to\n https://www.cuidevices.com/blog/what-is-encoder-ppr-cpr-and-lpr\n\n @return Counts per revolution"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder22GetCountsPerRevolutionEv"]
            pub fn SparkMaxRelativeEncoder_GetCountsPerRevolution(
                this: *mut ::std::os::raw::c_void,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Set the phase of the MotorFeedbackSensor so that it is set to be in\n phase with the motor itself. This only works for quadrature\n encoders. This will throw an error if the user tries to set\n inverted while the SparkMax is Brushless and using the hall\n effect sensor.\n\n @param inverted The phase of the encoder\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev23SparkMaxRelativeEncoder11SetInvertedEb"]
            pub fn SparkMaxRelativeEncoder_SetInverted(
                this: *mut ::std::os::raw::c_void,
                inverted: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the phase of the MotorFeedbackSensor. This will just return false\n if the user tries to get inverted while the SparkMax is\n Brushless and using the hall effect sensor.\n\n @return The phase of the encoder"]
            #[link_name = "\u{1}_ZNK3rev23SparkMaxRelativeEncoder11GetInvertedEv"]
            pub fn SparkMaxRelativeEncoder_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CANSparkMax {
            pub _base: root::rev::CANSparkMaxLowLevel,
            pub m_setpoint: f64,
            pub m_relativeEncoderCreated: root::std::atomic<bool>,
            pub m_alternateEncoderCreated: root::std::atomic<bool>,
            pub m_analogSensorCreated: root::std::atomic<bool>,
            pub m_pidControllerCreated: root::std::atomic<bool>,
            pub m_forwardLimitSwitchCreated: root::std::atomic<bool>,
            pub m_reverseLimitSwitchCreated: root::std::atomic<bool>,
        }
        pub const CANSparkMax_IdleMode_kCoast: root::rev::CANSparkMax_IdleMode = 0;
        pub const CANSparkMax_IdleMode_kBrake: root::rev::CANSparkMax_IdleMode = 1;
        pub type CANSparkMax_IdleMode = ::std::os::raw::c_int;
        pub const CANSparkMax_InputMode_kPWM: root::rev::CANSparkMax_InputMode = 0;
        pub const CANSparkMax_InputMode_kCAN: root::rev::CANSparkMax_InputMode = 1;
        #[doc = " @deprecated You don't need this"]
        pub type CANSparkMax_InputMode = ::std::os::raw::c_int;
        pub const CANSparkMax_SoftLimitDirection_kForward:
            root::rev::CANSparkMax_SoftLimitDirection = 0;
        pub const CANSparkMax_SoftLimitDirection_kReverse:
            root::rev::CANSparkMax_SoftLimitDirection = 1;
        pub type CANSparkMax_SoftLimitDirection = ::std::os::raw::c_int;
        pub const CANSparkMax_FaultID_kBrownout: root::rev::CANSparkMax_FaultID = 0;
        pub const CANSparkMax_FaultID_kOvercurrent: root::rev::CANSparkMax_FaultID = 1;
        pub const CANSparkMax_FaultID_kIWDTReset: root::rev::CANSparkMax_FaultID = 2;
        pub const CANSparkMax_FaultID_kMotorFault: root::rev::CANSparkMax_FaultID = 3;
        pub const CANSparkMax_FaultID_kSensorFault: root::rev::CANSparkMax_FaultID = 4;
        pub const CANSparkMax_FaultID_kStall: root::rev::CANSparkMax_FaultID = 5;
        pub const CANSparkMax_FaultID_kEEPROMCRC: root::rev::CANSparkMax_FaultID = 6;
        pub const CANSparkMax_FaultID_kCANTX: root::rev::CANSparkMax_FaultID = 7;
        pub const CANSparkMax_FaultID_kCANRX: root::rev::CANSparkMax_FaultID = 8;
        pub const CANSparkMax_FaultID_kHasReset: root::rev::CANSparkMax_FaultID = 9;
        pub const CANSparkMax_FaultID_kDRVFault: root::rev::CANSparkMax_FaultID = 10;
        pub const CANSparkMax_FaultID_kOtherFault: root::rev::CANSparkMax_FaultID = 11;
        pub const CANSparkMax_FaultID_kSoftLimitFwd: root::rev::CANSparkMax_FaultID = 12;
        pub const CANSparkMax_FaultID_kSoftLimitRev: root::rev::CANSparkMax_FaultID = 13;
        pub const CANSparkMax_FaultID_kHardLimitFwd: root::rev::CANSparkMax_FaultID = 14;
        pub const CANSparkMax_FaultID_kHardLimitRev: root::rev::CANSparkMax_FaultID = 15;
        pub type CANSparkMax_FaultID = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CANSparkMax_ExternalFollower {
            pub arbId: ::std::os::raw::c_int,
            pub configId: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_CANSparkMax_ExternalFollower() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMax_ExternalFollower> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMax_ExternalFollower>(),
                8usize,
                concat!("Size of: ", stringify!(CANSparkMax_ExternalFollower))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMax_ExternalFollower>(),
                4usize,
                concat!("Alignment of ", stringify!(CANSparkMax_ExternalFollower))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).arbId) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax_ExternalFollower),
                    "::",
                    stringify!(arbId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).configId) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax_ExternalFollower),
                    "::",
                    stringify!(configId)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev11CANSparkMax17kFollowerDisabledE"]
            pub static CANSparkMax_kFollowerDisabled: root::rev::CANSparkMax_ExternalFollower;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev11CANSparkMax17kFollowerSparkMaxE"]
            pub static CANSparkMax_kFollowerSparkMax: root::rev::CANSparkMax_ExternalFollower;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16kFollowerPhoenixE"]
            pub static CANSparkMax_kFollowerPhoenix: root::rev::CANSparkMax_ExternalFollower;
        }
        #[test]
        fn bindgen_test_layout_CANSparkMax() {
            const UNINIT: ::std::mem::MaybeUninit<CANSparkMax> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CANSparkMax>(),
                48usize,
                concat!("Size of: ", stringify!(CANSparkMax))
            );
            assert_eq!(
                ::std::mem::align_of::<CANSparkMax>(),
                8usize,
                concat!("Alignment of ", stringify!(CANSparkMax))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_setpoint) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_setpoint)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_relativeEncoderCreated) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_relativeEncoderCreated)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_alternateEncoderCreated) as usize - ptr as usize
                },
                41usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_alternateEncoderCreated)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_analogSensorCreated) as usize - ptr as usize
                },
                42usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_analogSensorCreated)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pidControllerCreated) as usize - ptr as usize
                },
                43usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_pidControllerCreated)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_forwardLimitSwitchCreated) as usize - ptr as usize
                },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_forwardLimitSwitchCreated)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_reverseLimitSwitchCreated) as usize - ptr as usize
                },
                45usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CANSparkMax),
                    "::",
                    stringify!(m_reverseLimitSwitchCreated)
                )
            );
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the encoder connected to the\n encoder pins or front port of the SPARK MAX.\n\n The default encoder type is assumed to be the hall effect for brushless.\n This can be modified for brushed DC to use an quadrature encoder."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10GetEncoderENS_23SparkMaxRelativeEncoder4TypeEi"]
            pub fn CANSparkMax_GetEncoder(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::SparkMaxRelativeEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the encoder connected to the\n encoder pins or front port of the SPARK MAX.\n\n The default encoder type is assumed to be the hall effect for brushless.\n This can be modified for brushed DC to use an quadrature encoder.\n\n @deprecated Use CANSparkMax::GetEncoder(SparkMaxRelativeEncoder::Type,\n int) instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10GetEncoderENS_10CANEncoder11EncoderTypeEi"]
            pub fn CANSparkMax_GetEncoder1(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::CANEncoder_EncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a quadrature encoder connected to\n the alternate encoder mode data port pins. These are defined as:\n\n Pin 4 (Forward Limit Switch): Index\n Pin 6 (Multi-function): Encoder A\n Pin 8 (Reverse Limit Switch): Encoder B\n\n This call will disable support for the limit switch inputs."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetAlternateEncoderEi"]
            pub fn CANSparkMax_GetAlternateEncoder(
                this: *mut root::rev::CANSparkMax,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a quadrature encoder connected to\n the alternate encoder mode data port pins. These are defined as:\n\n Pin 4 (Forward Limit Switch): Index\n Pin 6 (Multi-function): Encoder A\n Pin 8 (Reverse Limit Switch): Encoder B\n\n This call will disable support for the limit switch inputs."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetAlternateEncoderENS_24SparkMaxAlternateEncoder4TypeEi"]
            pub fn CANSparkMax_GetAlternateEncoder1(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::SparkMaxAlternateEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a quadrature encoder connected to\n the alternate encoder mode data port pins. These are defined as:\n\n Pin 4 (Forward Limit Switch): Index\n Pin 6 (Multi-function): Encoder A\n Pin 8 (Reverse Limit Switch): Encoder B\n\n This call will disable support for the limit switch inputs.\n\n @deprecated Use\n CANSparkMax::GetAlternateEncoder(SparkMaxAlternateEncoder::Type, int)\n instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetAlternateEncoderENS_10CANEncoder20AlternateEncoderTypeEi"]
            pub fn CANSparkMax_GetAlternateEncoder2(
                this: *mut root::rev::CANSparkMax,
                encoderType: root::rev::CANEncoder_AlternateEncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a connected analog sensor.\n By default, the mode is set to kAbsolute, thus treating the\n sensor as an absolute sensor."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9GetAnalogENS_20SparkMaxAnalogSensor4ModeE"]
            pub fn CANSparkMax_GetAnalog(
                this: *mut root::rev::CANSparkMax,
                mode: root::rev::SparkMaxAnalogSensor_Mode,
            ) -> root::rev::SparkMaxAnalogSensor;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with a connected analog sensor.\n\n @deprecated Use GetAnalog(SparkMaxAnalogSensor::Mode) instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9GetAnalogENS_9CANAnalog10AnalogModeE"]
            pub fn CANSparkMax_GetAnalog1(
                this: *mut root::rev::CANSparkMax,
                mode: root::rev::CANAnalog_AnalogMode,
            ) -> root::rev::SparkMaxAnalogSensor;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the integrated PID controller."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16GetPIDControllerEv"]
            pub fn CANSparkMax_GetPIDController(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::SparkMaxPIDController;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the forward limit switch connected\n to the appropriate pins on the data port.\n\n This call will disable support for the alternate encoder.\n\n @param switchType Whether the limit switch is normally open or normally\n closed."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetForwardLimitSwitchENS_19SparkMaxLimitSwitch4TypeE"]
            pub fn CANSparkMax_GetForwardLimitSwitch(
                this: *mut root::rev::CANSparkMax,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the forward limit switch connected\n to the appropriate pins on the data port.\n\n This call will disable support for the alternate encoder.\n\n @param polarity Whether the limit switch is normally open or normally\n closed.\n\n @deprecated Use\n GetForwardLimitSwitch(SparkMaxLimitSwitch::Type)\n instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetForwardLimitSwitchENS_15CANDigitalInput19LimitSwitchPolarityE"]
            pub fn CANSparkMax_GetForwardLimitSwitch1(
                this: *mut root::rev::CANSparkMax,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the reverse limit switch connected\n to the appropriate pins on the data port.\n\n This call will disable support for the alternate encoder.\n\n @param switchType Whether the limit switch is normally open or normally\n closed."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetReverseLimitSwitchENS_19SparkMaxLimitSwitch4TypeE"]
            pub fn CANSparkMax_GetReverseLimitSwitch(
                this: *mut root::rev::CANSparkMax,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Returns an object for interfacing with the reverse limit switch connected\n to the appropriate pins on the data port.\n\n This call will disable support for the alternate encoder.\n\n @param polarity Whether the limit switch is normally open or normally\n closed.\n\n @deprecated Use\n GetReverseLimitSwitch(SparkMaxLimitSwitch::Type)\n instead"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetReverseLimitSwitchENS_15CANDigitalInput19LimitSwitchPolarityE"]
            pub fn CANSparkMax_GetReverseLimitSwitch1(
                this: *mut root::rev::CANSparkMax,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch;
        }
        extern "C" {
            #[doc = " Sets the current limit in Amps.\n\n The motor controller will reduce the controller voltage output to avoid\n surpassing this limit. This limit is enabled by default and used for\n brushless only. This limit is highly recommended when using the NEO\n brushless motor.\n\n The NEO Brushless Motor has a low internal resistance, which\n can mean large current spikes that could be enough to cause damage to\n the motor and controller. This current limit provides a smarter\n strategy to deal with high current draws and keep the motor and\n controller operating in a safe region.\n\n\n @param limit      The current limit in Amps."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax20SetSmartCurrentLimitEj"]
            pub fn CANSparkMax_SetSmartCurrentLimit(
                this: *mut root::rev::CANSparkMax,
                limit: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the current limit in Amps.\n\n The motor controller will reduce the controller voltage output to avoid\n surpassing this limit. This limit is enabled by default and used for\n brushless only. This limit is highly recommended when using the NEO\n brushless motor.\n\n The NEO Brushless Motor has a low internal resistance, which\n can mean large current spikes that could be enough to cause damage to\n the motor and controller. This current limit provides a smarter\n strategy to deal with high current draws and keep the motor and\n controller operating in a safe region.\n\n The controller can also limit the current based on the RPM of the motor\n in a linear fashion to help with controllability in closed loop control.\n For a response that is linear the entire RPM range leave limit RPM at 0.\n\n\n @param stallLimit The current limit in Amps at 0 RPM.\n @param freeLimit The current limit at free speed (5700RPM for NEO).\n @param limitRPM RPM less than this value will be set to the stallLimit,\n RPM values greater than limitRPM will scale linearly to freeLimit"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax20SetSmartCurrentLimitEjjj"]
            pub fn CANSparkMax_SetSmartCurrentLimit1(
                this: *mut root::rev::CANSparkMax,
                stallLimit: ::std::os::raw::c_uint,
                freeLimit: ::std::os::raw::c_uint,
                limitRPM: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the secondary current limit in Amps.\n\n The motor controller will disable the output of the controller briefly\n if the current limit is exceeded to reduce the current. This limit is\n a simplified 'on/off' controller. This limit is enabled by default\n but is set higher than the default Smart Current Limit.\n\n The time the controller is off after the current limit is reached\n is determined by the parameter limitCycles, which is the number of\n PWM cycles (20kHz). The recommended value is the default of 0 which\n is the minimum time and is part of a PWM cycle from when the over\n current is detected. This allows the controller to regulate the current\n close to the limit value.\n\n The total time is set by the equation\n\n @code t = (50us - t0) + 50us * limitCycles\n t = total off time after over current\n t0 = time from the start of the PWM cycle until over current is detected\n @endcode\n\n\n @param limit The current limit in Amps.\n @param limitCycles The number of additional PWM cycles to turn\n the driver off after overcurrent is detected."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax24SetSecondaryCurrentLimitEdi"]
            pub fn CANSparkMax_SetSecondaryCurrentLimit(
                this: *mut root::rev::CANSparkMax,
                limit: f64,
                limitCycles: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the idle mode setting for the SPARK MAX.\n\n @param mode Idle mode (coast or brake)."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11SetIdleModeENS0_8IdleModeE"]
            pub fn CANSparkMax_SetIdleMode(
                this: *mut root::rev::CANSparkMax,
                mode: root::rev::CANSparkMax_IdleMode,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Gets the idle mode setting for the SPARK MAX.\n\n This uses the Get Parameter API and should be used infrequently. This\n function uses a non-blocking call and will return a cached value if the\n parameter is not returned by the timeout. The timeout can be changed by\n calling SetCANTimeout(int milliseconds)\n\n @return IdleMode Idle mode setting"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11GetIdleModeEv"]
            pub fn CANSparkMax_GetIdleMode(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::CANSparkMax_IdleMode;
        }
        extern "C" {
            #[doc = " Sets the voltage compensation setting for all modes on the SPARK MAX and\n enables voltage compensation.\n\n @param nominalVoltage Nominal voltage to compensate output to\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax25EnableVoltageCompensationEd"]
            pub fn CANSparkMax_EnableVoltageCompensation(
                this: *mut root::rev::CANSparkMax,
                nominalVoltage: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Disables the voltage compensation setting for all modes on the SPARK MAX.\n\n @return REVLibError::kOk if successful"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax26DisableVoltageCompensationEv"]
            pub fn CANSparkMax_DisableVoltageCompensation(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the configured voltage compensation nominal voltage value\n\n @return The nominal voltage for voltage compensation mode."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax36GetVoltageCompensationNominalVoltageEv"]
            pub fn CANSparkMax_GetVoltageCompensationNominalVoltage(
                this: *mut root::rev::CANSparkMax,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Sets the ramp rate for open loop control modes.\n\n This is the maximum rate at which the motor controller's output\n is allowed to change.\n\n @param rate Time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19SetOpenLoopRampRateEd"]
            pub fn CANSparkMax_SetOpenLoopRampRate(
                this: *mut root::rev::CANSparkMax,
                rate: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets the ramp rate for closed loop control modes.\n\n This is the maximum rate at which the motor controller's output\n is allowed to change.\n\n @param rate Time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21SetClosedLoopRampRateEd"]
            pub fn CANSparkMax_SetClosedLoopRampRate(
                this: *mut root::rev::CANSparkMax,
                rate: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the configured open loop ramp rate\n\n This is the maximum rate at which the motor controller's output\n is allowed to change.\n\n @return rampte rate time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetOpenLoopRampRateEv"]
            pub fn CANSparkMax_GetOpenLoopRampRate(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Get the configured closed loop ramp rate\n\n This is the maximum rate at which the motor controller's output\n is allowed to change.\n\n @return rampte rate time in seconds to go from 0 to full throttle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax21GetClosedLoopRampRateEv"]
            pub fn CANSparkMax_GetClosedLoopRampRate(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Causes this controller's output to mirror the provided leader.\n\n Only voltage output is mirrored. Settings changed on the leader do not\n affect the follower.\n\n Following anything other than a CAN SPARK MAX is not officially\n supported.\n\n @param leader The motor controller to follow.\n\n @param invert Set the follower to output opposite of the leader"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax6FollowERKS0_b"]
            pub fn CANSparkMax_Follow(
                this: *mut root::rev::CANSparkMax,
                leader: *const root::rev::CANSparkMax,
                invert: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Causes this controller's output to mirror the provided leader.\n\n Only voltage output is mirrored. Settings changed on the leader do not\n affect the follower.\n\n Following anything other than a CAN SPARK MAX is not officially\n supported.\n\n @param leader   The type of motor controller to follow (Talon SRX, Spark\n                 Max, etc.).\n @param deviceID The CAN ID of the device to follow.\n\n @param invert Set the follower to output opposite of the leader"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax6FollowENS0_16ExternalFollowerEib"]
            pub fn CANSparkMax_Follow1(
                this: *mut root::rev::CANSparkMax,
                leader: root::rev::CANSparkMax_ExternalFollower,
                deviceID: ::std::os::raw::c_int,
                invert: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Returns whether the controller is following another controller\n\n @return True if this device is following another controller\n false otherwise"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10IsFollowerEv"]
            pub fn CANSparkMax_IsFollower(this: *mut root::rev::CANSparkMax) -> bool;
        }
        extern "C" {
            #[doc = " Returns fault bits."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9GetFaultsEv"]
            pub fn CANSparkMax_GetFaults(this: *mut root::rev::CANSparkMax) -> u16;
        }
        extern "C" {
            #[doc = " Returns sticky fault bits."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax15GetStickyFaultsEv"]
            pub fn CANSparkMax_GetStickyFaults(this: *mut root::rev::CANSparkMax) -> u16;
        }
        extern "C" {
            #[doc = " Returns whether the fault with the given ID occurred."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax8GetFaultENS0_7FaultIDE"]
            pub fn CANSparkMax_GetFault(
                this: *const root::rev::CANSparkMax,
                faultID: root::rev::CANSparkMax_FaultID,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns whether the sticky fault with the given ID occurred."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax14GetStickyFaultENS0_7FaultIDE"]
            pub fn CANSparkMax_GetStickyFault(
                this: *const root::rev::CANSparkMax,
                faultID: root::rev::CANSparkMax_FaultID,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns the voltage fed into the motor controller."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax13GetBusVoltageEv"]
            pub fn CANSparkMax_GetBusVoltage(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Returns motor controller's output duty cycle."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16GetAppliedOutputEv"]
            pub fn CANSparkMax_GetAppliedOutput(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Returns motor controller's output current in Amps."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax16GetOutputCurrentEv"]
            pub fn CANSparkMax_GetOutputCurrent(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Returns the motor temperature in Celsius."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax19GetMotorTemperatureEv"]
            pub fn CANSparkMax_GetMotorTemperature(this: *mut root::rev::CANSparkMax) -> f64;
        }
        extern "C" {
            #[doc = " Clears all non-sticky faults.\n\n Sticky faults must be cleared by resetting the motor controller."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11ClearFaultsEv"]
            pub fn CANSparkMax_ClearFaults(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Writes all settings to flash."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9BurnFlashEv"]
            pub fn CANSparkMax_BurnFlash(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Sets timeout for sending CAN messages. A timeout of 0 also means that\n error handling will be done automatically by registering calls and\n waiting for responses, rather than needing to call GetLastError().\n\n @param milliseconds The timeout in milliseconds."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax13SetCANTimeoutEi"]
            pub fn CANSparkMax_SetCANTimeout(
                this: *mut root::rev::CANSparkMax,
                milliseconds: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Enable soft limits\n\n @param direction the direction of motion to restrict\n\n @param enable set true to enable soft limits"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax15EnableSoftLimitENS0_18SoftLimitDirectionEb"]
            pub fn CANSparkMax_EnableSoftLimit(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                enable: bool,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Returns true if the soft limit is enabled."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax18IsSoftLimitEnabledENS0_18SoftLimitDirectionE"]
            pub fn CANSparkMax_IsSoftLimitEnabled(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Set the soft limit based on position. The default unit is\n rotations, but will match the unit scaling set by the user.\n\n Note that this value is not scaled internally so care must\n be taken to make sure these units match the desired conversion\n\n @param direction the direction of motion to restrict\n\n @param limit position soft limit of the controller"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax12SetSoftLimitENS0_18SoftLimitDirectionEd"]
            pub fn CANSparkMax_SetSoftLimit(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                limit: f64,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Get the soft limit setting in the controller\n\n @param direction the direction of motion to restrict\n\n @return position soft limit setting of the controller"]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax12GetSoftLimitENS0_18SoftLimitDirectionE"]
            pub fn CANSparkMax_GetSoftLimit(
                this: *mut root::rev::CANSparkMax,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> f64;
        }
        extern "C" {
            #[doc = " All device errors are tracked on a per thread basis for all\n devices in that thread. This is meant to be called\n immediately following another call that has the possibility\n of throwing an error to validate if an  error has occurred.\n\n @return the last error that was generated."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax12GetLastErrorEv"]
            pub fn CANSparkMax_GetLastError(
                this: *mut root::rev::CANSparkMax,
            ) -> root::rev::REVLibError;
        }
        extern "C" {
            #[doc = " Create a new object to control a SPARK MAX motor Controller\n\n @param deviceID The device ID.\n @param type     The motor type connected to the controller. Brushless\n                 motor wires must be connected to their matching colors,\n and the hall sensor must be plugged in. Brushed motors must be connected\n                 to the Red and Black terminals only."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMaxC1EiNS_19CANSparkMaxLowLevel9MotorTypeE"]
            pub fn CANSparkMax_CANSparkMax(
                this: *mut root::rev::CANSparkMax,
                deviceID: ::std::os::raw::c_int,
                type_: root::rev::CANSparkMaxLowLevel_MotorType,
            );
        }
        impl CANSparkMax {
            #[inline]
            pub unsafe fn GetEncoder(
                &mut self,
                encoderType: root::rev::SparkMaxRelativeEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder {
                CANSparkMax_GetEncoder(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetEncoder1(
                &mut self,
                encoderType: root::rev::CANEncoder_EncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxRelativeEncoder {
                CANSparkMax_GetEncoder1(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAlternateEncoder(
                &mut self,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder {
                CANSparkMax_GetAlternateEncoder(self, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAlternateEncoder1(
                &mut self,
                encoderType: root::rev::SparkMaxAlternateEncoder_Type,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder {
                CANSparkMax_GetAlternateEncoder1(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAlternateEncoder2(
                &mut self,
                encoderType: root::rev::CANEncoder_AlternateEncoderType,
                countsPerRev: ::std::os::raw::c_int,
            ) -> root::rev::SparkMaxAlternateEncoder {
                CANSparkMax_GetAlternateEncoder2(self, encoderType, countsPerRev)
            }
            #[inline]
            pub unsafe fn GetAnalog(
                &mut self,
                mode: root::rev::SparkMaxAnalogSensor_Mode,
            ) -> root::rev::SparkMaxAnalogSensor {
                CANSparkMax_GetAnalog(self, mode)
            }
            #[inline]
            pub unsafe fn GetAnalog1(
                &mut self,
                mode: root::rev::CANAnalog_AnalogMode,
            ) -> root::rev::SparkMaxAnalogSensor {
                CANSparkMax_GetAnalog1(self, mode)
            }
            #[inline]
            pub unsafe fn GetPIDController(&mut self) -> root::rev::SparkMaxPIDController {
                CANSparkMax_GetPIDController(self)
            }
            #[inline]
            pub unsafe fn GetForwardLimitSwitch(
                &mut self,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetForwardLimitSwitch(self, switchType)
            }
            #[inline]
            pub unsafe fn GetForwardLimitSwitch1(
                &mut self,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetForwardLimitSwitch1(self, polarity)
            }
            #[inline]
            pub unsafe fn GetReverseLimitSwitch(
                &mut self,
                switchType: root::rev::SparkMaxLimitSwitch_Type,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetReverseLimitSwitch(self, switchType)
            }
            #[inline]
            pub unsafe fn GetReverseLimitSwitch1(
                &mut self,
                polarity: root::rev::CANDigitalInput_LimitSwitchPolarity,
            ) -> root::rev::SparkMaxLimitSwitch {
                CANSparkMax_GetReverseLimitSwitch1(self, polarity)
            }
            #[inline]
            pub unsafe fn SetSmartCurrentLimit(
                &mut self,
                limit: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSmartCurrentLimit(self, limit)
            }
            #[inline]
            pub unsafe fn SetSmartCurrentLimit1(
                &mut self,
                stallLimit: ::std::os::raw::c_uint,
                freeLimit: ::std::os::raw::c_uint,
                limitRPM: ::std::os::raw::c_uint,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSmartCurrentLimit1(self, stallLimit, freeLimit, limitRPM)
            }
            #[inline]
            pub unsafe fn SetSecondaryCurrentLimit(
                &mut self,
                limit: f64,
                limitCycles: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSecondaryCurrentLimit(self, limit, limitCycles)
            }
            #[inline]
            pub unsafe fn SetIdleMode(
                &mut self,
                mode: root::rev::CANSparkMax_IdleMode,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetIdleMode(self, mode)
            }
            #[inline]
            pub unsafe fn GetIdleMode(&mut self) -> root::rev::CANSparkMax_IdleMode {
                CANSparkMax_GetIdleMode(self)
            }
            #[inline]
            pub unsafe fn EnableVoltageCompensation(
                &mut self,
                nominalVoltage: f64,
            ) -> root::rev::REVLibError {
                CANSparkMax_EnableVoltageCompensation(self, nominalVoltage)
            }
            #[inline]
            pub unsafe fn DisableVoltageCompensation(&mut self) -> root::rev::REVLibError {
                CANSparkMax_DisableVoltageCompensation(self)
            }
            #[inline]
            pub unsafe fn GetVoltageCompensationNominalVoltage(&mut self) -> f64 {
                CANSparkMax_GetVoltageCompensationNominalVoltage(self)
            }
            #[inline]
            pub unsafe fn SetOpenLoopRampRate(&mut self, rate: f64) -> root::rev::REVLibError {
                CANSparkMax_SetOpenLoopRampRate(self, rate)
            }
            #[inline]
            pub unsafe fn SetClosedLoopRampRate(&mut self, rate: f64) -> root::rev::REVLibError {
                CANSparkMax_SetClosedLoopRampRate(self, rate)
            }
            #[inline]
            pub unsafe fn GetOpenLoopRampRate(&mut self) -> f64 {
                CANSparkMax_GetOpenLoopRampRate(self)
            }
            #[inline]
            pub unsafe fn GetClosedLoopRampRate(&mut self) -> f64 {
                CANSparkMax_GetClosedLoopRampRate(self)
            }
            #[inline]
            pub unsafe fn Follow(
                &mut self,
                leader: *const root::rev::CANSparkMax,
                invert: bool,
            ) -> root::rev::REVLibError {
                CANSparkMax_Follow(self, leader, invert)
            }
            #[inline]
            pub unsafe fn Follow1(
                &mut self,
                leader: root::rev::CANSparkMax_ExternalFollower,
                deviceID: ::std::os::raw::c_int,
                invert: bool,
            ) -> root::rev::REVLibError {
                CANSparkMax_Follow1(self, leader, deviceID, invert)
            }
            #[inline]
            pub unsafe fn IsFollower(&mut self) -> bool {
                CANSparkMax_IsFollower(self)
            }
            #[inline]
            pub unsafe fn GetFaults(&mut self) -> u16 {
                CANSparkMax_GetFaults(self)
            }
            #[inline]
            pub unsafe fn GetStickyFaults(&mut self) -> u16 {
                CANSparkMax_GetStickyFaults(self)
            }
            #[inline]
            pub unsafe fn GetFault(&self, faultID: root::rev::CANSparkMax_FaultID) -> bool {
                CANSparkMax_GetFault(self, faultID)
            }
            #[inline]
            pub unsafe fn GetStickyFault(&self, faultID: root::rev::CANSparkMax_FaultID) -> bool {
                CANSparkMax_GetStickyFault(self, faultID)
            }
            #[inline]
            pub unsafe fn GetBusVoltage(&mut self) -> f64 {
                CANSparkMax_GetBusVoltage(self)
            }
            #[inline]
            pub unsafe fn GetAppliedOutput(&mut self) -> f64 {
                CANSparkMax_GetAppliedOutput(self)
            }
            #[inline]
            pub unsafe fn GetOutputCurrent(&mut self) -> f64 {
                CANSparkMax_GetOutputCurrent(self)
            }
            #[inline]
            pub unsafe fn GetMotorTemperature(&mut self) -> f64 {
                CANSparkMax_GetMotorTemperature(self)
            }
            #[inline]
            pub unsafe fn ClearFaults(&mut self) -> root::rev::REVLibError {
                CANSparkMax_ClearFaults(self)
            }
            #[inline]
            pub unsafe fn BurnFlash(&mut self) -> root::rev::REVLibError {
                CANSparkMax_BurnFlash(self)
            }
            #[inline]
            pub unsafe fn SetCANTimeout(
                &mut self,
                milliseconds: ::std::os::raw::c_int,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetCANTimeout(self, milliseconds)
            }
            #[inline]
            pub unsafe fn EnableSoftLimit(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                enable: bool,
            ) -> root::rev::REVLibError {
                CANSparkMax_EnableSoftLimit(self, direction, enable)
            }
            #[inline]
            pub unsafe fn IsSoftLimitEnabled(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> bool {
                CANSparkMax_IsSoftLimitEnabled(self, direction)
            }
            #[inline]
            pub unsafe fn SetSoftLimit(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
                limit: f64,
            ) -> root::rev::REVLibError {
                CANSparkMax_SetSoftLimit(self, direction, limit)
            }
            #[inline]
            pub unsafe fn GetSoftLimit(
                &mut self,
                direction: root::rev::CANSparkMax_SoftLimitDirection,
            ) -> f64 {
                CANSparkMax_GetSoftLimit(self, direction)
            }
            #[inline]
            pub unsafe fn GetLastError(&mut self) -> root::rev::REVLibError {
                CANSparkMax_GetLastError(self)
            }
            #[inline]
            pub unsafe fn new(
                deviceID: ::std::os::raw::c_int,
                type_: root::rev::CANSparkMaxLowLevel_MotorType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CANSparkMax_CANSparkMax(__bindgen_tmp.as_mut_ptr(), deviceID, type_);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[doc = " Speed Controller Interface ****/\n/**\n Common interface for setting the speed of a speed controller.\n\n @param speed The speed to set.  Value should be between -1.0 and 1.0."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax3SetEd"]
            pub fn CANSparkMax_Set(this: *mut ::std::os::raw::c_void, speed: f64);
        }
        extern "C" {
            #[doc = " Sets the voltage output of the SpeedController.  This is equivalent to\n a call to SetReference(output, CANSparkMax::ControlType::kVoltage). The\n behavior of this call differs slightly from the WPILib documentation for\n this call since the device internally sets the desired voltage (not a\n compensation value). That means that this *can* be a 'set-and-forget'\n call.\n\n @param output The voltage to output."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax10SetVoltageEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl2ELl1EES5_S4_ILln3ELl1EES4_ILl0ELl1EES4_ILln1ELl1EES9_S9_S9_S9_EES9_S9_EEdNS1_12linear_scaleEEE"]
            pub fn CANSparkMax_SetVoltage(
                this: *mut ::std::os::raw::c_void,
                output: root::units::voltage::volt_t,
            );
        }
        extern "C" {
            #[doc = " Common interface for getting the current set speed of a speed controller.\n\n @return The current set speed.  Value is between -1.0 and 1.0."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax3GetEv"]
            pub fn CANSparkMax_Get(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Common interface for inverting direction of a speed controller.\n\n This call has no effect if the controller is a follower. To invert\n a follower, see the follow() method.\n\n @param isInverted The state of inversion, true is inverted."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax11SetInvertedEb"]
            pub fn CANSparkMax_SetInverted(this: *mut ::std::os::raw::c_void, isInverted: bool);
        }
        extern "C" {
            #[doc = " Common interface for returning the inversion state of a speed controller.\n\n This call has no effect if the controller is a follower.\n\n @return isInverted The state of inversion, true is inverted."]
            #[link_name = "\u{1}_ZNK3rev11CANSparkMax11GetInvertedEv"]
            pub fn CANSparkMax_GetInverted(this: *mut ::std::os::raw::c_void) -> bool;
        }
        extern "C" {
            #[doc = " Common interface for disabling a motor."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax7DisableEv"]
            pub fn CANSparkMax_Disable(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Common interface to stop the motor until Set is called again."]
            #[link_name = "\u{1}_ZN3rev11CANSparkMax9StopMotorEv"]
            pub fn CANSparkMax_StopMotor(this: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CIEColor {
            pub X: f64,
            pub Y: f64,
            pub Z: f64,
            pub mag: f64,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev8CIEColor13IlluminantD65E"]
            pub static CIEColor_IlluminantD65: [f64; 3usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev8CIEColor8XYZtoRGBE"]
            pub static CIEColor_XYZtoRGB: [f64; 9usize];
        }
        #[test]
        fn bindgen_test_layout_CIEColor() {
            const UNINIT: ::std::mem::MaybeUninit<CIEColor> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<CIEColor>(),
                32usize,
                concat!("Size of: ", stringify!(CIEColor))
            );
            assert_eq!(
                ::std::mem::align_of::<CIEColor>(),
                8usize,
                concat!("Alignment of ", stringify!(CIEColor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CIEColor),
                    "::",
                    stringify!(X)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CIEColor),
                    "::",
                    stringify!(Y)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CIEColor),
                    "::",
                    stringify!(Z)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mag) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CIEColor),
                    "::",
                    stringify!(mag)
                )
            );
        }
        #[doc = " REV Robotics Color Sensor V3.\n\n This class allows access to a REV Robotics color sensor V3 on an I2C bus."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ColorMatch {
            pub m_colorsToMatch: root::std::vector,
            pub m_confidenceLevel: f64,
        }
        #[test]
        fn bindgen_test_layout_ColorMatch() {
            const UNINIT: ::std::mem::MaybeUninit<ColorMatch> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ColorMatch>(),
                32usize,
                concat!("Size of: ", stringify!(ColorMatch))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorMatch>(),
                8usize,
                concat!("Alignment of ", stringify!(ColorMatch))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_colorsToMatch) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorMatch),
                    "::",
                    stringify!(m_colorsToMatch)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_confidenceLevel) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorMatch),
                    "::",
                    stringify!(m_confidenceLevel)
                )
            );
        }
        extern "C" {
            #[doc = " Add color to match object\n\n @param color color to add to matching\n"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch13AddColorMatchERKN3frc5ColorE"]
            pub fn ColorMatch_AddColorMatch(
                this: *mut root::rev::ColorMatch,
                color: *const root::frc::Color,
            );
        }
        extern "C" {
            #[doc = " Set the confidence interval for determining color. Defaults to 0.95\n\n @param confidence    A value between 0 and 1"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch22SetConfidenceThresholdEd"]
            pub fn ColorMatch_SetConfidenceThreshold(
                this: *mut root::rev::ColorMatch,
                confidence: f64,
            );
        }
        extern "C" {
            #[doc = " MatchColor uses euclidean distance to compare a given normalized RGB\n vector against stored values\n\n @param colorToMatch color to compare against stored colors\n\n @return  Matched color if detected"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch10MatchColorERKN3frc5ColorE"]
            pub fn ColorMatch_MatchColor(
                this: *mut root::rev::ColorMatch,
                colorToMatch: *const root::frc::Color,
            ) -> root::std::optional;
        }
        extern "C" {
            #[doc = " MatchColor uses euclidean distance to compare a given normalized RGB\n vector against stored values\n\n @param colorToMatch color to compare against stored colors\n\n @param confidence The confidence value for this match, this is\n simply 1 - euclidean distance of the two color vectors\n\n @return  Matched color if detected"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch10MatchColorERKN3frc5ColorERd"]
            pub fn ColorMatch_MatchColor1(
                this: *mut root::rev::ColorMatch,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::std::optional;
        }
        extern "C" {
            #[doc = " MatchColor uses euclidean distance to compare a given normalized RGB\n vector against stored values\n\n @param colorToMatch color to compare against stored colors\n\n @param confidence The confidence value for this match, this is\n simply 1 - euclidean distance of the two color vectors\n\n @return  Closest matching color"]
            #[link_name = "\u{1}_ZN3rev10ColorMatch17MatchClosestColorERKN3frc5ColorERd"]
            pub fn ColorMatch_MatchClosestColor(
                this: *mut root::rev::ColorMatch,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::frc::Color;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev10ColorMatchC1Ev"]
            pub fn ColorMatch_ColorMatch(this: *mut root::rev::ColorMatch);
        }
        impl ColorMatch {
            #[inline]
            pub unsafe fn AddColorMatch(&mut self, color: *const root::frc::Color) {
                ColorMatch_AddColorMatch(self, color)
            }
            #[inline]
            pub unsafe fn SetConfidenceThreshold(&mut self, confidence: f64) {
                ColorMatch_SetConfidenceThreshold(self, confidence)
            }
            #[inline]
            pub unsafe fn MatchColor(
                &mut self,
                colorToMatch: *const root::frc::Color,
            ) -> root::std::optional {
                ColorMatch_MatchColor(self, colorToMatch)
            }
            #[inline]
            pub unsafe fn MatchColor1(
                &mut self,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::std::optional {
                ColorMatch_MatchColor1(self, colorToMatch, confidence)
            }
            #[inline]
            pub unsafe fn MatchClosestColor(
                &mut self,
                colorToMatch: *const root::frc::Color,
                confidence: *mut f64,
            ) -> root::frc::Color {
                ColorMatch_MatchClosestColor(self, colorToMatch, confidence)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ColorMatch_ColorMatch(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " REV Robotics Color Sensor V3.\n\n This class allows access to a REV Robotics color sensor V3 on an I2C bus."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ColorSensorV3 {
            pub m_i2c: root::frc::I2C,
            pub m_simDevice: root::hal::SimDevice,
            pub m_simR: root::hal::SimDouble,
            pub m_simG: root::hal::SimDouble,
            pub m_simB: root::hal::SimDouble,
            pub m_simIR: root::hal::SimDouble,
            pub m_simProx: root::hal::SimDouble,
        }
        pub const ColorSensorV3_GainFactor_k1x: root::rev::ColorSensorV3_GainFactor = 0;
        pub const ColorSensorV3_GainFactor_k3x: root::rev::ColorSensorV3_GainFactor = 1;
        pub const ColorSensorV3_GainFactor_k6x: root::rev::ColorSensorV3_GainFactor = 2;
        pub const ColorSensorV3_GainFactor_k9x: root::rev::ColorSensorV3_GainFactor = 3;
        pub const ColorSensorV3_GainFactor_k18x: root::rev::ColorSensorV3_GainFactor = 4;
        pub type ColorSensorV3_GainFactor = ::std::os::raw::c_int;
        pub const ColorSensorV3_LEDPulseFrequency_k60kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 24;
        pub const ColorSensorV3_LEDPulseFrequency_k70kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 64;
        pub const ColorSensorV3_LEDPulseFrequency_k80kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 40;
        pub const ColorSensorV3_LEDPulseFrequency_k90kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 48;
        pub const ColorSensorV3_LEDPulseFrequency_k100kHz:
            root::rev::ColorSensorV3_LEDPulseFrequency = 56;
        pub type ColorSensorV3_LEDPulseFrequency = ::std::os::raw::c_int;
        pub const ColorSensorV3_LEDCurrent_kPulse2mA: root::rev::ColorSensorV3_LEDCurrent = 0;
        pub const ColorSensorV3_LEDCurrent_kPulse5mA: root::rev::ColorSensorV3_LEDCurrent = 1;
        pub const ColorSensorV3_LEDCurrent_kPulse10mA: root::rev::ColorSensorV3_LEDCurrent = 2;
        pub const ColorSensorV3_LEDCurrent_kPulse25mA: root::rev::ColorSensorV3_LEDCurrent = 3;
        pub const ColorSensorV3_LEDCurrent_kPulse50mA: root::rev::ColorSensorV3_LEDCurrent = 4;
        pub const ColorSensorV3_LEDCurrent_kPulse75mA: root::rev::ColorSensorV3_LEDCurrent = 5;
        pub const ColorSensorV3_LEDCurrent_kPulse100mA: root::rev::ColorSensorV3_LEDCurrent = 6;
        pub const ColorSensorV3_LEDCurrent_kPulse125mA: root::rev::ColorSensorV3_LEDCurrent = 7;
        pub type ColorSensorV3_LEDCurrent = ::std::os::raw::c_int;
        pub const ColorSensorV3_ProximityResolution_k8bit:
            root::rev::ColorSensorV3_ProximityResolution = 0;
        pub const ColorSensorV3_ProximityResolution_k9bit:
            root::rev::ColorSensorV3_ProximityResolution = 8;
        pub const ColorSensorV3_ProximityResolution_k10bit:
            root::rev::ColorSensorV3_ProximityResolution = 16;
        pub const ColorSensorV3_ProximityResolution_k11bit:
            root::rev::ColorSensorV3_ProximityResolution = 24;
        pub type ColorSensorV3_ProximityResolution = ::std::os::raw::c_int;
        pub const ColorSensorV3_ProximityMeasurementRate_k6ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 1;
        pub const ColorSensorV3_ProximityMeasurementRate_k12ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 2;
        pub const ColorSensorV3_ProximityMeasurementRate_k25ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 3;
        pub const ColorSensorV3_ProximityMeasurementRate_k50ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 4;
        pub const ColorSensorV3_ProximityMeasurementRate_k100ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 5;
        pub const ColorSensorV3_ProximityMeasurementRate_k200ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 6;
        pub const ColorSensorV3_ProximityMeasurementRate_k400ms:
            root::rev::ColorSensorV3_ProximityMeasurementRate = 7;
        pub type ColorSensorV3_ProximityMeasurementRate = ::std::os::raw::c_int;
        pub const ColorSensorV3_ColorResolution_k20bit: root::rev::ColorSensorV3_ColorResolution =
            0;
        pub const ColorSensorV3_ColorResolution_k19bit: root::rev::ColorSensorV3_ColorResolution =
            16;
        pub const ColorSensorV3_ColorResolution_k18bit: root::rev::ColorSensorV3_ColorResolution =
            32;
        pub const ColorSensorV3_ColorResolution_k17bit: root::rev::ColorSensorV3_ColorResolution =
            48;
        pub const ColorSensorV3_ColorResolution_k16bit: root::rev::ColorSensorV3_ColorResolution =
            64;
        pub const ColorSensorV3_ColorResolution_k13bit: root::rev::ColorSensorV3_ColorResolution =
            80;
        pub type ColorSensorV3_ColorResolution = ::std::os::raw::c_int;
        pub const ColorSensorV3_ColorMeasurementRate_k25ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 0;
        pub const ColorSensorV3_ColorMeasurementRate_k50ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 1;
        pub const ColorSensorV3_ColorMeasurementRate_k100ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 2;
        pub const ColorSensorV3_ColorMeasurementRate_k200ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 3;
        pub const ColorSensorV3_ColorMeasurementRate_k500ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 4;
        pub const ColorSensorV3_ColorMeasurementRate_k1000ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 5;
        pub const ColorSensorV3_ColorMeasurementRate_k2000ms:
            root::rev::ColorSensorV3_ColorMeasurementRate = 7;
        pub type ColorSensorV3_ColorMeasurementRate = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ColorSensorV3_RawColor {
            pub red: u32,
            pub green: u32,
            pub blue: u32,
            pub ir: u32,
        }
        #[test]
        fn bindgen_test_layout_ColorSensorV3_RawColor() {
            const UNINIT: ::std::mem::MaybeUninit<ColorSensorV3_RawColor> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ColorSensorV3_RawColor>(),
                16usize,
                concat!("Size of: ", stringify!(ColorSensorV3_RawColor))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorSensorV3_RawColor>(),
                4usize,
                concat!("Alignment of ", stringify!(ColorSensorV3_RawColor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3_RawColor),
                    "::",
                    stringify!(red)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3_RawColor),
                    "::",
                    stringify!(green)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3_RawColor),
                    "::",
                    stringify!(blue)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ir) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3_RawColor),
                    "::",
                    stringify!(ir)
                )
            );
        }
        pub const ColorSensorV3_Register_kMainCtrl: root::rev::ColorSensorV3_Register = 0;
        pub const ColorSensorV3_Register_kProximitySensorLED: root::rev::ColorSensorV3_Register = 1;
        pub const ColorSensorV3_Register_kProximitySensorPulses: root::rev::ColorSensorV3_Register =
            2;
        pub const ColorSensorV3_Register_kProximitySensorRate: root::rev::ColorSensorV3_Register =
            3;
        pub const ColorSensorV3_Register_kLightSensorMeasurementRate:
            root::rev::ColorSensorV3_Register = 4;
        pub const ColorSensorV3_Register_kLightSensorGain: root::rev::ColorSensorV3_Register = 5;
        pub const ColorSensorV3_Register_kPartID: root::rev::ColorSensorV3_Register = 6;
        pub const ColorSensorV3_Register_kMainStatus: root::rev::ColorSensorV3_Register = 7;
        pub const ColorSensorV3_Register_kProximityData: root::rev::ColorSensorV3_Register = 8;
        pub const ColorSensorV3_Register_kDataInfrared: root::rev::ColorSensorV3_Register = 10;
        pub const ColorSensorV3_Register_kDataGreen: root::rev::ColorSensorV3_Register = 13;
        pub const ColorSensorV3_Register_kDataBlue: root::rev::ColorSensorV3_Register = 16;
        pub const ColorSensorV3_Register_kDataRed: root::rev::ColorSensorV3_Register = 19;
        pub type ColorSensorV3_Register = ::std::os::raw::c_int;
        pub const ColorSensorV3_MainCtrlFields_kProximitySensorEnable:
            root::rev::ColorSensorV3_MainCtrlFields = 1;
        pub const ColorSensorV3_MainCtrlFields_kLightSensorEnable:
            root::rev::ColorSensorV3_MainCtrlFields = 2;
        pub const ColorSensorV3_MainCtrlFields_kRGBMode: root::rev::ColorSensorV3_MainCtrlFields =
            4;
        pub type ColorSensorV3_MainCtrlFields = ::std::os::raw::c_int;
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct ColorSensorV3_MainStatus {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        }
        #[test]
        fn bindgen_test_layout_ColorSensorV3_MainStatus() {
            assert_eq!(
                ::std::mem::size_of::<ColorSensorV3_MainStatus>(),
                1usize,
                concat!("Size of: ", stringify!(ColorSensorV3_MainStatus))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorSensorV3_MainStatus>(),
                1usize,
                concat!("Alignment of ", stringify!(ColorSensorV3_MainStatus))
            );
        }
        impl ColorSensorV3_MainStatus {
            #[inline]
            pub fn PSDataStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PSDataStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn PSInterruptStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PSInterruptStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn PSLogicStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PSLogicStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn LSDataStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_LSDataStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn LSInterruptStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_LSInterruptStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn PowerOnStatus(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_PowerOnStatus(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                PSDataStatus: u8,
                PSInterruptStatus: u8,
                PSLogicStatus: u8,
                LSDataStatus: u8,
                LSInterruptStatus: u8,
                PowerOnStatus: u8,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let PSDataStatus: u8 = unsafe { ::std::mem::transmute(PSDataStatus) };
                    PSDataStatus as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let PSInterruptStatus: u8 = unsafe { ::std::mem::transmute(PSInterruptStatus) };
                    PSInterruptStatus as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let PSLogicStatus: u8 = unsafe { ::std::mem::transmute(PSLogicStatus) };
                    PSLogicStatus as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let LSDataStatus: u8 = unsafe { ::std::mem::transmute(LSDataStatus) };
                    LSDataStatus as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let LSInterruptStatus: u8 = unsafe { ::std::mem::transmute(LSInterruptStatus) };
                    LSInterruptStatus as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let PowerOnStatus: u8 = unsafe { ::std::mem::transmute(PowerOnStatus) };
                    PowerOnStatus as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3rev13ColorSensorV37CmatrixE"]
            pub static ColorSensorV3_Cmatrix: [f64; 9usize];
        }
        #[test]
        fn bindgen_test_layout_ColorSensorV3() {
            const UNINIT: ::std::mem::MaybeUninit<ColorSensorV3> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ColorSensorV3>(),
                32usize,
                concat!("Size of: ", stringify!(ColorSensorV3))
            );
            assert_eq!(
                ::std::mem::align_of::<ColorSensorV3>(),
                4usize,
                concat!("Alignment of ", stringify!(ColorSensorV3))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_i2c) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_i2c)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_simDevice)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simR) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_simR)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simG) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_simG)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simB) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_simB)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simIR) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_simIR)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simProx) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ColorSensorV3),
                    "::",
                    stringify!(m_simProx)
                )
            );
        }
        extern "C" {
            #[doc = " Get the normalized RGB color from the sensor (normalized based on\n total R + G + B)\n\n @return  frc::Color class with normalized sRGB values"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV38GetColorEv"]
            pub fn ColorSensorV3_GetColor(this: *mut root::rev::ColorSensorV3) -> root::frc::Color;
        }
        extern "C" {
            #[doc = " Get the raw color value from the sensor.\n\n @return  Raw color values from sensopr"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV311GetRawColorEv"]
            pub fn ColorSensorV3_GetRawColor(
                this: *mut root::rev::ColorSensorV3,
            ) -> root::rev::ColorSensorV3_RawColor;
        }
        extern "C" {
            #[doc = " Get the color converted to CIE XYZ color space using factory\n calibrated constants.\n\n https://en.wikipedia.org/wiki/CIE_1931_color_space\n\n @return  CIEColor value from sensor"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV311GetCIEColorEv"]
            pub fn ColorSensorV3_GetCIEColor(
                this: *mut root::rev::ColorSensorV3,
            ) -> root::rev::CIEColor;
        }
        extern "C" {
            #[doc = " Get the normalzied IR value from the sensor. Works best when within 2\n inches and perpendicular to surface of interest.\n\n @return  Color class with normalized values"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV35GetIREv"]
            pub fn ColorSensorV3_GetIR(this: *mut root::rev::ColorSensorV3) -> f64;
        }
        extern "C" {
            #[doc = " Get the raw proximity value from the sensor ADC. This value is largest\n when an object is close to the sensor and smallest when\n far away.\n\n @return  Proximity measurement value, ranging from 0 to 2047 in\n          default configuration"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV312GetProximityEv"]
            pub fn ColorSensorV3_GetProximity(this: *mut root::rev::ColorSensorV3) -> u32;
        }
        extern "C" {
            #[doc = " Set the gain factor applied to color ADC measurements.\n\n By default, the gain is set to 3x.\n\n @param gain  Gain factor applied to color ADC measurements\n              measurements"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV37SetGainENS0_10GainFactorE"]
            pub fn ColorSensorV3_SetGain(
                this: *mut root::rev::ColorSensorV3,
                gain: root::rev::ColorSensorV3_GainFactor,
            );
        }
        extern "C" {
            #[doc = " Configure the the IR LED used by the proximity sensor.\n\n These settings are only needed for advanced users, the defaults\n will work fine for most teams. Consult the APDS-9151 for more\n information on these configuration settings and how they will affect\n proximity sensor measurements.\n\n @param freq      The pulse modulation frequency for the proximity\n                  sensor LED\n @param curr      The pulse current for the proximity sensor LED\n @param pulses    The number of pulses per measurement of the\n                  proximity sensor LED"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV327ConfigureProximitySensorLEDENS0_17LEDPulseFrequencyENS0_10LEDCurrentEh"]
            pub fn ColorSensorV3_ConfigureProximitySensorLED(
                this: *mut root::rev::ColorSensorV3,
                freq: root::rev::ColorSensorV3_LEDPulseFrequency,
                current: root::rev::ColorSensorV3_LEDCurrent,
                pulses: u8,
            );
        }
        extern "C" {
            #[doc = " Configure the proximity sensor.\n\n These settings are only needed for advanced users, the defaults\n will work fine for most teams. Consult the APDS-9151 for more\n information on these configuration settings and how they will affect\n proximity sensor measurements.\n\n @param res   Bit resolution output by the proximity sensor ADC.\n @param rate  Measurement rate of the proximity sensor"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV324ConfigureProximitySensorENS0_19ProximityResolutionENS0_24ProximityMeasurementRateE"]
            pub fn ColorSensorV3_ConfigureProximitySensor(
                this: *mut root::rev::ColorSensorV3,
                res: root::rev::ColorSensorV3_ProximityResolution,
                rate: root::rev::ColorSensorV3_ProximityMeasurementRate,
            );
        }
        extern "C" {
            #[doc = " Configure the color sensor.\n\n These settings are only needed for advanced users, the defaults\n will work fine for most teams. Consult the APDS-9151 for more\n information on these configuration settings and how they will affect\n color sensor measurements.\n\n @param res   Bit resolution output by the respective light sensor ADCs\n @param rate  Measurement rate of the light sensor"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV320ConfigureColorSensorENS0_15ColorResolutionENS0_20ColorMeasurementRateE"]
            pub fn ColorSensorV3_ConfigureColorSensor(
                this: *mut root::rev::ColorSensorV3,
                res: root::rev::ColorSensorV3_ColorResolution,
                rate: root::rev::ColorSensorV3_ColorMeasurementRate,
            );
        }
        extern "C" {
            #[doc = " Indicates if the device reset. Based on the power on status flag in the\n status register. Per the datasheet:\n\n Part went through a power-up event, either because the part was turned\n on or because there was power supply voltage disturbance (default at\n first register read).\n\n This flag is self clearing\n\n @return  true if the device was reset"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV38HasResetEv"]
            pub fn ColorSensorV3_HasReset(this: *mut root::rev::ColorSensorV3) -> bool;
        }
        extern "C" {
            #[doc = " Indicates if the device can currently be communicated with.\n\n @return  true if the device is currently connected and responsive"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV311IsConnectedEv"]
            pub fn ColorSensorV3_IsConnected(this: *mut root::rev::ColorSensorV3) -> bool;
        }
        extern "C" {
            #[doc = " Constructs a ColorSensorV3.\n\n Note that the REV Color Sensor is really two devices in one package:\n a color sensor providing red, green, blue and IR values, and a proximity\n sensor.\n\n @param port  The I2C port the color sensor is attached to"]
            #[link_name = "\u{1}_ZN3rev13ColorSensorV3C1EN3frc3I2C4PortE"]
            pub fn ColorSensorV3_ColorSensorV3(
                this: *mut root::rev::ColorSensorV3,
                port: root::frc::I2C_Port,
            );
        }
        impl ColorSensorV3 {
            #[inline]
            pub unsafe fn GetColor(&mut self) -> root::frc::Color {
                ColorSensorV3_GetColor(self)
            }
            #[inline]
            pub unsafe fn GetRawColor(&mut self) -> root::rev::ColorSensorV3_RawColor {
                ColorSensorV3_GetRawColor(self)
            }
            #[inline]
            pub unsafe fn GetCIEColor(&mut self) -> root::rev::CIEColor {
                ColorSensorV3_GetCIEColor(self)
            }
            #[inline]
            pub unsafe fn GetIR(&mut self) -> f64 {
                ColorSensorV3_GetIR(self)
            }
            #[inline]
            pub unsafe fn GetProximity(&mut self) -> u32 {
                ColorSensorV3_GetProximity(self)
            }
            #[inline]
            pub unsafe fn SetGain(&mut self, gain: root::rev::ColorSensorV3_GainFactor) {
                ColorSensorV3_SetGain(self, gain)
            }
            #[inline]
            pub unsafe fn ConfigureProximitySensorLED(
                &mut self,
                freq: root::rev::ColorSensorV3_LEDPulseFrequency,
                current: root::rev::ColorSensorV3_LEDCurrent,
                pulses: u8,
            ) {
                ColorSensorV3_ConfigureProximitySensorLED(self, freq, current, pulses)
            }
            #[inline]
            pub unsafe fn ConfigureProximitySensor(
                &mut self,
                res: root::rev::ColorSensorV3_ProximityResolution,
                rate: root::rev::ColorSensorV3_ProximityMeasurementRate,
            ) {
                ColorSensorV3_ConfigureProximitySensor(self, res, rate)
            }
            #[inline]
            pub unsafe fn ConfigureColorSensor(
                &mut self,
                res: root::rev::ColorSensorV3_ColorResolution,
                rate: root::rev::ColorSensorV3_ColorMeasurementRate,
            ) {
                ColorSensorV3_ConfigureColorSensor(self, res, rate)
            }
            #[inline]
            pub unsafe fn HasReset(&mut self) -> bool {
                ColorSensorV3_HasReset(self)
            }
            #[inline]
            pub unsafe fn IsConnected(&mut self) -> bool {
                ColorSensorV3_IsConnected(self)
            }
            #[inline]
            pub unsafe fn new(port: root::frc::I2C_Port) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ColorSensorV3_ColorSensorV3(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct basic_string<_CharT> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider,
            pub _M_string_length: root::std::basic_string_size_type,
            pub __bindgen_anon_1: root::std::basic_string__bindgen_ty_2<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string__Char_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::basic_string__Char_alloc_type;
        pub type basic_string_size_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_difference_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::basic_string_const_iterator;
        pub type basic_string___sv_type<_CharT> = root::std::basic_string_view<_CharT>;
        pub type basic_string__If_sv = root::std::enable_if_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___sv_wrapper<_CharT> {
            pub _M_sv: root::std::basic_string___sv_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::basic_string_pointer,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: *mut _CharT,
            pub _M_allocated_capacity: root::std::basic_string_size_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type __bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __not_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_same {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        pub type __enable_if_t = u8;
        pub type __remove_cvref_t = root::std::remove_cv;
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_t {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_in_place_t() {
            assert_eq!(
                ::std::mem::size_of::<in_place_t>(),
                1usize,
                concat!("Size of: ", stringify!(in_place_t))
            );
            assert_eq!(
                ::std::mem::align_of::<in_place_t>(),
                1usize,
                concat!("Alignment of ", stringify!(in_place_t))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = root::std::__undefined;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_elem {
            pub _address: u8,
        }
        pub type __ptr_traits_elem_t = root::std::__ptr_traits_elem;
        pub type __ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
        pub type __ptr_traits_ptr_to_element_type<_Elt> = _Elt;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl___difference {
            pub _address: u8,
        }
        pub type __ptr_traits_impl___difference_type = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl___rebind {
            pub _address: u8,
        }
        pub type __ptr_traits_impl_pointer<_Ptr> = _Ptr;
        pub type __ptr_traits_impl_element_type<_Elt> = _Elt;
        pub type __ptr_traits_impl_difference_type = root::std::__ptr_traits_impl___difference;
        pub type __ptr_traits_impl_rebind = root::std::__ptr_traits_impl___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct atomic<_Tp> {
            pub _M_i: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        pub type atomic_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __new_allocator {
            pub _address: u8,
        }
        pub type __new_allocator_value_type<_Tp> = _Tp;
        pub type __new_allocator_size_type = usize;
        pub type __new_allocator_difference_type = isize;
        pub type __new_allocator_pointer<_Tp> = *mut _Tp;
        pub type __new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type __new_allocator_reference<_Tp> = *mut _Tp;
        pub type __new_allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __new_allocator_rebind {
            pub _address: u8,
        }
        pub type __new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type __allocator_base = root::std::__new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        pub type string = root::std::basic_string<::std::os::raw::c_char>;
        pub type streamoff = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        pub type streampos = root::std::fpos<root::mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: usize,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> =
            *mut root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_pointer<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_reference<_CharT> =
            *mut root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_reference<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_iterator<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_iterator<_CharT> =
            root::std::basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            root::std::reverse_iterator<root::std::basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            root::std::basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct vector__Temporary_value<_Tp> {
            pub _M_this: *mut root::std::vector,
            pub _M_storage: root::std::vector__Temporary_value__Storage<_Tp>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        #[repr(C)]
        pub union vector__Temporary_value__Storage<_Tp> {
            pub _M_byte: ::std::os::raw::c_uchar,
            pub _M_val: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::intmax_t;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::intmax_t;
        }
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional__Base = u8;
        pub type optional___not_self = root::std::__not_;
        pub type optional___not_tag = root::std::__not_;
        pub type optional__Requires = root::std::enable_if_t;
        pub type optional_value_type<_Tp> = _Tp;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator___convertible_from = root::std::__enable_if_t;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: root::__mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    pub type mbstate_t = root::__mbstate_t;
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod fmt {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod units {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @brief\t\thelper type to identify base units.\n @details\t\tA non-templated base class for `base_unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _base_unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__base_unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_base_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_base_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_base_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_base_unit_t))
                );
            }
            #[doc = " @brief\t\thelper type to identify units.\n @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_unit_t))
                );
            }
        }
        pub mod constants {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod traits {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct base_unit {
            pub _address: u8,
        }
        pub type base_unit_meter_ratio<Meter> = Meter;
        pub type base_unit_kilogram_ratio<Kilogram> = Kilogram;
        pub type base_unit_second_ratio<Second> = Second;
        pub type base_unit_radian_ratio<Radian> = Radian;
        pub type base_unit_ampere_ratio<Ampere> = Ampere;
        pub type base_unit_kelvin_ratio<Kelvin> = Kelvin;
        pub type base_unit_mole_ratio<Mole> = Mole;
        pub type base_unit_candela_ratio<Candela> = Candela;
        pub type base_unit_byte_ratio<Byte> = Byte;
        pub mod category {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type voltage_unit = root::units::base_unit;
        }
        #[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
        #[repr(C)]
        pub struct unit_t {
            pub _base: root::units::linear_scale<[u8; 0usize]>,
        }
        pub type unit_t_nls = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_non_linear_scale_type = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_underlying_type<T> = T;
        pub type unit_t_value_type<T> = T;
        pub type unit_t_unit_type<Units> = Units;
        #[doc = " @cond"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct linear_scale<T> {
            #[doc = "< linearized value."]
            pub m_value: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub mod voltage {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type volts = u8;
            pub type volt = root::units::voltage::volts;
            #[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
            pub type volt_t = root::units::unit_t;
        }
    }
    pub mod frc {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct SpeedController__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface for speed controlling devices.\n\n @deprecated Use MotorController."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SpeedController {
            pub vtable_: *const SpeedController__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_SpeedController() {
            assert_eq!(
                ::std::mem::size_of::<SpeedController>(),
                8usize,
                concat!("Size of: ", stringify!(SpeedController))
            );
            assert_eq!(
                ::std::mem::align_of::<SpeedController>(),
                8usize,
                concat!("Alignment of ", stringify!(SpeedController))
            );
        }
        extern "C" {
            #[doc = " Sets the voltage output of the SpeedController.  Compensates for\n the current bus voltage to ensure that the desired voltage is output even\n if the battery voltage is below 12V - highly useful when the voltage\n outputs are \"meaningful\" (e.g. they come from a feedforward calculation).\n\n <p>NOTE: This function *must* be called regularly in order for voltage\n compensation to work properly - unlike the ordinary set function, it is not\n \"set it and forget it.\"\n\n @param output The voltage to output."]
            #[link_name = "\u{1}_ZN3frc15SpeedController10SetVoltageEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl2ELl1EES5_S4_ILln3ELl1EES4_ILl0ELl1EES4_ILln1ELl1EES9_S9_S9_S9_EES9_S9_EEdNS1_12linear_scaleEEE"]
            pub fn SpeedController_SetVoltage(
                this: *mut ::std::os::raw::c_void,
                output: root::units::voltage::volt_t,
            );
        }
        #[doc = " Interface for motor controlling devices."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct MotorController {
            pub _base: root::frc::SpeedController,
        }
        #[test]
        fn bindgen_test_layout_MotorController() {
            assert_eq!(
                ::std::mem::size_of::<MotorController>(),
                8usize,
                concat!("Size of: ", stringify!(MotorController))
            );
            assert_eq!(
                ::std::mem::align_of::<MotorController>(),
                8usize,
                concat!("Alignment of ", stringify!(MotorController))
            );
        }
        #[doc = " Represents colors that can be used with Addressable LEDs.\n\n Limited to 12 bits of precision."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Color {
            pub red: f64,
            pub green: f64,
            pub blue: f64,
        }
        extern "C" {
            #[doc = " 0x1560BD."]
            #[link_name = "\u{1}_ZN3frc5Color6kDenimE"]
            pub static Color_kDenim: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x0066B3."]
            #[link_name = "\u{1}_ZN3frc5Color10kFirstBlueE"]
            pub static Color_kFirstBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xED1C24."]
            #[link_name = "\u{1}_ZN3frc5Color9kFirstRedE"]
            pub static Color_kFirstRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0F8FF."]
            #[link_name = "\u{1}_ZN3frc5Color10kAliceBlueE"]
            pub static Color_kAliceBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFAEBD7."]
            #[link_name = "\u{1}_ZN3frc5Color13kAntiqueWhiteE"]
            pub static Color_kAntiqueWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color5kAquaE"]
            pub static Color_kAqua: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7FFFD4."]
            #[link_name = "\u{1}_ZN3frc5Color11kAquamarineE"]
            pub static Color_kAquamarine: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color6kAzureE"]
            pub static Color_kAzure: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5F5DC."]
            #[link_name = "\u{1}_ZN3frc5Color6kBeigeE"]
            pub static Color_kBeige: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFE4C4."]
            #[link_name = "\u{1}_ZN3frc5Color7kBisqueE"]
            pub static Color_kBisque: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x000000."]
            #[link_name = "\u{1}_ZN3frc5Color6kBlackE"]
            pub static Color_kBlack: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFEBCD."]
            #[link_name = "\u{1}_ZN3frc5Color15kBlanchedAlmondE"]
            pub static Color_kBlanchedAlmond: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x0000FF."]
            #[link_name = "\u{1}_ZN3frc5Color5kBlueE"]
            pub static Color_kBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8A2BE2."]
            #[link_name = "\u{1}_ZN3frc5Color11kBlueVioletE"]
            pub static Color_kBlueViolet: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xA52A2A."]
            #[link_name = "\u{1}_ZN3frc5Color6kBrownE"]
            pub static Color_kBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDEB887."]
            #[link_name = "\u{1}_ZN3frc5Color10kBurlywoodE"]
            pub static Color_kBurlywood: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x5F9EA0."]
            #[link_name = "\u{1}_ZN3frc5Color10kCadetBlueE"]
            pub static Color_kCadetBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7FFF00."]
            #[link_name = "\u{1}_ZN3frc5Color11kChartreuseE"]
            pub static Color_kChartreuse: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD2691E."]
            #[link_name = "\u{1}_ZN3frc5Color10kChocolateE"]
            pub static Color_kChocolate: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF7F50."]
            #[link_name = "\u{1}_ZN3frc5Color6kCoralE"]
            pub static Color_kCoral: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x6495ED."]
            #[link_name = "\u{1}_ZN3frc5Color15kCornflowerBlueE"]
            pub static Color_kCornflowerBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFF8DC."]
            #[link_name = "\u{1}_ZN3frc5Color9kCornsilkE"]
            pub static Color_kCornsilk: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDC143C."]
            #[link_name = "\u{1}_ZN3frc5Color8kCrimsonE"]
            pub static Color_kCrimson: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color5kCyanE"]
            pub static Color_kCyan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00008B."]
            #[link_name = "\u{1}_ZN3frc5Color9kDarkBlueE"]
            pub static Color_kDarkBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x008B8B."]
            #[link_name = "\u{1}_ZN3frc5Color9kDarkCyanE"]
            pub static Color_kDarkCyan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB8860B."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkGoldenrodE"]
            pub static Color_kDarkGoldenrod: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xA9A9A9."]
            #[link_name = "\u{1}_ZN3frc5Color9kDarkGrayE"]
            pub static Color_kDarkGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x006400."]
            #[link_name = "\u{1}_ZN3frc5Color10kDarkGreenE"]
            pub static Color_kDarkGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xBDB76B."]
            #[link_name = "\u{1}_ZN3frc5Color10kDarkKhakiE"]
            pub static Color_kDarkKhaki: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8B008B."]
            #[link_name = "\u{1}_ZN3frc5Color12kDarkMagentaE"]
            pub static Color_kDarkMagenta: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x556B2F."]
            #[link_name = "\u{1}_ZN3frc5Color15kDarkOliveGreenE"]
            pub static Color_kDarkOliveGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF8C00."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkOrangeE"]
            pub static Color_kDarkOrange: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9932CC."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkOrchidE"]
            pub static Color_kDarkOrchid: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8B0000."]
            #[link_name = "\u{1}_ZN3frc5Color8kDarkRedE"]
            pub static Color_kDarkRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xE9967A."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkSalmonE"]
            pub static Color_kDarkSalmon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8FBC8F."]
            #[link_name = "\u{1}_ZN3frc5Color13kDarkSeaGreenE"]
            pub static Color_kDarkSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x483D8B."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkSlateBlueE"]
            pub static Color_kDarkSlateBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x2F4F4F."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkSlateGrayE"]
            pub static Color_kDarkSlateGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00CED1."]
            #[link_name = "\u{1}_ZN3frc5Color14kDarkTurquoiseE"]
            pub static Color_kDarkTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9400D3."]
            #[link_name = "\u{1}_ZN3frc5Color11kDarkVioletE"]
            pub static Color_kDarkViolet: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF1493."]
            #[link_name = "\u{1}_ZN3frc5Color9kDeepPinkE"]
            pub static Color_kDeepPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00BFFF."]
            #[link_name = "\u{1}_ZN3frc5Color12kDeepSkyBlueE"]
            pub static Color_kDeepSkyBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x696969."]
            #[link_name = "\u{1}_ZN3frc5Color8kDimGrayE"]
            pub static Color_kDimGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x1E90FF."]
            #[link_name = "\u{1}_ZN3frc5Color11kDodgerBlueE"]
            pub static Color_kDodgerBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB22222."]
            #[link_name = "\u{1}_ZN3frc5Color10kFirebrickE"]
            pub static Color_kFirebrick: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFAF0."]
            #[link_name = "\u{1}_ZN3frc5Color12kFloralWhiteE"]
            pub static Color_kFloralWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x228B22."]
            #[link_name = "\u{1}_ZN3frc5Color12kForestGreenE"]
            pub static Color_kForestGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF00FF."]
            #[link_name = "\u{1}_ZN3frc5Color8kFuchsiaE"]
            pub static Color_kFuchsia: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDCDCDC."]
            #[link_name = "\u{1}_ZN3frc5Color10kGainsboroE"]
            pub static Color_kGainsboro: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF8F8FF."]
            #[link_name = "\u{1}_ZN3frc5Color11kGhostWhiteE"]
            pub static Color_kGhostWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFD700."]
            #[link_name = "\u{1}_ZN3frc5Color5kGoldE"]
            pub static Color_kGold: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDAA520."]
            #[link_name = "\u{1}_ZN3frc5Color10kGoldenrodE"]
            pub static Color_kGoldenrod: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x808080."]
            #[link_name = "\u{1}_ZN3frc5Color5kGrayE"]
            pub static Color_kGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x008000."]
            #[link_name = "\u{1}_ZN3frc5Color6kGreenE"]
            pub static Color_kGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xADFF2F."]
            #[link_name = "\u{1}_ZN3frc5Color12kGreenYellowE"]
            pub static Color_kGreenYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0FFF0."]
            #[link_name = "\u{1}_ZN3frc5Color9kHoneydewE"]
            pub static Color_kHoneydew: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF69B4."]
            #[link_name = "\u{1}_ZN3frc5Color8kHotPinkE"]
            pub static Color_kHotPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xCD5C5C."]
            #[link_name = "\u{1}_ZN3frc5Color10kIndianRedE"]
            pub static Color_kIndianRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x4B0082."]
            #[link_name = "\u{1}_ZN3frc5Color7kIndigoE"]
            pub static Color_kIndigo: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFFF0."]
            #[link_name = "\u{1}_ZN3frc5Color6kIvoryE"]
            pub static Color_kIvory: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF0E68C."]
            #[link_name = "\u{1}_ZN3frc5Color6kKhakiE"]
            pub static Color_kKhaki: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xE6E6FA."]
            #[link_name = "\u{1}_ZN3frc5Color9kLavenderE"]
            pub static Color_kLavender: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFF0F5."]
            #[link_name = "\u{1}_ZN3frc5Color14kLavenderBlushE"]
            pub static Color_kLavenderBlush: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7CFC00."]
            #[link_name = "\u{1}_ZN3frc5Color10kLawnGreenE"]
            pub static Color_kLawnGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFACD."]
            #[link_name = "\u{1}_ZN3frc5Color13kLemonChiffonE"]
            pub static Color_kLemonChiffon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xADD8E6."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightBlueE"]
            pub static Color_kLightBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF08080."]
            #[link_name = "\u{1}_ZN3frc5Color11kLightCoralE"]
            pub static Color_kLightCoral: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xE0FFFF."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightCyanE"]
            pub static Color_kLightCyan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFAFAD2."]
            #[link_name = "\u{1}_ZN3frc5Color21kLightGoldenrodYellowE"]
            pub static Color_kLightGoldenrodYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD3D3D3."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightGrayE"]
            pub static Color_kLightGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x90EE90."]
            #[link_name = "\u{1}_ZN3frc5Color11kLightGreenE"]
            pub static Color_kLightGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFB6C1."]
            #[link_name = "\u{1}_ZN3frc5Color10kLightPinkE"]
            pub static Color_kLightPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFA07A."]
            #[link_name = "\u{1}_ZN3frc5Color12kLightSalmonE"]
            pub static Color_kLightSalmon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x20B2AA."]
            #[link_name = "\u{1}_ZN3frc5Color14kLightSeaGreenE"]
            pub static Color_kLightSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x87CEFA."]
            #[link_name = "\u{1}_ZN3frc5Color13kLightSkyBlueE"]
            pub static Color_kLightSkyBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x778899."]
            #[link_name = "\u{1}_ZN3frc5Color15kLightSlateGrayE"]
            pub static Color_kLightSlateGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB0C4DE."]
            #[link_name = "\u{1}_ZN3frc5Color15kLightSteelBlueE"]
            pub static Color_kLightSteelBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFFE0."]
            #[link_name = "\u{1}_ZN3frc5Color12kLightYellowE"]
            pub static Color_kLightYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FF00."]
            #[link_name = "\u{1}_ZN3frc5Color5kLimeE"]
            pub static Color_kLime: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x32CD32."]
            #[link_name = "\u{1}_ZN3frc5Color10kLimeGreenE"]
            pub static Color_kLimeGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFAF0E6."]
            #[link_name = "\u{1}_ZN3frc5Color6kLinenE"]
            pub static Color_kLinen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF00FF."]
            #[link_name = "\u{1}_ZN3frc5Color8kMagentaE"]
            pub static Color_kMagenta: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x800000."]
            #[link_name = "\u{1}_ZN3frc5Color7kMaroonE"]
            pub static Color_kMaroon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x66CDAA."]
            #[link_name = "\u{1}_ZN3frc5Color17kMediumAquamarineE"]
            pub static Color_kMediumAquamarine: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x0000CD."]
            #[link_name = "\u{1}_ZN3frc5Color11kMediumBlueE"]
            pub static Color_kMediumBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xBA55D3."]
            #[link_name = "\u{1}_ZN3frc5Color13kMediumOrchidE"]
            pub static Color_kMediumOrchid: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9370DB."]
            #[link_name = "\u{1}_ZN3frc5Color13kMediumPurpleE"]
            pub static Color_kMediumPurple: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x3CB371."]
            #[link_name = "\u{1}_ZN3frc5Color15kMediumSeaGreenE"]
            pub static Color_kMediumSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x7B68EE."]
            #[link_name = "\u{1}_ZN3frc5Color16kMediumSlateBlueE"]
            pub static Color_kMediumSlateBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FA9A."]
            #[link_name = "\u{1}_ZN3frc5Color18kMediumSpringGreenE"]
            pub static Color_kMediumSpringGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x48D1CC."]
            #[link_name = "\u{1}_ZN3frc5Color16kMediumTurquoiseE"]
            pub static Color_kMediumTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xC71585."]
            #[link_name = "\u{1}_ZN3frc5Color16kMediumVioletRedE"]
            pub static Color_kMediumVioletRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x191970."]
            #[link_name = "\u{1}_ZN3frc5Color13kMidnightBlueE"]
            pub static Color_kMidnightBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5FFFA."]
            #[link_name = "\u{1}_ZN3frc5Color10kMintcreamE"]
            pub static Color_kMintcream: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFE4E1."]
            #[link_name = "\u{1}_ZN3frc5Color10kMistyRoseE"]
            pub static Color_kMistyRose: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFE4B5."]
            #[link_name = "\u{1}_ZN3frc5Color9kMoccasinE"]
            pub static Color_kMoccasin: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFDEAD."]
            #[link_name = "\u{1}_ZN3frc5Color12kNavajoWhiteE"]
            pub static Color_kNavajoWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x000080."]
            #[link_name = "\u{1}_ZN3frc5Color5kNavyE"]
            pub static Color_kNavy: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFDF5E6."]
            #[link_name = "\u{1}_ZN3frc5Color8kOldLaceE"]
            pub static Color_kOldLace: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x808000."]
            #[link_name = "\u{1}_ZN3frc5Color6kOliveE"]
            pub static Color_kOlive: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x6B8E23."]
            #[link_name = "\u{1}_ZN3frc5Color10kOliveDrabE"]
            pub static Color_kOliveDrab: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFA500."]
            #[link_name = "\u{1}_ZN3frc5Color7kOrangeE"]
            pub static Color_kOrange: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF4500."]
            #[link_name = "\u{1}_ZN3frc5Color10kOrangeRedE"]
            pub static Color_kOrangeRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDA70D6."]
            #[link_name = "\u{1}_ZN3frc5Color7kOrchidE"]
            pub static Color_kOrchid: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xEEE8AA."]
            #[link_name = "\u{1}_ZN3frc5Color14kPaleGoldenrodE"]
            pub static Color_kPaleGoldenrod: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x98FB98."]
            #[link_name = "\u{1}_ZN3frc5Color10kPaleGreenE"]
            pub static Color_kPaleGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xAFEEEE."]
            #[link_name = "\u{1}_ZN3frc5Color14kPaleTurquoiseE"]
            pub static Color_kPaleTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDB7093."]
            #[link_name = "\u{1}_ZN3frc5Color14kPaleVioletRedE"]
            pub static Color_kPaleVioletRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFEFD5."]
            #[link_name = "\u{1}_ZN3frc5Color11kPapayaWhipE"]
            pub static Color_kPapayaWhip: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFDAB9."]
            #[link_name = "\u{1}_ZN3frc5Color10kPeachPuffE"]
            pub static Color_kPeachPuff: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xCD853F."]
            #[link_name = "\u{1}_ZN3frc5Color5kPeruE"]
            pub static Color_kPeru: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFC0CB."]
            #[link_name = "\u{1}_ZN3frc5Color5kPinkE"]
            pub static Color_kPink: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xDDA0DD."]
            #[link_name = "\u{1}_ZN3frc5Color5kPlumE"]
            pub static Color_kPlum: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xB0E0E6."]
            #[link_name = "\u{1}_ZN3frc5Color11kPowderBlueE"]
            pub static Color_kPowderBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x800080."]
            #[link_name = "\u{1}_ZN3frc5Color7kPurpleE"]
            pub static Color_kPurple: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF0000."]
            #[link_name = "\u{1}_ZN3frc5Color4kRedE"]
            pub static Color_kRed: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xBC8F8F."]
            #[link_name = "\u{1}_ZN3frc5Color10kRosyBrownE"]
            pub static Color_kRosyBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x4169E1."]
            #[link_name = "\u{1}_ZN3frc5Color10kRoyalBlueE"]
            pub static Color_kRoyalBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x8B4513."]
            #[link_name = "\u{1}_ZN3frc5Color12kSaddleBrownE"]
            pub static Color_kSaddleBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFA8072."]
            #[link_name = "\u{1}_ZN3frc5Color7kSalmonE"]
            pub static Color_kSalmon: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF4A460."]
            #[link_name = "\u{1}_ZN3frc5Color11kSandyBrownE"]
            pub static Color_kSandyBrown: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x2E8B57."]
            #[link_name = "\u{1}_ZN3frc5Color9kSeaGreenE"]
            pub static Color_kSeaGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFF5EE."]
            #[link_name = "\u{1}_ZN3frc5Color9kSeashellE"]
            pub static Color_kSeashell: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xA0522D."]
            #[link_name = "\u{1}_ZN3frc5Color7kSiennaE"]
            pub static Color_kSienna: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xC0C0C0."]
            #[link_name = "\u{1}_ZN3frc5Color7kSilverE"]
            pub static Color_kSilver: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x87CEEB."]
            #[link_name = "\u{1}_ZN3frc5Color8kSkyBlueE"]
            pub static Color_kSkyBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x6A5ACD."]
            #[link_name = "\u{1}_ZN3frc5Color10kSlateBlueE"]
            pub static Color_kSlateBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x708090."]
            #[link_name = "\u{1}_ZN3frc5Color10kSlateGrayE"]
            pub static Color_kSlateGray: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFAFA."]
            #[link_name = "\u{1}_ZN3frc5Color5kSnowE"]
            pub static Color_kSnow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x00FF7F."]
            #[link_name = "\u{1}_ZN3frc5Color12kSpringGreenE"]
            pub static Color_kSpringGreen: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x4682B4."]
            #[link_name = "\u{1}_ZN3frc5Color10kSteelBlueE"]
            pub static Color_kSteelBlue: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD2B48C."]
            #[link_name = "\u{1}_ZN3frc5Color4kTanE"]
            pub static Color_kTan: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x008080."]
            #[link_name = "\u{1}_ZN3frc5Color5kTealE"]
            pub static Color_kTeal: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xD8BFD8."]
            #[link_name = "\u{1}_ZN3frc5Color8kThistleE"]
            pub static Color_kThistle: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFF6347."]
            #[link_name = "\u{1}_ZN3frc5Color7kTomatoE"]
            pub static Color_kTomato: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x40E0D0."]
            #[link_name = "\u{1}_ZN3frc5Color10kTurquoiseE"]
            pub static Color_kTurquoise: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xEE82EE."]
            #[link_name = "\u{1}_ZN3frc5Color7kVioletE"]
            pub static Color_kViolet: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5DEB3."]
            #[link_name = "\u{1}_ZN3frc5Color6kWheatE"]
            pub static Color_kWheat: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFFFF."]
            #[link_name = "\u{1}_ZN3frc5Color6kWhiteE"]
            pub static Color_kWhite: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xF5F5F5."]
            #[link_name = "\u{1}_ZN3frc5Color11kWhiteSmokeE"]
            pub static Color_kWhiteSmoke: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0xFFFF00."]
            #[link_name = "\u{1}_ZN3frc5Color7kYellowE"]
            pub static Color_kYellow: root::frc::Color;
        }
        extern "C" {
            #[doc = " 0x9ACD32."]
            #[link_name = "\u{1}_ZN3frc5Color12kYellowGreenE"]
            pub static Color_kYellowGreen: root::frc::Color;
        }
        pub const Color_kPrecision: f64 = 0.000244140625;
        #[test]
        fn bindgen_test_layout_Color() {
            const UNINIT: ::std::mem::MaybeUninit<Color> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Color>(),
                24usize,
                concat!("Size of: ", stringify!(Color))
            );
            assert_eq!(
                ::std::mem::align_of::<Color>(),
                8usize,
                concat!("Alignment of ", stringify!(Color))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Color),
                    "::",
                    stringify!(red)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Color),
                    "::",
                    stringify!(green)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Color),
                    "::",
                    stringify!(blue)
                )
            );
        }
        #[doc = " I2C bus interface class.\n\n This class is intended to be used by sensor (and other I2C device) drivers.\n It probably should not be used directly."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct I2C {
            pub m_port: root::hal::I2CPort,
            pub m_deviceAddress: ::std::os::raw::c_int,
        }
        pub const I2C_Port_kOnboard: root::frc::I2C_Port = 0;
        pub const I2C_Port_kMXP: root::frc::I2C_Port = 1;
        pub type I2C_Port = ::std::os::raw::c_uint;
        #[test]
        fn bindgen_test_layout_I2C() {
            const UNINIT: ::std::mem::MaybeUninit<I2C> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<I2C>(),
                8usize,
                concat!("Size of: ", stringify!(I2C))
            );
            assert_eq!(
                ::std::mem::align_of::<I2C>(),
                4usize,
                concat!("Alignment of ", stringify!(I2C))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(I2C),
                    "::",
                    stringify!(m_port)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_deviceAddress) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(I2C),
                    "::",
                    stringify!(m_deviceAddress)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK3frc3I2C7GetPortEv"]
            pub fn I2C_GetPort(this: *const root::frc::I2C) -> root::frc::I2C_Port;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK3frc3I2C16GetDeviceAddressEv"]
            pub fn I2C_GetDeviceAddress(this: *const root::frc::I2C) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Generic transaction.\n\n This is a lower-level interface to the I2C hardware giving you more control\n over each transaction. If you intend to write multiple bytes in the same\n transaction and do not plan to receive anything back, use writeBulk()\n instead. Calling this with a receiveSize of 0 will result in an error.\n\n @param dataToSend   Buffer of data to send as part of the transaction.\n @param sendSize     Number of bytes to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param receiveSize  Number of bytes to read from the device.\n @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C11TransactionEPhiS1_i"]
            pub fn I2C_Transaction(
                this: *mut root::frc::I2C,
                dataToSend: *mut u8,
                sendSize: ::std::os::raw::c_int,
                dataReceived: *mut u8,
                receiveSize: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Attempt to address a device on the I2C bus.\n\n This allows you to figure out if there is a device on the I2C bus that\n responds to the address specified in the constructor.\n\n @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C11AddressOnlyEv"]
            pub fn I2C_AddressOnly(this: *mut root::frc::I2C) -> bool;
        }
        extern "C" {
            #[doc = " Execute a write transaction with the device.\n\n Write a single byte to a register on a device and wait until the\n   transaction is complete.\n\n @param registerAddress The address of the register on the device to be\n                        written.\n @param data            The byte to write to the register on the device.\n @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C5WriteEih"]
            pub fn I2C_Write(
                this: *mut root::frc::I2C,
                registerAddress: ::std::os::raw::c_int,
                data: u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a bulk write transaction with the device.\n\n Write multiple bytes to a device and wait until the\n   transaction is complete.\n\n @param data  The data to write to the register on the device.\n @param count The number of bytes to be written.\n @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C9WriteBulkEPhi"]
            pub fn I2C_WriteBulk(
                this: *mut root::frc::I2C,
                data: *mut u8,
                count: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a read transaction with the device.\n\n Read bytes from a device.\n Most I2C devices will auto-increment the register pointer internally\n allowing you to read consecutive registers on a device in a single\n transaction.\n\n @param registerAddress The register to read first in the transaction.\n @param count           The number of bytes to read in the transaction.\n @param data            A pointer to the array of bytes to store the data\n                        read from the device.\n @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C4ReadEiiPh"]
            pub fn I2C_Read(
                this: *mut root::frc::I2C,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                data: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a read only transaction with the device.\n\n Read bytes from a device. This method does not write any data to prompt the\n device.\n\n @param buffer A pointer to the array of bytes to store the data read from\n               the device.\n @param count  The number of bytes to read in the transaction.\n @return Transfer Aborted... false for success, true for aborted."]
            #[link_name = "\u{1}_ZN3frc3I2C8ReadOnlyEiPh"]
            pub fn I2C_ReadOnly(
                this: *mut root::frc::I2C,
                count: ::std::os::raw::c_int,
                buffer: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Verify that a device's registers contain expected values.\n\n Most devices will have a set of registers that contain a known value that\n can be used to identify them.  This allows an I2C device driver to easily\n verify that the device contains the expected value.\n\n @pre The device must support and be configured to use register\n auto-increment.\n\n @param registerAddress The base register to start reading from the device.\n @param count           The size of the field to be verified.\n @param expected        A buffer containing the values expected from the\n                        device."]
            #[link_name = "\u{1}_ZN3frc3I2C12VerifySensorEiiPKh"]
            pub fn I2C_VerifySensor(
                this: *mut root::frc::I2C,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                expected: *const u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Constructor.\n\n @param port          The I2C port to which the device is connected.\n @param deviceAddress The address of the device on the I2C bus."]
            #[link_name = "\u{1}_ZN3frc3I2CC1ENS0_4PortEi"]
            pub fn I2C_I2C(
                this: *mut root::frc::I2C,
                port: root::frc::I2C_Port,
                deviceAddress: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc3I2CD1Ev"]
            pub fn I2C_I2C_destructor(this: *mut root::frc::I2C);
        }
        impl I2C {
            #[inline]
            pub unsafe fn GetPort(&self) -> root::frc::I2C_Port {
                I2C_GetPort(self)
            }
            #[inline]
            pub unsafe fn GetDeviceAddress(&self) -> ::std::os::raw::c_int {
                I2C_GetDeviceAddress(self)
            }
            #[inline]
            pub unsafe fn Transaction(
                &mut self,
                dataToSend: *mut u8,
                sendSize: ::std::os::raw::c_int,
                dataReceived: *mut u8,
                receiveSize: ::std::os::raw::c_int,
            ) -> bool {
                I2C_Transaction(self, dataToSend, sendSize, dataReceived, receiveSize)
            }
            #[inline]
            pub unsafe fn AddressOnly(&mut self) -> bool {
                I2C_AddressOnly(self)
            }
            #[inline]
            pub unsafe fn Write(
                &mut self,
                registerAddress: ::std::os::raw::c_int,
                data: u8,
            ) -> bool {
                I2C_Write(self, registerAddress, data)
            }
            #[inline]
            pub unsafe fn WriteBulk(
                &mut self,
                data: *mut u8,
                count: ::std::os::raw::c_int,
            ) -> bool {
                I2C_WriteBulk(self, data, count)
            }
            #[inline]
            pub unsafe fn Read(
                &mut self,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                data: *mut u8,
            ) -> bool {
                I2C_Read(self, registerAddress, count, data)
            }
            #[inline]
            pub unsafe fn ReadOnly(
                &mut self,
                count: ::std::os::raw::c_int,
                buffer: *mut u8,
            ) -> bool {
                I2C_ReadOnly(self, count, buffer)
            }
            #[inline]
            pub unsafe fn VerifySensor(
                &mut self,
                registerAddress: ::std::os::raw::c_int,
                count: ::std::os::raw::c_int,
                expected: *const u8,
            ) -> bool {
                I2C_VerifySensor(self, registerAddress, count, expected)
            }
            #[inline]
            pub unsafe fn new(
                port: root::frc::I2C_Port,
                deviceAddress: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                I2C_I2C(__bindgen_tmp.as_mut_ptr(), port, deviceAddress);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                I2C_I2C_destructor(self)
            }
        }
    }
    pub type HAL_Handle = i32;
    pub type HAL_SimDeviceHandle = root::HAL_Handle;
    pub type HAL_SimValueHandle = root::HAL_Handle;
    pub mod hal {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " A move-only C++ wrapper around HAL_I2CPort.\n Does not ensure destruction."]
        pub type I2CPort = u32;
        #[doc = " C++ wrapper around a HAL simulator value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimValue {
            pub m_handle: root::HAL_SimValueHandle,
        }
        #[test]
        fn bindgen_test_layout_SimValue() {
            const UNINIT: ::std::mem::MaybeUninit<SimValue> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SimValue>(),
                4usize,
                concat!("Size of: ", stringify!(SimValue))
            );
            assert_eq!(
                ::std::mem::align_of::<SimValue>(),
                4usize,
                concat!("Alignment of ", stringify!(SimValue))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SimValue),
                    "::",
                    stringify!(m_handle)
                )
            );
        }
        #[doc = " C++ wrapper around a HAL simulator double value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimDouble {
            pub _base: root::hal::SimValue,
        }
        #[test]
        fn bindgen_test_layout_SimDouble() {
            assert_eq!(
                ::std::mem::size_of::<SimDouble>(),
                4usize,
                concat!("Size of: ", stringify!(SimDouble))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDouble>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDouble))
            );
        }
        #[doc = " A move-only C++ wrapper around a HAL simulator device handle."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SimDevice {
            pub m_handle: root::HAL_SimDeviceHandle,
        }
        pub const SimDevice_Direction_kInput: root::hal::SimDevice_Direction = 0;
        pub const SimDevice_Direction_kOutput: root::hal::SimDevice_Direction = 1;
        pub const SimDevice_Direction_kBidir: root::hal::SimDevice_Direction = 2;
        #[doc = " Direction of a simulated value (from the perspective of user code)."]
        pub type SimDevice_Direction = ::std::os::raw::c_uint;
        #[test]
        fn bindgen_test_layout_SimDevice() {
            const UNINIT: ::std::mem::MaybeUninit<SimDevice> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SimDevice>(),
                4usize,
                concat!("Size of: ", stringify!(SimDevice))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDevice>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDevice))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SimDevice),
                    "::",
                    stringify!(m_handle)
                )
            );
        }
        extern "C" {
            #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index in\n brackets to the device name, e.g. passing index=1 results in \"device[1]\"\n for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKci"]
            pub fn SimDevice_SimDevice(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index and\n channel in brackets to the device name, e.g. passing index=1 and channel=2\n results in \"device[1,2]\" for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name\n @param channel device channel number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKcii"]
            pub fn SimDevice_SimDevice1(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            );
        }
        impl SimDevice {
            #[inline]
            pub unsafe fn new(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice(__bindgen_tmp.as_mut_ptr(), name, index);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice1(__bindgen_tmp.as_mut_ptr(), name, index, channel);
                __bindgen_tmp.assume_init()
            }
        }
    }
    pub const HAL_I2CPort_HAL_I2C_kInvalid: root::HAL_I2CPort = -1;
    pub const HAL_I2CPort_HAL_I2C_kOnboard: root::HAL_I2CPort = 0;
    pub const HAL_I2CPort_HAL_I2C_kMXP: root::HAL_I2CPort = 1;
    #[doc = " @defgroup hal_i2c I2C Functions\n @ingroup hal_capi\n @{"]
    pub type HAL_I2CPort = i32;
    pub mod wpi {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_t_open0_volt_double_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_atomic_open0_bool__close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::atomic<bool>>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::atomic<bool>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_Color_allocator_open1_Color_close1_close0_instantiation()
    {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_Color_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
}
