/* automatically generated by rust-bindgen 0.60.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const HAL_kInvalidHandle: u32 = 0;
    pub const HAL_IO_CONFIG_DATA_SIZE: u32 = 32;
    pub const HAL_SYS_STATUS_DATA_SIZE: u32 = 44;
    pub const HAL_USER_STATUS_DATA_SIZE: u32 = 908;
    pub const HAL_kMaxJoystickAxes: u32 = 12;
    pub const HAL_kMaxJoystickPOVs: u32 = 12;
    pub const HAL_kMaxJoysticks: u32 = 6;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __int16_t = ::std::os::raw::c_short;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __int64_t = ::std::os::raw::c_long;
    pub type __uint64_t = ::std::os::raw::c_ulong;
    pub type __intmax_t = ::std::os::raw::c_long;
    pub type intmax_t = root::__intmax_t;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type size_t = ::std::os::raw::c_ulong;
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type false_type = u8;
        pub type __bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Tp> = _Tp;
        pub type __enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub type _TupleConstraints_is_constructible = root::std::__bool_constant;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        pub type tuple__TCC = u8;
        pub type tuple__ImplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ImplicitCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitCtor = root::std::__enable_if_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple__UseOtherCtor {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uniq_ptr_impl {
            pub _M_t: root::std::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uniq_ptr_impl__Ptr {
            pub _address: u8,
        }
        pub type __uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
        pub type __uniq_ptr_impl__DeleterConstraint = u8;
        pub type __uniq_ptr_impl_pointer = root::std::__uniq_ptr_impl__Ptr;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr {
            pub _M_t: u8,
        }
        pub type unique_ptr__DeleterConstraint = root::std::__uniq_ptr_impl;
        pub type unique_ptr_pointer = root::std::__uniq_ptr_impl;
        pub type unique_ptr_element_type<_Tp> = _Tp;
        pub type unique_ptr_deleter_type<_Dp> = _Dp;
        pub type unique_ptr___safe_conversion_up = root::std::__and_;
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::intmax_t;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::intmax_t;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ratio_multiply {
            pub _address: u8,
        }
        pub type __ratio_multiply_type = u8;
        pub type ratio_multiply = root::std::__ratio_multiply;
        pub type __ratio_add_impl___t = u8;
        pub type __ratio_add_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ratio_add {
            pub _address: u8,
        }
        pub type __ratio_add_type = u8;
        pub type ratio_add = root::std::__ratio_add;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod wpi {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub type span_storage_type = u8;
        pub type span_element_type<ElementType> = ElementType;
        pub type span_value_type = root::std::remove_cv;
        pub type span_size_type = root::std::size_t;
        pub type span_difference_type = isize;
        pub type span_pointer<ElementType> = *mut root::wpi::span_element_type<ElementType>;
        pub type span_const_pointer<ElementType> = *const root::wpi::span_element_type<ElementType>;
        pub type span_reference<ElementType> = *mut root::wpi::span_element_type<ElementType>;
        pub type span_const_reference<ElementType> =
            *const root::wpi::span_element_type<ElementType>;
        pub type span_iterator<ElementType> = root::wpi::span_pointer<ElementType>;
        pub type span_reverse_iterator<ElementType> =
            root::std::reverse_iterator<root::wpi::span_iterator<ElementType>>;
        pub type span_subspan_return_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SendableBuilder {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct Sendable__bindgen_vtable {
            pub Sendable_InitSendable:
                unsafe extern "C" fn(this: *mut Sendable, builder: *mut root::wpi::SendableBuilder),
        }
        #[doc = " Interface for Sendable objects."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Sendable {
            pub vtable_: *const Sendable__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_Sendable() {
            assert_eq!(
                ::std::mem::size_of::<Sendable>(),
                8usize,
                concat!("Size of: ", stringify!(Sendable))
            );
            assert_eq!(
                ::std::mem::align_of::<Sendable>(),
                8usize,
                concat!("Alignment of ", stringify!(Sendable))
            );
        }
        #[doc = " A helper class for use with objects that add themselves to SendableRegistry."]
        #[doc = " It takes care of properly calling Move() and Remove() on move and"]
        #[doc = " destruction.  No action is taken if the object is copied."]
        #[doc = " Use public inheritance with CRTP when using this class."]
        #[doc = " @tparam CRTP derived class"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SendableHelper {
            pub _address: u8,
        }
        pub mod support {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod hashing {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub type HAL_Handle = i32;
    pub type HAL_PortHandle = root::HAL_Handle;
    pub type HAL_AnalogInputHandle = root::HAL_Handle;
    pub type HAL_AnalogOutputHandle = root::HAL_Handle;
    pub type HAL_AnalogTriggerHandle = root::HAL_Handle;
    pub type HAL_CompressorHandle = root::HAL_Handle;
    pub type HAL_CounterHandle = root::HAL_Handle;
    pub type HAL_DigitalHandle = root::HAL_Handle;
    pub type HAL_DigitalPWMHandle = root::HAL_Handle;
    pub type HAL_EncoderHandle = root::HAL_Handle;
    pub type HAL_FPGAEncoderHandle = root::HAL_Handle;
    pub type HAL_GyroHandle = root::HAL_Handle;
    pub type HAL_InterruptHandle = root::HAL_Handle;
    pub type HAL_NotifierHandle = root::HAL_Handle;
    pub type HAL_RelayHandle = root::HAL_Handle;
    pub type HAL_SolenoidHandle = root::HAL_Handle;
    pub type HAL_SerialPortHandle = root::HAL_Handle;
    pub type HAL_CANHandle = root::HAL_Handle;
    pub type HAL_SimDeviceHandle = root::HAL_Handle;
    pub type HAL_SimValueHandle = root::HAL_Handle;
    pub type HAL_DMAHandle = root::HAL_Handle;
    pub type HAL_DutyCycleHandle = root::HAL_Handle;
    pub type HAL_AddressableLEDHandle = root::HAL_Handle;
    pub type HAL_PDPHandle = root::HAL_CANHandle;
    pub type HAL_PowerDistributionHandle = root::HAL_Handle;
    pub type HAL_CTREPCMHandle = root::HAL_Handle;
    pub type HAL_REVPDHHandle = root::HAL_Handle;
    pub type HAL_REVPHHandle = root::HAL_Handle;
    pub type HAL_Bool = i32;
    pub mod hal {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " C++ wrapper around a HAL simulator value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimValue {
            pub m_handle: root::HAL_SimValueHandle,
        }
        #[test]
        fn bindgen_test_layout_SimValue() {
            assert_eq!(
                ::std::mem::size_of::<SimValue>(),
                4usize,
                concat!("Size of: ", stringify!(SimValue))
            );
            assert_eq!(
                ::std::mem::align_of::<SimValue>(),
                4usize,
                concat!("Alignment of ", stringify!(SimValue))
            );
            fn test_field_m_handle() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SimValue>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SimValue),
                        "::",
                        stringify!(m_handle)
                    )
                );
            }
            test_field_m_handle();
        }
        #[doc = " C++ wrapper around a HAL simulator double value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimDouble {
            pub _base: root::hal::SimValue,
        }
        #[test]
        fn bindgen_test_layout_SimDouble() {
            assert_eq!(
                ::std::mem::size_of::<SimDouble>(),
                4usize,
                concat!("Size of: ", stringify!(SimDouble))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDouble>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDouble))
            );
        }
        #[doc = " A move-only C++ wrapper around a HAL simulator device handle."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SimDevice {
            pub m_handle: root::HAL_SimDeviceHandle,
        }
        pub const SimDevice_Direction_kInput: root::hal::SimDevice_Direction = 0;
        pub const SimDevice_Direction_kOutput: root::hal::SimDevice_Direction = 1;
        pub const SimDevice_Direction_kBidir: root::hal::SimDevice_Direction = 2;
        #[doc = " Direction of a simulated value (from the perspective of user code)."]
        pub type SimDevice_Direction = ::std::os::raw::c_uint;
        #[test]
        fn bindgen_test_layout_SimDevice() {
            assert_eq!(
                ::std::mem::size_of::<SimDevice>(),
                4usize,
                concat!("Size of: ", stringify!(SimDevice))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDevice>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDevice))
            );
            fn test_field_m_handle() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SimDevice>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SimDevice),
                        "::",
                        stringify!(m_handle)
                    )
                );
            }
            test_field_m_handle();
        }
        extern "C" {
            #[doc = " Creates a simulated device."]
            #[doc = ""]
            #[doc = " The device name must be unique.  Returns null if the device name"]
            #[doc = " already exists.  This is a convenience method that appends index in"]
            #[doc = " brackets to the device name, e.g. passing index=1 results in \"device[1]\""]
            #[doc = " for the device name."]
            #[doc = ""]
            #[doc = " If not in simulation, results in an \"empty\" object that evaluates to false"]
            #[doc = " in a boolean context."]
            #[doc = ""]
            #[doc = " @param name device name"]
            #[doc = " @param index device index number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKci"]
            pub fn SimDevice_SimDevice(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Creates a simulated device."]
            #[doc = ""]
            #[doc = " The device name must be unique.  Returns null if the device name"]
            #[doc = " already exists.  This is a convenience method that appends index and"]
            #[doc = " channel in brackets to the device name, e.g. passing index=1 and channel=2"]
            #[doc = " results in \"device[1,2]\" for the device name."]
            #[doc = ""]
            #[doc = " If not in simulation, results in an \"empty\" object that evaluates to false"]
            #[doc = " in a boolean context."]
            #[doc = ""]
            #[doc = " @param name device name"]
            #[doc = " @param index device index number to append to name"]
            #[doc = " @param channel device channel number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKcii"]
            pub fn SimDevice_SimDevice1(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            );
        }
        impl SimDevice {
            #[inline]
            pub unsafe fn new(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice(__bindgen_tmp.as_mut_ptr(), name, index);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice1(__bindgen_tmp.as_mut_ptr(), name, index, channel);
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " A move-only C++ wrapper around a HAL handle."]
        #[doc = " Does not ensure destruction."]
        pub type SPIPort = u32;
    }
    pub const HAL_Type_HAL_UNASSIGNED: root::HAL_Type = 0;
    pub const HAL_Type_HAL_BOOLEAN: root::HAL_Type = 1;
    pub const HAL_Type_HAL_DOUBLE: root::HAL_Type = 2;
    pub const HAL_Type_HAL_ENUM: root::HAL_Type = 4;
    pub const HAL_Type_HAL_INT: root::HAL_Type = 8;
    pub const HAL_Type_HAL_LONG: root::HAL_Type = 16;
    #[doc = " HAL data types."]
    pub type HAL_Type = ::std::os::raw::c_uint;
    #[doc = " HAL Entry Value.  Note this is a typed union."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct HAL_Value {
        pub data: root::HAL_Value__bindgen_ty_1,
        pub type_: root::HAL_Type,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union HAL_Value__bindgen_ty_1 {
        pub v_boolean: root::HAL_Bool,
        pub v_enum: i32,
        pub v_int: i32,
        pub v_long: i64,
        pub v_double: f64,
    }
    #[test]
    fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
        );
        fn test_field_v_boolean() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value__bindgen_ty_1),
                    "::",
                    stringify!(v_boolean)
                )
            );
        }
        test_field_v_boolean();
        fn test_field_v_enum() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).v_enum) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value__bindgen_ty_1),
                    "::",
                    stringify!(v_enum)
                )
            );
        }
        test_field_v_enum();
        fn test_field_v_int() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value__bindgen_ty_1),
                    "::",
                    stringify!(v_int)
                )
            );
        }
        test_field_v_int();
        fn test_field_v_long() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value__bindgen_ty_1),
                    "::",
                    stringify!(v_long)
                )
            );
        }
        test_field_v_long();
        fn test_field_v_double() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value__bindgen_ty_1>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value__bindgen_ty_1),
                    "::",
                    stringify!(v_double)
                )
            );
        }
        test_field_v_double();
    }
    #[test]
    fn bindgen_test_layout_HAL_Value() {
        assert_eq!(
            ::std::mem::size_of::<HAL_Value>(),
            16usize,
            concat!("Size of: ", stringify!(HAL_Value))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_Value>(),
            8usize,
            concat!("Alignment of ", stringify!(HAL_Value))
        );
        fn test_field_data() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value),
                    "::",
                    stringify!(data)
                )
            );
        }
        test_field_data();
        fn test_field_type() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_Value>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_Value),
                    "::",
                    stringify!(type_)
                )
            );
        }
        test_field_type();
    }
    #[doc = "< input to user code from the simulator"]
    pub const HAL_SimValueDirection_HAL_SimValueInput: root::HAL_SimValueDirection = 0;
    #[doc = "< output from user code to the simulator"]
    pub const HAL_SimValueDirection_HAL_SimValueOutput: root::HAL_SimValueDirection = 1;
    #[doc = "< bidirectional between user code and simulator"]
    pub const HAL_SimValueDirection_HAL_SimValueBidir: root::HAL_SimValueDirection = 2;
    #[doc = " Direction of a simulated value (from the perspective of user code)."]
    pub type HAL_SimValueDirection = i32;
    extern "C" {
        #[doc = " Creates a simulated device."]
        #[doc = ""]
        #[doc = " The device name must be unique.  0 is returned if the device name already"]
        #[doc = " exists.  If multiple instances of the same device are desired, recommend"]
        #[doc = " appending the instance/unique identifer in brackets to the base name,"]
        #[doc = " e.g. \"device[1]\"."]
        #[doc = ""]
        #[doc = " 0 is returned if not in simulation."]
        #[doc = ""]
        #[doc = " @param name device name"]
        #[doc = " @return simulated device handle"]
        pub fn HAL_CreateSimDevice(
            name: *const ::std::os::raw::c_char,
        ) -> root::HAL_SimDeviceHandle;
    }
    extern "C" {
        #[doc = " Frees a simulated device."]
        #[doc = ""]
        #[doc = " This also allows the same device name to be used again."]
        #[doc = " This also frees all the simulated values created on the device."]
        #[doc = ""]
        #[doc = " @param handle simulated device handle"]
        pub fn HAL_FreeSimDevice(handle: root::HAL_SimDeviceHandle);
    }
    extern "C" {
        #[doc = " Creates a value on a simulated device."]
        #[doc = ""]
        #[doc = " Returns 0 if not in simulation; this can be used to avoid calls"]
        #[doc = " to Set/Get functions."]
        #[doc = ""]
        #[doc = " @param device simulated device handle"]
        #[doc = " @param name value name"]
        #[doc = " @param direction input/output/bidir (from perspective of user code)"]
        #[doc = " @param initialValue initial value"]
        #[doc = " @return simulated value handle"]
        pub fn HAL_CreateSimValue(
            device: root::HAL_SimDeviceHandle,
            name: *const ::std::os::raw::c_char,
            direction: i32,
            initialValue: *const root::HAL_Value,
        ) -> root::HAL_SimValueHandle;
    }
    extern "C" {
        #[doc = " Creates an enumerated value on a simulated device."]
        #[doc = ""]
        #[doc = " Enumerated values are always in the range 0 to numOptions-1."]
        #[doc = ""]
        #[doc = " Returns 0 if not in simulation; this can be used to avoid calls"]
        #[doc = " to Set/Get functions."]
        #[doc = ""]
        #[doc = " @param device simulated device handle"]
        #[doc = " @param name value name"]
        #[doc = " @param direction input/output/bidir (from perspective of user code)"]
        #[doc = " @param numOptions number of enumerated value options (length of options)"]
        #[doc = " @param options array of option descriptions"]
        #[doc = " @param initialValue initial value (selection)"]
        #[doc = " @return simulated value handle"]
        pub fn HAL_CreateSimValueEnum(
            device: root::HAL_SimDeviceHandle,
            name: *const ::std::os::raw::c_char,
            direction: i32,
            numOptions: i32,
            options: *mut *const ::std::os::raw::c_char,
            initialValue: i32,
        ) -> root::HAL_SimValueHandle;
    }
    extern "C" {
        #[doc = " Creates an enumerated value on a simulated device with double values."]
        #[doc = ""]
        #[doc = " Enumerated values are always in the range 0 to numOptions-1."]
        #[doc = ""]
        #[doc = " Returns 0 if not in simulation; this can be used to avoid calls"]
        #[doc = " to Set/Get functions."]
        #[doc = ""]
        #[doc = " @param device simulated device handle"]
        #[doc = " @param name value name"]
        #[doc = " @param direction input/output/bidir (from perspective of user code)"]
        #[doc = " @param numOptions number of enumerated value options (length of options)"]
        #[doc = " @param options array of option descriptions"]
        #[doc = " @param optionValues array of option double values"]
        #[doc = " @param initialValue initial value (selection)"]
        #[doc = " @return simulated value handle"]
        pub fn HAL_CreateSimValueEnumDouble(
            device: root::HAL_SimDeviceHandle,
            name: *const ::std::os::raw::c_char,
            direction: i32,
            numOptions: i32,
            options: *mut *const ::std::os::raw::c_char,
            optionValues: *const f64,
            initialValue: i32,
        ) -> root::HAL_SimValueHandle;
    }
    extern "C" {
        #[doc = " Gets a simulated value."]
        #[doc = ""]
        #[doc = " @param handle simulated value handle"]
        #[doc = " @param value value (output parameter)"]
        pub fn HAL_GetSimValue(handle: root::HAL_SimValueHandle, value: *mut root::HAL_Value);
    }
    extern "C" {
        #[doc = " Sets a simulated value."]
        #[doc = ""]
        #[doc = " @param handle simulated value handle"]
        #[doc = " @param value the value to set"]
        pub fn HAL_SetSimValue(handle: root::HAL_SimValueHandle, value: *const root::HAL_Value);
    }
    extern "C" {
        #[doc = " Resets a simulated double or integral value to 0."]
        #[doc = " Has no effect on other value types."]
        #[doc = " Use this instead of Set(0) for resetting incremental sensor values like"]
        #[doc = " encoder counts or gyro accumulated angle to ensure correct behavior in a"]
        #[doc = " distributed system (e.g. WebSockets)."]
        #[doc = ""]
        #[doc = " @param handle simulated value handle"]
        pub fn HAL_ResetSimValue(handle: root::HAL_SimValueHandle);
    }
    pub mod fmt {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod units {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @brief\t\thelper type to identify base units."]
            #[doc = " @details\t\tA non-templated base class for `base_unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _base_unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__base_unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_base_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_base_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_base_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_base_unit_t))
                );
            }
            #[doc = " @brief\t\thelper type to identify units."]
            #[doc = " @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _unit {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__unit() {
                assert_eq!(
                    ::std::mem::size_of::<_unit>(),
                    1usize,
                    concat!("Size of: ", stringify!(_unit))
                );
                assert_eq!(
                    ::std::mem::align_of::<_unit>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_unit))
                );
            }
            #[doc = " @brief\t\thelper type to identify units."]
            #[doc = " @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_unit_t))
                );
            }
        }
        pub mod constants {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod traits {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @brief\t\tunit traits implementation for classes which are not units."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct unit_traits {
                pub _address: u8,
            }
            pub type unit_traits_base_unit_type = ::std::os::raw::c_void;
            pub type unit_traits_conversion_ratio = ::std::os::raw::c_void;
            pub type unit_traits_pi_exponent_ratio = ::std::os::raw::c_void;
            pub type unit_traits_translation_ratio = ::std::os::raw::c_void;
        }
        #[doc = " @ingroup\t\tUnitTypes"]
        #[doc = " @brief\t\tClass representing SI base unit types."]
        #[doc = " @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each"]
        #[doc = "\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second"]
        #[doc = "\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:"]
        #[doc = "\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`"]
        #[doc = " @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters."]
        #[doc = " @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms."]
        #[doc = " @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds."]
        #[doc = " @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars."]
        #[doc = " @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes."]
        #[doc = " @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin."]
        #[doc = " @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles."]
        #[doc = " @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas."]
        #[doc = " @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes."]
        #[doc = " @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct base_unit {
            pub _address: u8,
        }
        pub type base_unit_meter_ratio<Meter> = Meter;
        pub type base_unit_kilogram_ratio<Kilogram> = Kilogram;
        pub type base_unit_second_ratio<Second> = Second;
        pub type base_unit_radian_ratio<Radian> = Radian;
        pub type base_unit_ampere_ratio<Ampere> = Ampere;
        pub type base_unit_kelvin_ratio<Kelvin> = Kelvin;
        pub type base_unit_mole_ratio<Mole> = Mole;
        pub type base_unit_candela_ratio<Candela> = Candela;
        pub type base_unit_byte_ratio<Byte> = Byte;
        pub mod category {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @ingroup\t\tUnitTypes"]
            #[doc = " @brief\t\tClass representing SI base unit types."]
            #[doc = " @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each"]
            #[doc = "\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second"]
            #[doc = "\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:"]
            #[doc = "\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`"]
            #[doc = " @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters."]
            #[doc = " @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms."]
            #[doc = " @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds."]
            #[doc = " @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars."]
            #[doc = " @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes."]
            #[doc = " @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin."]
            #[doc = " @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles."]
            #[doc = " @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas."]
            #[doc = " @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes."]
            #[doc = " @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
            pub type time_unit = root::units::base_unit;
            #[doc = " @ingroup\t\tUnitTypes"]
            #[doc = " @brief\t\tClass representing SI base unit types."]
            #[doc = " @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each"]
            #[doc = "\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second"]
            #[doc = "\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:"]
            #[doc = "\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`"]
            #[doc = " @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters."]
            #[doc = " @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms."]
            #[doc = " @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds."]
            #[doc = " @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars."]
            #[doc = " @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes."]
            #[doc = " @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin."]
            #[doc = " @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles."]
            #[doc = " @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas."]
            #[doc = " @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes."]
            #[doc = " @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
            pub type angle_unit = root::units::base_unit;
        }
        #[doc = " @brief\t\tunit type template specialization for units derived from base units."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unit {
            pub _address: u8,
        }
        pub type unit_base_unit_type = root::units::traits::unit_traits;
        pub type unit_conversion_ratio = root::std::ratio_multiply;
        pub type unit_pi_exponent_ratio = root::std::ratio_add;
        pub type unit_translation_ratio = root::std::ratio_add;
        #[doc = " @ingroup\t\tUnitContainers"]
        #[doc = " @brief\t\tContainer for values which represent quantities of a given unit."]
        #[doc = " @details\t\tStores a value which represents a quantity in the given units. Unit containers"]
        #[doc = "\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to"]
        #[doc = "\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly"]
        #[doc = "\t\t\t\tconvertible to other compatible unit container types. Unit containers support"]
        #[doc = "\t\t\t\tvarious types of arithmetic operations, depending on their scale type."]
        #[doc = ""]
        #[doc = "\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment"]
        #[doc = "\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed"]
        #[doc = "\t\t\t\tusing `operator()`: @code"]
        #[doc = "\t\t\t\tmeter_t m(5.0);"]
        #[doc = "\t\t\t\tdouble val = m(); // val == 5.0\t@endcode."]
        #[doc = " @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)"]
        #[doc = " @tparam\t\tT underlying type of the storage. Defaults to double."]
        #[doc = " @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does"]
        #[doc = "\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,"]
        #[doc = "\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale"]
        #[doc = "\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`."]
        #[doc = " @sa"]
        #[doc = "\t\t\t\t- \\ref lengthContainers \"length unit containers\""]
        #[doc = "\t\t\t\t- \\ref massContainers \"mass unit containers\""]
        #[doc = "\t\t\t\t- \\ref timeContainers \"time unit containers\""]
        #[doc = "\t\t\t\t- \\ref angleContainers \"angle unit containers\""]
        #[doc = "\t\t\t\t- \\ref currentContainers \"current unit containers\""]
        #[doc = "\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\""]
        #[doc = "\t\t\t\t- \\ref substanceContainers \"substance unit containers\""]
        #[doc = "\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\""]
        #[doc = "\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\""]
        #[doc = "\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\""]
        #[doc = "\t\t\t\t- \\ref velocityContainers \"velocity unit containers\""]
        #[doc = "\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\""]
        #[doc = "\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\""]
        #[doc = "\t\t\t\t- \\ref forceContainers \"force unit containers\""]
        #[doc = "\t\t\t\t- \\ref pressureContainers \"pressure unit containers\""]
        #[doc = "\t\t\t\t- \\ref chargeContainers \"charge unit containers\""]
        #[doc = "\t\t\t\t- \\ref energyContainers \"energy unit containers\""]
        #[doc = "\t\t\t\t- \\ref powerContainers \"power unit containers\""]
        #[doc = "\t\t\t\t- \\ref voltageContainers \"voltage unit containers\""]
        #[doc = "\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\""]
        #[doc = "\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\""]
        #[doc = "\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\""]
        #[doc = "\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\""]
        #[doc = "\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\""]
        #[doc = "\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\""]
        #[doc = "\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\""]
        #[doc = "\t\t\t\t- \\ref radiationContainers \"radiation unit containers\""]
        #[doc = "\t\t\t\t- \\ref torqueContainers \"torque unit containers\""]
        #[doc = "\t\t\t\t- \\ref areaContainers \"area unit containers\""]
        #[doc = "\t\t\t\t- \\ref volumeContainers \"volume unit containers\""]
        #[doc = "\t\t\t\t- \\ref densityContainers \"density unit containers\""]
        #[doc = "\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\""]
        #[doc = "\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
        #[repr(C)]
        pub struct unit_t {
            pub _base: root::units::linear_scale<[u8; 0usize]>,
        }
        pub type unit_t_nls = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_non_linear_scale_type = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_underlying_type<T> = T;
        pub type unit_t_value_type<T> = T;
        pub type unit_t_unit_type<Units> = Units;
        #[doc = " @cond"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct linear_scale<T> {
            #[doc = "< linearized value."]
            pub m_value: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub mod time {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type seconds = u8;
            pub type second = root::units::time::seconds;
            #[doc = " @ingroup\t\tUnitContainers"]
            #[doc = " @brief\t\tContainer for values which represent quantities of a given unit."]
            #[doc = " @details\t\tStores a value which represents a quantity in the given units. Unit containers"]
            #[doc = "\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to"]
            #[doc = "\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly"]
            #[doc = "\t\t\t\tconvertible to other compatible unit container types. Unit containers support"]
            #[doc = "\t\t\t\tvarious types of arithmetic operations, depending on their scale type."]
            #[doc = ""]
            #[doc = "\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment"]
            #[doc = "\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed"]
            #[doc = "\t\t\t\tusing `operator()`: @code"]
            #[doc = "\t\t\t\tmeter_t m(5.0);"]
            #[doc = "\t\t\t\tdouble val = m(); // val == 5.0\t@endcode."]
            #[doc = " @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)"]
            #[doc = " @tparam\t\tT underlying type of the storage. Defaults to double."]
            #[doc = " @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does"]
            #[doc = "\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,"]
            #[doc = "\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale"]
            #[doc = "\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`."]
            #[doc = " @sa"]
            #[doc = "\t\t\t\t- \\ref lengthContainers \"length unit containers\""]
            #[doc = "\t\t\t\t- \\ref massContainers \"mass unit containers\""]
            #[doc = "\t\t\t\t- \\ref timeContainers \"time unit containers\""]
            #[doc = "\t\t\t\t- \\ref angleContainers \"angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref currentContainers \"current unit containers\""]
            #[doc = "\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\""]
            #[doc = "\t\t\t\t- \\ref substanceContainers \"substance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\""]
            #[doc = "\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\""]
            #[doc = "\t\t\t\t- \\ref velocityContainers \"velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\""]
            #[doc = "\t\t\t\t- \\ref forceContainers \"force unit containers\""]
            #[doc = "\t\t\t\t- \\ref pressureContainers \"pressure unit containers\""]
            #[doc = "\t\t\t\t- \\ref chargeContainers \"charge unit containers\""]
            #[doc = "\t\t\t\t- \\ref energyContainers \"energy unit containers\""]
            #[doc = "\t\t\t\t- \\ref powerContainers \"power unit containers\""]
            #[doc = "\t\t\t\t- \\ref voltageContainers \"voltage unit containers\""]
            #[doc = "\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\""]
            #[doc = "\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\""]
            #[doc = "\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\""]
            #[doc = "\t\t\t\t- \\ref radiationContainers \"radiation unit containers\""]
            #[doc = "\t\t\t\t- \\ref torqueContainers \"torque unit containers\""]
            #[doc = "\t\t\t\t- \\ref areaContainers \"area unit containers\""]
            #[doc = "\t\t\t\t- \\ref volumeContainers \"volume unit containers\""]
            #[doc = "\t\t\t\t- \\ref densityContainers \"density unit containers\""]
            #[doc = "\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\""]
            #[doc = "\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
            pub type second_t = root::units::unit_t;
        }
        pub mod angle {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type radians = u8;
            pub type radian = root::units::angle::radians;
            #[doc = " @ingroup\t\tUnitContainers"]
            #[doc = " @brief\t\tContainer for values which represent quantities of a given unit."]
            #[doc = " @details\t\tStores a value which represents a quantity in the given units. Unit containers"]
            #[doc = "\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to"]
            #[doc = "\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly"]
            #[doc = "\t\t\t\tconvertible to other compatible unit container types. Unit containers support"]
            #[doc = "\t\t\t\tvarious types of arithmetic operations, depending on their scale type."]
            #[doc = ""]
            #[doc = "\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment"]
            #[doc = "\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed"]
            #[doc = "\t\t\t\tusing `operator()`: @code"]
            #[doc = "\t\t\t\tmeter_t m(5.0);"]
            #[doc = "\t\t\t\tdouble val = m(); // val == 5.0\t@endcode."]
            #[doc = " @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)"]
            #[doc = " @tparam\t\tT underlying type of the storage. Defaults to double."]
            #[doc = " @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does"]
            #[doc = "\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,"]
            #[doc = "\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale"]
            #[doc = "\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`."]
            #[doc = " @sa"]
            #[doc = "\t\t\t\t- \\ref lengthContainers \"length unit containers\""]
            #[doc = "\t\t\t\t- \\ref massContainers \"mass unit containers\""]
            #[doc = "\t\t\t\t- \\ref timeContainers \"time unit containers\""]
            #[doc = "\t\t\t\t- \\ref angleContainers \"angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref currentContainers \"current unit containers\""]
            #[doc = "\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\""]
            #[doc = "\t\t\t\t- \\ref substanceContainers \"substance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\""]
            #[doc = "\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\""]
            #[doc = "\t\t\t\t- \\ref velocityContainers \"velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\""]
            #[doc = "\t\t\t\t- \\ref forceContainers \"force unit containers\""]
            #[doc = "\t\t\t\t- \\ref pressureContainers \"pressure unit containers\""]
            #[doc = "\t\t\t\t- \\ref chargeContainers \"charge unit containers\""]
            #[doc = "\t\t\t\t- \\ref energyContainers \"energy unit containers\""]
            #[doc = "\t\t\t\t- \\ref powerContainers \"power unit containers\""]
            #[doc = "\t\t\t\t- \\ref voltageContainers \"voltage unit containers\""]
            #[doc = "\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\""]
            #[doc = "\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\""]
            #[doc = "\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\""]
            #[doc = "\t\t\t\t- \\ref radiationContainers \"radiation unit containers\""]
            #[doc = "\t\t\t\t- \\ref torqueContainers \"torque unit containers\""]
            #[doc = "\t\t\t\t- \\ref areaContainers \"area unit containers\""]
            #[doc = "\t\t\t\t- \\ref volumeContainers \"volume unit containers\""]
            #[doc = "\t\t\t\t- \\ref densityContainers \"density unit containers\""]
            #[doc = "\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\""]
            #[doc = "\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
            pub type radian_t = root::units::unit_t;
            #[doc = " @brief\t\tunit type template specialization for units derived from base units."]
            pub type degrees = root::units::unit;
            #[doc = " @brief\t\tunit type template specialization for units derived from base units."]
            pub type degree = root::units::angle::degrees;
            #[doc = " @ingroup\t\tUnitContainers"]
            #[doc = " @brief\t\tContainer for values which represent quantities of a given unit."]
            #[doc = " @details\t\tStores a value which represents a quantity in the given units. Unit containers"]
            #[doc = "\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to"]
            #[doc = "\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly"]
            #[doc = "\t\t\t\tconvertible to other compatible unit container types. Unit containers support"]
            #[doc = "\t\t\t\tvarious types of arithmetic operations, depending on their scale type."]
            #[doc = ""]
            #[doc = "\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment"]
            #[doc = "\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed"]
            #[doc = "\t\t\t\tusing `operator()`: @code"]
            #[doc = "\t\t\t\tmeter_t m(5.0);"]
            #[doc = "\t\t\t\tdouble val = m(); // val == 5.0\t@endcode."]
            #[doc = " @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)"]
            #[doc = " @tparam\t\tT underlying type of the storage. Defaults to double."]
            #[doc = " @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does"]
            #[doc = "\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,"]
            #[doc = "\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale"]
            #[doc = "\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`."]
            #[doc = " @sa"]
            #[doc = "\t\t\t\t- \\ref lengthContainers \"length unit containers\""]
            #[doc = "\t\t\t\t- \\ref massContainers \"mass unit containers\""]
            #[doc = "\t\t\t\t- \\ref timeContainers \"time unit containers\""]
            #[doc = "\t\t\t\t- \\ref angleContainers \"angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref currentContainers \"current unit containers\""]
            #[doc = "\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\""]
            #[doc = "\t\t\t\t- \\ref substanceContainers \"substance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\""]
            #[doc = "\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\""]
            #[doc = "\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\""]
            #[doc = "\t\t\t\t- \\ref velocityContainers \"velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\""]
            #[doc = "\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\""]
            #[doc = "\t\t\t\t- \\ref forceContainers \"force unit containers\""]
            #[doc = "\t\t\t\t- \\ref pressureContainers \"pressure unit containers\""]
            #[doc = "\t\t\t\t- \\ref chargeContainers \"charge unit containers\""]
            #[doc = "\t\t\t\t- \\ref energyContainers \"energy unit containers\""]
            #[doc = "\t\t\t\t- \\ref powerContainers \"power unit containers\""]
            #[doc = "\t\t\t\t- \\ref voltageContainers \"voltage unit containers\""]
            #[doc = "\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\""]
            #[doc = "\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\""]
            #[doc = "\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\""]
            #[doc = "\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\""]
            #[doc = "\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\""]
            #[doc = "\t\t\t\t- \\ref radiationContainers \"radiation unit containers\""]
            #[doc = "\t\t\t\t- \\ref torqueContainers \"torque unit containers\""]
            #[doc = "\t\t\t\t- \\ref areaContainers \"area unit containers\""]
            #[doc = "\t\t\t\t- \\ref volumeContainers \"volume unit containers\""]
            #[doc = "\t\t\t\t- \\ref densityContainers \"density unit containers\""]
            #[doc = "\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\""]
            #[doc = "\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
            pub type degree_t = root::units::unit_t;
        }
    }
    pub mod frc {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const AnalogTriggerType_kInWindow: root::frc::AnalogTriggerType = 0;
        pub const AnalogTriggerType_kState: root::frc::AnalogTriggerType = 1;
        pub const AnalogTriggerType_kRisingPulse: root::frc::AnalogTriggerType = 2;
        pub const AnalogTriggerType_kFallingPulse: root::frc::AnalogTriggerType = 3;
        pub type AnalogTriggerType = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct DigitalSource__bindgen_vtable {
            pub DigitalSource_GetPortHandleForRouting:
                unsafe extern "C" fn(this: *const DigitalSource) -> root::HAL_Handle,
            pub DigitalSource_GetAnalogTriggerTypeForRouting:
                unsafe extern "C" fn(this: *const DigitalSource) -> root::frc::AnalogTriggerType,
            pub DigitalSource_IsAnalogTrigger:
                unsafe extern "C" fn(this: *const DigitalSource) -> bool,
            pub DigitalSource_GetChannel:
                unsafe extern "C" fn(this: *const DigitalSource) -> ::std::os::raw::c_int,
        }
        #[doc = " DigitalSource Interface."]
        #[doc = ""]
        #[doc = " The DigitalSource represents all the possible inputs for a counter or a"]
        #[doc = " quadrature encoder. The source may be either a digital input or an analog"]
        #[doc = " input. If the caller just provides a channel, then a digital input will be"]
        #[doc = " constructed and freed when finished for the source. The source can either be"]
        #[doc = " a digital input or analog trigger but not both."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DigitalSource {
            pub vtable_: *const DigitalSource__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_DigitalSource() {
            assert_eq!(
                ::std::mem::size_of::<DigitalSource>(),
                8usize,
                concat!("Size of: ", stringify!(DigitalSource))
            );
            assert_eq!(
                ::std::mem::align_of::<DigitalSource>(),
                8usize,
                concat!("Alignment of ", stringify!(DigitalSource))
            );
        }
        #[repr(C)]
        pub struct SPI__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " SPI bus interface class."]
        #[doc = ""]
        #[doc = " This class is intended to be used by sensor (and other SPI device) drivers."]
        #[doc = " It probably should not be used directly."]
        #[doc = ""]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SPI {
            pub vtable_: *const SPI__bindgen_vtable,
            pub m_port: root::hal::SPIPort,
            pub m_msbFirst: bool,
            pub m_sampleOnTrailing: bool,
            pub m_clockIdleHigh: bool,
            pub m_accum: root::std::unique_ptr,
        }
        pub const SPI_Port_kOnboardCS0: root::frc::SPI_Port = 0;
        pub const SPI_Port_kOnboardCS1: root::frc::SPI_Port = 1;
        pub const SPI_Port_kOnboardCS2: root::frc::SPI_Port = 2;
        pub const SPI_Port_kOnboardCS3: root::frc::SPI_Port = 3;
        pub const SPI_Port_kMXP: root::frc::SPI_Port = 4;
        pub type SPI_Port = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SPI_Accumulator {
            _unused: [u8; 0],
        }
        #[test]
        fn bindgen_test_layout_SPI() {
            assert_eq!(
                ::std::mem::size_of::<SPI>(),
                24usize,
                concat!("Size of: ", stringify!(SPI))
            );
            assert_eq!(
                ::std::mem::align_of::<SPI>(),
                8usize,
                concat!("Alignment of ", stringify!(SPI))
            );
            fn test_field_m_port() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SPI>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SPI),
                        "::",
                        stringify!(m_port)
                    )
                );
            }
            test_field_m_port();
            fn test_field_m_msbFirst() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SPI>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_msbFirst) as usize - ptr as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SPI),
                        "::",
                        stringify!(m_msbFirst)
                    )
                );
            }
            test_field_m_msbFirst();
            fn test_field_m_sampleOnTrailing() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SPI>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_sampleOnTrailing) as usize - ptr as usize
                    },
                    13usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SPI),
                        "::",
                        stringify!(m_sampleOnTrailing)
                    )
                );
            }
            test_field_m_sampleOnTrailing();
            fn test_field_m_clockIdleHigh() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SPI>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_clockIdleHigh) as usize - ptr as usize
                    },
                    14usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SPI),
                        "::",
                        stringify!(m_clockIdleHigh)
                    )
                );
            }
            test_field_m_clockIdleHigh();
            fn test_field_m_accum() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<SPI>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_accum) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SPI),
                        "::",
                        stringify!(m_accum)
                    )
                );
            }
            test_field_m_accum();
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK3frc3SPI7GetPortEv"]
            pub fn SPI_GetPort(this: *const root::frc::SPI) -> root::frc::SPI_Port;
        }
        extern "C" {
            #[doc = " Configure the rate of the generated clock signal."]
            #[doc = ""]
            #[doc = " The default value is 500,000Hz."]
            #[doc = " The maximum value is 4,000,000Hz."]
            #[doc = ""]
            #[doc = " @param hz The clock rate in Hertz."]
            #[link_name = "\u{1}_ZN3frc3SPI12SetClockRateEi"]
            pub fn SPI_SetClockRate(this: *mut root::frc::SPI, hz: ::std::os::raw::c_int);
        }
        extern "C" {
            #[doc = " Configure the order that bits are sent and received on the wire"]
            #[doc = " to be most significant bit first."]
            #[link_name = "\u{1}_ZN3frc3SPI11SetMSBFirstEv"]
            pub fn SPI_SetMSBFirst(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the order that bits are sent and received on the wire"]
            #[doc = " to be least significant bit first."]
            #[link_name = "\u{1}_ZN3frc3SPI11SetLSBFirstEv"]
            pub fn SPI_SetLSBFirst(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the leading edge and the data"]
            #[doc = " changes on the trailing edge."]
            #[link_name = "\u{1}_ZN3frc3SPI26SetSampleDataOnLeadingEdgeEv"]
            pub fn SPI_SetSampleDataOnLeadingEdge(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the trailing edge and the data"]
            #[doc = " changes on the leading edge."]
            #[link_name = "\u{1}_ZN3frc3SPI27SetSampleDataOnTrailingEdgeEv"]
            pub fn SPI_SetSampleDataOnTrailingEdge(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the falling edge and the data"]
            #[doc = " changes on the rising edge."]
            #[doc = ""]
            #[doc = " @deprecated Use SetSampleDataOnTrailingEdge() instead."]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3frc3SPI22SetSampleDataOnFallingEv"]
            pub fn SPI_SetSampleDataOnFalling(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the rising edge and the data"]
            #[doc = " changes on the falling edge."]
            #[doc = ""]
            #[doc = " @deprecated Use SetSampleDataOnLeadingEdge() instead."]
            #[doc = ""]
            #[link_name = "\u{1}_ZN3frc3SPI21SetSampleDataOnRisingEv"]
            pub fn SPI_SetSampleDataOnRising(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the clock output line to be active low."]
            #[doc = " This is sometimes called clock polarity high or clock idle high."]
            #[link_name = "\u{1}_ZN3frc3SPI17SetClockActiveLowEv"]
            pub fn SPI_SetClockActiveLow(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the clock output line to be active high."]
            #[doc = " This is sometimes called clock polarity low or clock idle low."]
            #[link_name = "\u{1}_ZN3frc3SPI18SetClockActiveHighEv"]
            pub fn SPI_SetClockActiveHigh(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the chip select line to be active high."]
            #[link_name = "\u{1}_ZN3frc3SPI23SetChipSelectActiveHighEv"]
            pub fn SPI_SetChipSelectActiveHigh(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the chip select line to be active low."]
            #[link_name = "\u{1}_ZN3frc3SPI22SetChipSelectActiveLowEv"]
            pub fn SPI_SetChipSelectActiveLow(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Initialize automatic SPI transfer engine."]
            #[doc = ""]
            #[doc = " Only a single engine is available, and use of it blocks use of all other"]
            #[doc = " chip select usage on the same physical SPI port while it is running."]
            #[doc = ""]
            #[doc = " @param bufferSize buffer size in bytes"]
            #[link_name = "\u{1}_ZN3frc3SPI8InitAutoEi"]
            pub fn SPI_InitAuto(this: *mut root::frc::SPI, bufferSize: ::std::os::raw::c_int);
        }
        extern "C" {
            #[doc = " Frees the automatic SPI transfer engine."]
            #[link_name = "\u{1}_ZN3frc3SPI8FreeAutoEv"]
            pub fn SPI_FreeAuto(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Set the data to be transmitted by the engine."]
            #[doc = ""]
            #[doc = " Up to 16 bytes are configurable, and may be followed by up to 127 zero"]
            #[doc = " bytes."]
            #[doc = ""]
            #[doc = " @param dataToSend data to send (maximum 16 bytes)"]
            #[doc = " @param zeroSize number of zeros to send after the data"]
            #[link_name = "\u{1}_ZN3frc3SPI19SetAutoTransmitDataEN3wpi4spanIKhLm18446744073709551615EEEi"]
            pub fn SPI_SetAutoTransmitData(
                this: *mut root::frc::SPI,
                dataToSend: u8,
                zeroSize: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Start running the automatic SPI transfer engine at a periodic rate."]
            #[doc = ""]
            #[doc = " InitAuto() and SetAutoTransmitData() must be called before calling this"]
            #[doc = " function."]
            #[doc = ""]
            #[doc = " @param period period between transfers (us resolution)"]
            #[link_name = "\u{1}_ZN3frc3SPI13StartAutoRateEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
            pub fn SPI_StartAutoRate(
                this: *mut root::frc::SPI,
                period: root::units::time::second_t,
            );
        }
        extern "C" {
            #[doc = " Start running the automatic SPI transfer engine at a periodic rate."]
            #[doc = ""]
            #[doc = " InitAuto() and SetAutoTransmitData() must be called before calling this"]
            #[doc = " function."]
            #[doc = ""]
            #[doc = " @deprecated use unit-safe StartAutoRate(units::second_t period) instead."]
            #[doc = ""]
            #[doc = " @param period period between transfers, in seconds (us resolution)"]
            #[link_name = "\u{1}_ZN3frc3SPI13StartAutoRateEd"]
            pub fn SPI_StartAutoRate1(this: *mut root::frc::SPI, period: f64);
        }
        extern "C" {
            #[doc = " Start running the automatic SPI transfer engine when a trigger occurs."]
            #[doc = ""]
            #[doc = " InitAuto() and SetAutoTransmitData() must be called before calling this"]
            #[doc = " function."]
            #[doc = ""]
            #[doc = " @param source digital source for the trigger (may be an analog trigger)"]
            #[doc = " @param rising trigger on the rising edge"]
            #[doc = " @param falling trigger on the falling edge"]
            #[link_name = "\u{1}_ZN3frc3SPI16StartAutoTriggerERNS_13DigitalSourceEbb"]
            pub fn SPI_StartAutoTrigger(
                this: *mut root::frc::SPI,
                source: *mut root::frc::DigitalSource,
                rising: bool,
                falling: bool,
            );
        }
        extern "C" {
            #[doc = " Stop running the automatic SPI transfer engine."]
            #[link_name = "\u{1}_ZN3frc3SPI8StopAutoEv"]
            pub fn SPI_StopAuto(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Force the engine to make a single transfer."]
            #[link_name = "\u{1}_ZN3frc3SPI13ForceAutoReadEv"]
            pub fn SPI_ForceAutoRead(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Read data that has been transferred by the automatic SPI transfer engine."]
            #[doc = ""]
            #[doc = " Transfers may be made a byte at a time, so it's necessary for the caller"]
            #[doc = " to handle cases where an entire transfer has not been completed."]
            #[doc = ""]
            #[doc = " Each received data sequence consists of a timestamp followed by the"]
            #[doc = " received data bytes, one byte per word (in the least significant byte)."]
            #[doc = " The length of each received data sequence is the same as the combined"]
            #[doc = " size of the data and zeroSize set in SetAutoTransmitData()."]
            #[doc = ""]
            #[doc = " Blocks until numToRead words have been read or timeout expires."]
            #[doc = " May be called with numToRead=0 to retrieve how many words are available."]
            #[doc = ""]
            #[doc = " @param buffer buffer where read words are stored"]
            #[doc = " @param numToRead number of words to read"]
            #[doc = " @param timeout timeout (ms resolution)"]
            #[doc = " @return Number of words remaining to be read"]
            #[link_name = "\u{1}_ZN3frc3SPI20ReadAutoReceivedDataEPjiN5units6unit_tINS2_4unitISt5ratioILl1ELl1EENS2_9base_unitIS5_ILl0ELl1EES8_S6_S8_S8_S8_S8_S8_S8_EES8_S8_EEdNS2_12linear_scaleEEE"]
            pub fn SPI_ReadAutoReceivedData(
                this: *mut root::frc::SPI,
                buffer: *mut u32,
                numToRead: ::std::os::raw::c_int,
                timeout: root::units::time::second_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the number of bytes dropped by the automatic SPI transfer engine due"]
            #[doc = " to the receive buffer being full."]
            #[doc = ""]
            #[doc = " @return Number of bytes dropped"]
            #[link_name = "\u{1}_ZN3frc3SPI19GetAutoDroppedCountEv"]
            pub fn SPI_GetAutoDroppedCount(this: *mut root::frc::SPI) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Configure the Auto SPI Stall time between reads."]
            #[doc = ""]
            #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
            #[doc = " MXP."]
            #[doc = " @param csToSclkTicks the number of ticks to wait before asserting the cs"]
            #[doc = " pin"]
            #[doc = " @param stallTicks the number of ticks to stall for"]
            #[doc = " @param pow2BytesPerRead the number of bytes to read before stalling"]
            #[link_name = "\u{1}_ZN3frc3SPI18ConfigureAutoStallE11HAL_SPIPortiii"]
            pub fn SPI_ConfigureAutoStall(
                this: *mut root::frc::SPI,
                port: root::HAL_SPIPort,
                csToSclkTicks: ::std::os::raw::c_int,
                stallTicks: ::std::os::raw::c_int,
                pow2BytesPerRead: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Initialize the accumulator."]
            #[doc = ""]
            #[doc = " @param period     Time between reads"]
            #[doc = " @param cmd        SPI command to send to request data"]
            #[doc = " @param xferSize   SPI transfer size, in bytes"]
            #[doc = " @param validMask  Mask to apply to received data for validity checking"]
            #[doc = " @param validValue After valid_mask is applied, required matching value for"]
            #[doc = "                   validity checking"]
            #[doc = " @param dataShift  Bit shift to apply to received data to get actual data"]
            #[doc = "                   value"]
            #[doc = " @param dataSize   Size (in bits) of data field"]
            #[doc = " @param isSigned   Is data field signed?"]
            #[doc = " @param bigEndian  Is device big endian?"]
            #[link_name = "\u{1}_ZN3frc3SPI15InitAccumulatorEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEEiiiiiibb"]
            pub fn SPI_InitAccumulator(
                this: *mut root::frc::SPI,
                period: root::units::time::second_t,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            );
        }
        extern "C" {
            #[doc = " Initialize the accumulator."]
            #[doc = ""]
            #[doc = " @deprecated Use unit-safe version instead."]
            #[doc = "             InitAccumulator(units::second_t period, int cmd, int <!--"]
            #[doc = " -->         xferSize, int validMask, int validValue, int dataShift, <!--"]
            #[doc = " -->         int dataSize, bool isSigned, bool bigEndian)"]
            #[doc = ""]
            #[doc = " @param period     Time between reads"]
            #[doc = " @param cmd        SPI command to send to request data"]
            #[doc = " @param xferSize   SPI transfer size, in bytes"]
            #[doc = " @param validMask  Mask to apply to received data for validity checking"]
            #[doc = " @param validValue After valid_mask is applied, required matching value for"]
            #[doc = "                   validity checking"]
            #[doc = " @param dataShift  Bit shift to apply to received data to get actual data"]
            #[doc = "                   value"]
            #[doc = " @param dataSize   Size (in bits) of data field"]
            #[doc = " @param isSigned   Is data field signed?"]
            #[doc = " @param bigEndian  Is device big endian?"]
            #[link_name = "\u{1}_ZN3frc3SPI15InitAccumulatorEdiiiiiibb"]
            pub fn SPI_InitAccumulator1(
                this: *mut root::frc::SPI,
                period: f64,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            );
        }
        extern "C" {
            #[doc = " Frees the accumulator."]
            #[link_name = "\u{1}_ZN3frc3SPI15FreeAccumulatorEv"]
            pub fn SPI_FreeAccumulator(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Resets the accumulator to zero."]
            #[link_name = "\u{1}_ZN3frc3SPI16ResetAccumulatorEv"]
            pub fn SPI_ResetAccumulator(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Set the center value of the accumulator."]
            #[doc = ""]
            #[doc = " The center value is subtracted from each value before it is added to the"]
            #[doc = " accumulator. This is used for the center value of devices like gyros and"]
            #[doc = " accelerometers to make integration work and to take the device offset into"]
            #[doc = " account when integrating."]
            #[link_name = "\u{1}_ZN3frc3SPI20SetAccumulatorCenterEi"]
            pub fn SPI_SetAccumulatorCenter(
                this: *mut root::frc::SPI,
                center: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Set the accumulator's deadband."]
            #[link_name = "\u{1}_ZN3frc3SPI22SetAccumulatorDeadbandEi"]
            pub fn SPI_SetAccumulatorDeadband(
                this: *mut root::frc::SPI,
                deadband: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Read the last value read by the accumulator engine."]
            #[link_name = "\u{1}_ZNK3frc3SPI23GetAccumulatorLastValueEv"]
            pub fn SPI_GetAccumulatorLastValue(
                this: *const root::frc::SPI,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Read the accumulated value."]
            #[doc = ""]
            #[doc = " @return The 64-bit value accumulated since the last Reset()."]
            #[link_name = "\u{1}_ZNK3frc3SPI19GetAccumulatorValueEv"]
            pub fn SPI_GetAccumulatorValue(this: *const root::frc::SPI) -> i64;
        }
        extern "C" {
            #[doc = " Read the number of accumulated values."]
            #[doc = ""]
            #[doc = " Read the count of the accumulated values since the accumulator was last"]
            #[doc = " Reset()."]
            #[doc = ""]
            #[doc = " @return The number of times samples from the channel were accumulated."]
            #[link_name = "\u{1}_ZNK3frc3SPI19GetAccumulatorCountEv"]
            pub fn SPI_GetAccumulatorCount(this: *const root::frc::SPI) -> i64;
        }
        extern "C" {
            #[doc = " Read the average of the accumulated value."]
            #[doc = ""]
            #[doc = " @return The accumulated average value (value / count)."]
            #[link_name = "\u{1}_ZNK3frc3SPI21GetAccumulatorAverageEv"]
            pub fn SPI_GetAccumulatorAverage(this: *const root::frc::SPI) -> f64;
        }
        extern "C" {
            #[doc = " Read the accumulated value and the number of accumulated values atomically."]
            #[doc = ""]
            #[doc = " This function reads the value and count atomically."]
            #[doc = " This can be used for averaging."]
            #[doc = ""]
            #[doc = " @param value Pointer to the 64-bit accumulated output."]
            #[doc = " @param count Pointer to the number of accumulation cycles."]
            #[link_name = "\u{1}_ZNK3frc3SPI20GetAccumulatorOutputERlS1_"]
            pub fn SPI_GetAccumulatorOutput(
                this: *const root::frc::SPI,
                value: *mut i64,
                count: *mut i64,
            );
        }
        extern "C" {
            #[doc = " Set the center value of the accumulator integrator."]
            #[doc = ""]
            #[doc = " The center value is subtracted from each value*dt before it is added to the"]
            #[doc = " integrated value. This is used for the center value of devices like gyros"]
            #[doc = " and accelerometers to take the device offset into account when integrating."]
            #[link_name = "\u{1}_ZN3frc3SPI30SetAccumulatorIntegratedCenterEd"]
            pub fn SPI_SetAccumulatorIntegratedCenter(this: *mut root::frc::SPI, center: f64);
        }
        extern "C" {
            #[doc = " Read the integrated value.  This is the sum of (each value * time between"]
            #[doc = " values)."]
            #[doc = ""]
            #[doc = " @return The integrated value accumulated since the last Reset()."]
            #[link_name = "\u{1}_ZNK3frc3SPI29GetAccumulatorIntegratedValueEv"]
            pub fn SPI_GetAccumulatorIntegratedValue(this: *const root::frc::SPI) -> f64;
        }
        extern "C" {
            #[doc = " Read the average of the integrated value.  This is the sum of (each value"]
            #[doc = " times the time between values), divided by the count."]
            #[doc = ""]
            #[doc = " @return The average of the integrated value accumulated since the last"]
            #[doc = "         Reset()."]
            #[link_name = "\u{1}_ZNK3frc3SPI31GetAccumulatorIntegratedAverageEv"]
            pub fn SPI_GetAccumulatorIntegratedAverage(this: *const root::frc::SPI) -> f64;
        }
        extern "C" {
            #[doc = " Constructor"]
            #[doc = ""]
            #[doc = " @param port the physical SPI port"]
            #[link_name = "\u{1}_ZN3frc3SPIC1ENS0_4PortE"]
            pub fn SPI_SPI(this: *mut root::frc::SPI, port: root::frc::SPI_Port);
        }
        impl SPI {
            #[inline]
            pub unsafe fn GetPort(&self) -> root::frc::SPI_Port {
                SPI_GetPort(self)
            }
            #[inline]
            pub unsafe fn SetClockRate(&mut self, hz: ::std::os::raw::c_int) {
                SPI_SetClockRate(self, hz)
            }
            #[inline]
            pub unsafe fn SetMSBFirst(&mut self) {
                SPI_SetMSBFirst(self)
            }
            #[inline]
            pub unsafe fn SetLSBFirst(&mut self) {
                SPI_SetLSBFirst(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnLeadingEdge(&mut self) {
                SPI_SetSampleDataOnLeadingEdge(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnTrailingEdge(&mut self) {
                SPI_SetSampleDataOnTrailingEdge(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnFalling(&mut self) {
                SPI_SetSampleDataOnFalling(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnRising(&mut self) {
                SPI_SetSampleDataOnRising(self)
            }
            #[inline]
            pub unsafe fn SetClockActiveLow(&mut self) {
                SPI_SetClockActiveLow(self)
            }
            #[inline]
            pub unsafe fn SetClockActiveHigh(&mut self) {
                SPI_SetClockActiveHigh(self)
            }
            #[inline]
            pub unsafe fn SetChipSelectActiveHigh(&mut self) {
                SPI_SetChipSelectActiveHigh(self)
            }
            #[inline]
            pub unsafe fn SetChipSelectActiveLow(&mut self) {
                SPI_SetChipSelectActiveLow(self)
            }
            #[inline]
            pub unsafe fn InitAuto(&mut self, bufferSize: ::std::os::raw::c_int) {
                SPI_InitAuto(self, bufferSize)
            }
            #[inline]
            pub unsafe fn FreeAuto(&mut self) {
                SPI_FreeAuto(self)
            }
            #[inline]
            pub unsafe fn SetAutoTransmitData(
                &mut self,
                dataToSend: u8,
                zeroSize: ::std::os::raw::c_int,
            ) {
                SPI_SetAutoTransmitData(self, dataToSend, zeroSize)
            }
            #[inline]
            pub unsafe fn StartAutoRate(&mut self, period: root::units::time::second_t) {
                SPI_StartAutoRate(self, period)
            }
            #[inline]
            pub unsafe fn StartAutoRate1(&mut self, period: f64) {
                SPI_StartAutoRate1(self, period)
            }
            #[inline]
            pub unsafe fn StartAutoTrigger(
                &mut self,
                source: *mut root::frc::DigitalSource,
                rising: bool,
                falling: bool,
            ) {
                SPI_StartAutoTrigger(self, source, rising, falling)
            }
            #[inline]
            pub unsafe fn StopAuto(&mut self) {
                SPI_StopAuto(self)
            }
            #[inline]
            pub unsafe fn ForceAutoRead(&mut self) {
                SPI_ForceAutoRead(self)
            }
            #[inline]
            pub unsafe fn ReadAutoReceivedData(
                &mut self,
                buffer: *mut u32,
                numToRead: ::std::os::raw::c_int,
                timeout: root::units::time::second_t,
            ) -> ::std::os::raw::c_int {
                SPI_ReadAutoReceivedData(self, buffer, numToRead, timeout)
            }
            #[inline]
            pub unsafe fn GetAutoDroppedCount(&mut self) -> ::std::os::raw::c_int {
                SPI_GetAutoDroppedCount(self)
            }
            #[inline]
            pub unsafe fn ConfigureAutoStall(
                &mut self,
                port: root::HAL_SPIPort,
                csToSclkTicks: ::std::os::raw::c_int,
                stallTicks: ::std::os::raw::c_int,
                pow2BytesPerRead: ::std::os::raw::c_int,
            ) {
                SPI_ConfigureAutoStall(self, port, csToSclkTicks, stallTicks, pow2BytesPerRead)
            }
            #[inline]
            pub unsafe fn InitAccumulator(
                &mut self,
                period: root::units::time::second_t,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            ) {
                SPI_InitAccumulator(
                    self, period, cmd, xferSize, validMask, validValue, dataShift, dataSize,
                    isSigned, bigEndian,
                )
            }
            #[inline]
            pub unsafe fn InitAccumulator1(
                &mut self,
                period: f64,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            ) {
                SPI_InitAccumulator1(
                    self, period, cmd, xferSize, validMask, validValue, dataShift, dataSize,
                    isSigned, bigEndian,
                )
            }
            #[inline]
            pub unsafe fn FreeAccumulator(&mut self) {
                SPI_FreeAccumulator(self)
            }
            #[inline]
            pub unsafe fn ResetAccumulator(&mut self) {
                SPI_ResetAccumulator(self)
            }
            #[inline]
            pub unsafe fn SetAccumulatorCenter(&mut self, center: ::std::os::raw::c_int) {
                SPI_SetAccumulatorCenter(self, center)
            }
            #[inline]
            pub unsafe fn SetAccumulatorDeadband(&mut self, deadband: ::std::os::raw::c_int) {
                SPI_SetAccumulatorDeadband(self, deadband)
            }
            #[inline]
            pub unsafe fn GetAccumulatorLastValue(&self) -> ::std::os::raw::c_int {
                SPI_GetAccumulatorLastValue(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorValue(&self) -> i64 {
                SPI_GetAccumulatorValue(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorCount(&self) -> i64 {
                SPI_GetAccumulatorCount(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorAverage(&self) -> f64 {
                SPI_GetAccumulatorAverage(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorOutput(&self, value: *mut i64, count: *mut i64) {
                SPI_GetAccumulatorOutput(self, value, count)
            }
            #[inline]
            pub unsafe fn SetAccumulatorIntegratedCenter(&mut self, center: f64) {
                SPI_SetAccumulatorIntegratedCenter(self, center)
            }
            #[inline]
            pub unsafe fn GetAccumulatorIntegratedValue(&self) -> f64 {
                SPI_GetAccumulatorIntegratedValue(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorIntegratedAverage(&self) -> f64 {
                SPI_GetAccumulatorIntegratedAverage(self)
            }
            #[inline]
            pub unsafe fn new(port: root::frc::SPI_Port) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SPI_SPI(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc3SPID1Ev"]
            pub fn SPI_SPI_destructor(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Write data to the peripheral device.  Blocks until there is space in the"]
            #[doc = " output FIFO."]
            #[doc = ""]
            #[doc = " If not running in output only mode, also saves the data received"]
            #[doc = " on the CIPO input during the transfer into the receive FIFO."]
            #[link_name = "\u{1}_ZN3frc3SPI5WriteEPhi"]
            pub fn SPI_Write(
                this: *mut ::std::os::raw::c_void,
                data: *mut u8,
                size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Read a word from the receive FIFO."]
            #[doc = ""]
            #[doc = " Waits for the current transfer to complete if the receive FIFO is empty."]
            #[doc = ""]
            #[doc = " If the receive FIFO is empty, there is no active transfer, and initiate"]
            #[doc = " is false, errors."]
            #[doc = ""]
            #[doc = " @param initiate     If true, this function pushes \"0\" into the transmit"]
            #[doc = "                     buffer and initiates a transfer. If false, this"]
            #[doc = "                     function assumes that data is already in the receive"]
            #[doc = "                     FIFO from a previous write."]
            #[doc = " @param dataReceived Buffer to receive data from the device"]
            #[doc = " @param size         The length of the transaction, in bytes"]
            #[link_name = "\u{1}_ZN3frc3SPI4ReadEbPhi"]
            pub fn SPI_Read(
                this: *mut ::std::os::raw::c_void,
                initiate: bool,
                dataReceived: *mut u8,
                size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Perform a simultaneous read/write transaction with the device"]
            #[doc = ""]
            #[doc = " @param dataToSend   The data to be written out to the device"]
            #[doc = " @param dataReceived Buffer to receive data from the device"]
            #[doc = " @param size         The length of the transaction, in bytes"]
            #[link_name = "\u{1}_ZN3frc3SPI11TransactionEPhS1_i"]
            pub fn SPI_Transaction(
                this: *mut ::std::os::raw::c_void,
                dataToSend: *mut u8,
                dataReceived: *mut u8,
                size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        #[doc = " A rotation in a 2d coordinate frame represented a point on the unit circle"]
        #[doc = " (cosine and sine)."]
        #[repr(C)]
        pub struct Rotation2d {
            pub m_value: root::units::angle::radian_t,
            pub m_cos: f64,
            pub m_sin: f64,
        }
        #[test]
        fn bindgen_test_layout_Rotation2d() {
            assert_eq!(
                ::std::mem::size_of::<Rotation2d>(),
                24usize,
                concat!("Size of: ", stringify!(Rotation2d))
            );
            assert_eq!(
                ::std::mem::align_of::<Rotation2d>(),
                8usize,
                concat!("Alignment of ", stringify!(Rotation2d))
            );
            fn test_field_m_value() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<Rotation2d>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Rotation2d),
                        "::",
                        stringify!(m_value)
                    )
                );
            }
            test_field_m_value();
            fn test_field_m_cos() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<Rotation2d>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_cos) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Rotation2d),
                        "::",
                        stringify!(m_cos)
                    )
                );
            }
            test_field_m_cos();
            fn test_field_m_sin() {
                assert_eq!(
                    unsafe {
                        let uninit = ::std::mem::MaybeUninit::<Rotation2d>::uninit();
                        let ptr = uninit.as_ptr();
                        ::std::ptr::addr_of!((*ptr).m_sin) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Rotation2d),
                        "::",
                        stringify!(m_sin)
                    )
                );
            }
            test_field_m_sin();
        }
        extern "C" {
            #[doc = " Adds the new rotation to the current rotation using a rotation matrix."]
            #[doc = ""]
            #[doc = " <pre>"]
            #[doc = " [cos_new]   [other.cos, -other.sin][cos]"]
            #[doc = " [sin_new] = [other.sin,  other.cos][sin]"]
            #[doc = " value_new = std::atan2(sin_new, cos_new)"]
            #[doc = " </pre>"]
            #[doc = ""]
            #[doc = " @param other The rotation to rotate by."]
            #[doc = ""]
            #[doc = " @return The new rotated Rotation2d."]
            #[link_name = "\u{1}_ZNK3frc10Rotation2d8RotateByERKS0_"]
            pub fn Rotation2d_RotateBy(
                this: *const root::frc::Rotation2d,
                other: *const root::frc::Rotation2d,
            ) -> root::frc::Rotation2d;
        }
        extern "C" {
            #[doc = " Constructs a Rotation2d with the given radian value."]
            #[doc = ""]
            #[doc = " @param value The value of the angle in radians."]
            #[link_name = "\u{1}_ZN3frc10Rotation2dC1EN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S7_S5_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
            pub fn Rotation2d_Rotation2d(
                this: *mut root::frc::Rotation2d,
                value: root::units::angle::radian_t,
            );
        }
        extern "C" {
            #[doc = " Constructs a Rotation2d with the given degree value."]
            #[doc = ""]
            #[doc = " @param value The value of the angle in degrees."]
            #[link_name = "\u{1}_ZN3frc10Rotation2dC1EN5units6unit_tINS1_4unitISt5ratioILl1ELl180EENS3_IS4_ILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES8_S8_S6_S8_S8_S8_S8_S8_EES8_S8_EES6_S8_EEdNS1_12linear_scaleEEE"]
            pub fn Rotation2d_Rotation2d1(
                this: *mut root::frc::Rotation2d,
                value: root::units::angle::degree_t,
            );
        }
        extern "C" {
            #[doc = " Constructs a Rotation2d with the given x and y (cosine and sine)"]
            #[doc = " components. The x and y don't have to be normalized."]
            #[doc = ""]
            #[doc = " @param x The x component or cosine of the rotation."]
            #[doc = " @param y The y component or sine of the rotation."]
            #[link_name = "\u{1}_ZN3frc10Rotation2dC1Edd"]
            pub fn Rotation2d_Rotation2d2(this: *mut root::frc::Rotation2d, x: f64, y: f64);
        }
        impl Rotation2d {
            #[inline]
            pub unsafe fn RotateBy(
                &self,
                other: *const root::frc::Rotation2d,
            ) -> root::frc::Rotation2d {
                Rotation2d_RotateBy(self, other)
            }
            #[inline]
            pub unsafe fn new(value: root::units::angle::radian_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Rotation2d_Rotation2d(__bindgen_tmp.as_mut_ptr(), value);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(value: root::units::angle::degree_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Rotation2d_Rotation2d1(__bindgen_tmp.as_mut_ptr(), value);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(x: f64, y: f64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Rotation2d_Rotation2d2(__bindgen_tmp.as_mut_ptr(), x, y);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct Gyro__bindgen_vtable {
            pub Gyro_Calibrate: unsafe extern "C" fn(this: *mut Gyro),
            pub Gyro_Reset: unsafe extern "C" fn(this: *mut Gyro),
            pub Gyro_GetAngle: unsafe extern "C" fn(this: *const Gyro) -> f64,
            pub Gyro_GetRate: unsafe extern "C" fn(this: *const Gyro) -> f64,
        }
        #[doc = " Interface for yaw rate gyros."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Gyro {
            pub vtable_: *const Gyro__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_Gyro() {
            assert_eq!(
                ::std::mem::size_of::<Gyro>(),
                8usize,
                concat!("Size of: ", stringify!(Gyro))
            );
            assert_eq!(
                ::std::mem::align_of::<Gyro>(),
                8usize,
                concat!("Alignment of ", stringify!(Gyro))
            );
        }
        #[doc = " Use a rate gyro to return the robots heading relative to a starting position."]
        #[doc = ""]
        #[doc = " The %Gyro class tracks the robots heading based on the starting position. As"]
        #[doc = " the robot rotates the new heading is computed by integrating the rate of"]
        #[doc = " rotation returned by the sensor. When the class is instantiated, it does a"]
        #[doc = " short calibration routine where it samples the gyro while at rest to"]
        #[doc = " determine the default offset. This is subtracted from each sample to"]
        #[doc = " determine the heading."]
        #[doc = ""]
        #[doc = " This class is for the digital ADXRS450 gyro sensor that connects via SPI."]
        #[doc = " Only one instance of an ADXRS %Gyro is supported."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ADXRS450_Gyro {
            pub _base: root::frc::Gyro,
            pub _base_1: root::wpi::Sendable,
            pub m_spi: root::frc::SPI,
            pub m_port: root::frc::SPI_Port,
            pub m_simDevice: root::hal::SimDevice,
            pub m_simAngle: root::hal::SimDouble,
            pub m_simRate: root::hal::SimDouble,
        }
        #[test]
        fn bindgen_test_layout_ADXRS450_Gyro() {
            assert_eq!(
                ::std::mem::size_of::<ADXRS450_Gyro>(),
                56usize,
                concat!("Size of: ", stringify!(ADXRS450_Gyro))
            );
            assert_eq!(
                ::std::mem::align_of::<ADXRS450_Gyro>(),
                8usize,
                concat!("Alignment of ", stringify!(ADXRS450_Gyro))
            );
        }
        extern "C" {
            #[doc = " Get the SPI port number."]
            #[doc = ""]
            #[doc = " @return The SPI port number."]
            #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro7GetPortEv"]
            pub fn ADXRS450_Gyro_GetPort(
                this: *const root::frc::ADXRS450_Gyro,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " %Gyro constructor on onboard CS0."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_GyroC1Ev"]
            pub fn ADXRS450_Gyro_ADXRS450_Gyro(this: *mut root::frc::ADXRS450_Gyro);
        }
        extern "C" {
            #[doc = " %Gyro constructor on the specified SPI port."]
            #[doc = ""]
            #[doc = " @param port The SPI port the gyro is attached to."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_GyroC1ENS_3SPI4PortE"]
            pub fn ADXRS450_Gyro_ADXRS450_Gyro1(
                this: *mut root::frc::ADXRS450_Gyro,
                port: root::frc::SPI_Port,
            );
        }
        impl ADXRS450_Gyro {
            #[inline]
            pub unsafe fn GetPort(&self) -> ::std::os::raw::c_int {
                ADXRS450_Gyro_GetPort(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ADXRS450_Gyro_ADXRS450_Gyro(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(port: root::frc::SPI_Port) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ADXRS450_Gyro_ADXRS450_Gyro1(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[doc = " Return the actual angle in degrees that the robot is currently facing."]
            #[doc = ""]
            #[doc = " The angle is based on integration of the returned rate from the gyro."]
            #[doc = " The angle is continuous, that is it will continue from 360->361 degrees."]
            #[doc = " This allows algorithms that wouldn't want to see a discontinuity in the"]
            #[doc = " gyro output as it sweeps from 360 to 0 on the second time around."]
            #[doc = ""]
            #[doc = " @return the current heading of the robot in degrees."]
            #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro8GetAngleEv"]
            pub fn ADXRS450_Gyro_GetAngle(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Return the rate of rotation of the gyro"]
            #[doc = ""]
            #[doc = " The rate is based on the most recent reading of the gyro."]
            #[doc = ""]
            #[doc = " @return the current rate in degrees per second"]
            #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro7GetRateEv"]
            pub fn ADXRS450_Gyro_GetRate(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Reset the gyro."]
            #[doc = ""]
            #[doc = " Resets the gyro to a heading of zero. This can be used if there is"]
            #[doc = " significant drift in the gyro and it needs to be recalibrated after it has"]
            #[doc = " been running."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_Gyro5ResetEv"]
            pub fn ADXRS450_Gyro_Reset(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Initialize the gyro."]
            #[doc = ""]
            #[doc = " Calibrate the gyro by running for a number of samples and computing the"]
            #[doc = " center value. Then use the center value as the Accumulator center value for"]
            #[doc = " subsequent measurements."]
            #[doc = ""]
            #[doc = " It's important to make sure that the robot is not moving while the"]
            #[doc = " centering calculations are in progress, this is typically done when the"]
            #[doc = " robot is first turned on while it's sitting at rest before the competition"]
            #[doc = " starts."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_Gyro9CalibrateEv"]
            pub fn ADXRS450_Gyro_Calibrate(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZThn8_N3frc13ADXRS450_Gyro12InitSendableERN3wpi15SendableBuilderE"]
            pub fn ADXRS450_Gyro_InitSendable(
                this: *mut ::std::os::raw::c_void,
                builder: *mut root::wpi::SendableBuilder,
            );
        }
    }
    pub const HAL_SPIPort_HAL_SPI_kInvalid: root::HAL_SPIPort = -1;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS0: root::HAL_SPIPort = 0;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS1: root::HAL_SPIPort = 1;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS2: root::HAL_SPIPort = 2;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS3: root::HAL_SPIPort = 3;
    pub const HAL_SPIPort_HAL_SPI_kMXP: root::HAL_SPIPort = 4;
    #[doc = " @defgroup hal_spi SPI Functions"]
    #[doc = " @ingroup hal_capi"]
    #[doc = " @{"]
    pub type HAL_SPIPort = i32;
    pub const HAL_I2CPort_HAL_I2C_kInvalid: root::HAL_I2CPort = -1;
    pub const HAL_I2CPort_HAL_I2C_kOnboard: root::HAL_I2CPort = 0;
    pub const HAL_I2CPort_HAL_I2C_kMXP: root::HAL_I2CPort = 1;
    #[doc = " @defgroup hal_i2c I2C Functions"]
    #[doc = " @ingroup hal_capi"]
    #[doc = " @{"]
    pub type HAL_I2CPort = i32;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kBroadcast: root::HAL_CANDeviceType = 0;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kRobotController: root::HAL_CANDeviceType = 1;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kMotorController: root::HAL_CANDeviceType = 2;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kRelayController: root::HAL_CANDeviceType = 3;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kGyroSensor: root::HAL_CANDeviceType = 4;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kAccelerometer: root::HAL_CANDeviceType = 5;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kUltrasonicSensor: root::HAL_CANDeviceType = 6;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kGearToothSensor: root::HAL_CANDeviceType = 7;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kPowerDistribution: root::HAL_CANDeviceType = 8;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kPneumatics: root::HAL_CANDeviceType = 9;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kMiscellaneous: root::HAL_CANDeviceType = 10;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kIOBreakout: root::HAL_CANDeviceType = 11;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kFirmwareUpdate: root::HAL_CANDeviceType = 31;
    #[doc = " The CAN device type."]
    #[doc = ""]
    #[doc = " Teams should use HAL_CAN_Dev_kMiscellaneous"]
    pub type HAL_CANDeviceType = i32;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kBroadcast: root::HAL_CANManufacturer = 0;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kNI: root::HAL_CANManufacturer = 1;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kLM: root::HAL_CANManufacturer = 2;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kDEKA: root::HAL_CANManufacturer = 3;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kCTRE: root::HAL_CANManufacturer = 4;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kREV: root::HAL_CANManufacturer = 5;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kGrapple: root::HAL_CANManufacturer = 6;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kMS: root::HAL_CANManufacturer = 7;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kTeamUse: root::HAL_CANManufacturer = 8;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kKauaiLabs: root::HAL_CANManufacturer = 9;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kCopperforge: root::HAL_CANManufacturer = 10;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kPWF: root::HAL_CANManufacturer = 11;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kStudica: root::HAL_CANManufacturer = 12;
    #[doc = " The CAN manufacturer ID."]
    #[doc = ""]
    #[doc = " Teams should use HAL_CAN_Man_kTeamUse."]
    pub type HAL_CANManufacturer = i32;
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_ControlWord {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[test]
    fn bindgen_test_layout_HAL_ControlWord() {
        assert_eq!(
            ::std::mem::size_of::<HAL_ControlWord>(),
            4usize,
            concat!("Size of: ", stringify!(HAL_ControlWord))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_ControlWord>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_ControlWord))
        );
    }
    impl HAL_ControlWord {
        #[inline]
        pub fn enabled(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_enabled(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn autonomous(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_autonomous(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn test(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_test(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn eStop(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_eStop(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn fmsAttached(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_fmsAttached(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dsAttached(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_dsAttached(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn control_reserved(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
        }
        #[inline]
        pub fn set_control_reserved(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(6usize, 26u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            enabled: u32,
            autonomous: u32,
            test: u32,
            eStop: u32,
            fmsAttached: u32,
            dsAttached: u32,
            control_reserved: u32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
                enabled as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
                autonomous as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let test: u32 = unsafe { ::std::mem::transmute(test) };
                test as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
                eStop as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
                fmsAttached as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
                dsAttached as u64
            });
            __bindgen_bitfield_unit.set(6usize, 26u8, {
                let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
                control_reserved as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed1: root::HAL_AllianceStationID = 0;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed2: root::HAL_AllianceStationID = 1;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed3: root::HAL_AllianceStationID = 2;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue1: root::HAL_AllianceStationID = 3;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue2: root::HAL_AllianceStationID = 4;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue3: root::HAL_AllianceStationID = 5;
    pub type HAL_AllianceStationID = i32;
    pub const HAL_MatchType_HAL_kMatchType_none: root::HAL_MatchType = 0;
    pub const HAL_MatchType_HAL_kMatchType_practice: root::HAL_MatchType = 1;
    pub const HAL_MatchType_HAL_kMatchType_qualification: root::HAL_MatchType = 2;
    pub const HAL_MatchType_HAL_kMatchType_elimination: root::HAL_MatchType = 3;
    pub type HAL_MatchType = i32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickAxes {
        pub count: i16,
        pub axes: [f32; 12usize],
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickAxes() {
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickAxes>(),
            52usize,
            concat!("Size of: ", stringify!(HAL_JoystickAxes))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickAxes>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_JoystickAxes))
        );
        fn test_field_count() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickAxes>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickAxes),
                    "::",
                    stringify!(count)
                )
            );
        }
        test_field_count();
        fn test_field_axes() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickAxes>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickAxes),
                    "::",
                    stringify!(axes)
                )
            );
        }
        test_field_axes();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickPOVs {
        pub count: i16,
        pub povs: [i16; 12usize],
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickPOVs() {
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickPOVs>(),
            26usize,
            concat!("Size of: ", stringify!(HAL_JoystickPOVs))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickPOVs>(),
            2usize,
            concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
        );
        fn test_field_count() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickPOVs>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickPOVs),
                    "::",
                    stringify!(count)
                )
            );
        }
        test_field_count();
        fn test_field_povs() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickPOVs>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize
                },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickPOVs),
                    "::",
                    stringify!(povs)
                )
            );
        }
        test_field_povs();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickButtons {
        pub buttons: u32,
        pub count: u8,
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickButtons() {
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickButtons>(),
            8usize,
            concat!("Size of: ", stringify!(HAL_JoystickButtons))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickButtons>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_JoystickButtons))
        );
        fn test_field_buttons() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickButtons>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickButtons),
                    "::",
                    stringify!(buttons)
                )
            );
        }
        test_field_buttons();
        fn test_field_count() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickButtons>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickButtons),
                    "::",
                    stringify!(count)
                )
            );
        }
        test_field_count();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickDescriptor {
        pub isXbox: u8,
        pub type_: u8,
        pub name: [::std::os::raw::c_char; 256usize],
        pub axisCount: u8,
        pub axisTypes: [u8; 12usize],
        pub buttonCount: u8,
        pub povCount: u8,
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickDescriptor() {
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickDescriptor>(),
            273usize,
            concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickDescriptor>(),
            1usize,
            concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
        );
        fn test_field_isXbox() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).isXbox) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(isXbox)
                )
            );
        }
        test_field_isXbox();
        fn test_field_type() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
                },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(type_)
                )
            );
        }
        test_field_type();
        fn test_field_name() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
                },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(name)
                )
            );
        }
        test_field_name();
        fn test_field_axisCount() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).axisCount) as usize - ptr as usize
                },
                258usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(axisCount)
                )
            );
        }
        test_field_axisCount();
        fn test_field_axisTypes() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).axisTypes) as usize - ptr as usize
                },
                259usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(axisTypes)
                )
            );
        }
        test_field_axisTypes();
        fn test_field_buttonCount() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).buttonCount) as usize - ptr as usize
                },
                271usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(buttonCount)
                )
            );
        }
        test_field_buttonCount();
        fn test_field_povCount() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_JoystickDescriptor>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).povCount) as usize - ptr as usize
                },
                272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_JoystickDescriptor),
                    "::",
                    stringify!(povCount)
                )
            );
        }
        test_field_povCount();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_MatchInfo {
        pub eventName: [::std::os::raw::c_char; 64usize],
        pub matchType: root::HAL_MatchType,
        pub matchNumber: u16,
        pub replayNumber: u8,
        pub gameSpecificMessage: [u8; 64usize],
        pub gameSpecificMessageSize: u16,
    }
    #[test]
    fn bindgen_test_layout_HAL_MatchInfo() {
        assert_eq!(
            ::std::mem::size_of::<HAL_MatchInfo>(),
            140usize,
            concat!("Size of: ", stringify!(HAL_MatchInfo))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_MatchInfo>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_MatchInfo))
        );
        fn test_field_eventName() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_MatchInfo>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).eventName) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_MatchInfo),
                    "::",
                    stringify!(eventName)
                )
            );
        }
        test_field_eventName();
        fn test_field_matchType() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_MatchInfo>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).matchType) as usize - ptr as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_MatchInfo),
                    "::",
                    stringify!(matchType)
                )
            );
        }
        test_field_matchType();
        fn test_field_matchNumber() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_MatchInfo>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).matchNumber) as usize - ptr as usize
                },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_MatchInfo),
                    "::",
                    stringify!(matchNumber)
                )
            );
        }
        test_field_matchNumber();
        fn test_field_replayNumber() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_MatchInfo>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).replayNumber) as usize - ptr as usize
                },
                70usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_MatchInfo),
                    "::",
                    stringify!(replayNumber)
                )
            );
        }
        test_field_replayNumber();
        fn test_field_gameSpecificMessage() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_MatchInfo>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).gameSpecificMessage) as usize - ptr as usize
                },
                71usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_MatchInfo),
                    "::",
                    stringify!(gameSpecificMessage)
                )
            );
        }
        test_field_gameSpecificMessage();
        fn test_field_gameSpecificMessageSize() {
            assert_eq!(
                unsafe {
                    let uninit = ::std::mem::MaybeUninit::<HAL_MatchInfo>::uninit();
                    let ptr = uninit.as_ptr();
                    ::std::ptr::addr_of!((*ptr).gameSpecificMessageSize) as usize - ptr as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HAL_MatchInfo),
                    "::",
                    stringify!(gameSpecificMessageSize)
                )
            );
        }
        test_field_gameSpecificMessageSize();
    }
    extern "C" {
        #[doc = " Sends an error to the driver station."]
        #[doc = ""]
        #[doc = " @param isError   true for error, false for warning"]
        #[doc = " @param errorCode the error code"]
        #[doc = " @param isLVCode  true for a LV error code, false for a standard error code"]
        #[doc = " @param details   the details of the error"]
        #[doc = " @param location  the file location of the errror"]
        #[doc = " @param callStack the callstack of the error"]
        #[doc = " @param printMsg  true to print the error message to stdout as well as to the"]
        #[doc = " DS"]
        pub fn HAL_SendError(
            isError: root::HAL_Bool,
            errorCode: i32,
            isLVCode: root::HAL_Bool,
            details: *const ::std::os::raw::c_char,
            location: *const ::std::os::raw::c_char,
            callStack: *const ::std::os::raw::c_char,
            printMsg: root::HAL_Bool,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Sends a line to the driver station console."]
        #[doc = ""]
        #[doc = " @param line the line to send (null terminated)"]
        pub fn HAL_SendConsoleLine(line: *const ::std::os::raw::c_char) -> i32;
    }
    extern "C" {
        #[doc = " Gets the current control word of the driver station."]
        #[doc = ""]
        #[doc = " The control work contains the robot state."]
        #[doc = ""]
        #[doc = " @param controlWord the control word (out)"]
        #[doc = " @return the error code, or 0 for success"]
        pub fn HAL_GetControlWord(controlWord: *mut root::HAL_ControlWord) -> i32;
    }
    extern "C" {
        #[doc = " Gets the current alliance station ID."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return the alliance station ID"]
        pub fn HAL_GetAllianceStation(status: *mut i32) -> root::HAL_AllianceStationID;
    }
    extern "C" {
        #[doc = " Gets the axes of a specific joystick."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @param axes        the axes values (output)"]
        #[doc = " @return the error code, or 0 for success"]
        pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut root::HAL_JoystickAxes) -> i32;
    }
    extern "C" {
        #[doc = " Gets the POVs of a specific joystick."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @param povs        the POV values (output)"]
        #[doc = " @return the error code, or 0 for success"]
        pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut root::HAL_JoystickPOVs) -> i32;
    }
    extern "C" {
        #[doc = " Gets the buttons of a specific joystick."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @param buttons     the button values (output)"]
        #[doc = " @return the error code, or 0 for success"]
        pub fn HAL_GetJoystickButtons(
            joystickNum: i32,
            buttons: *mut root::HAL_JoystickButtons,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Retrieves the Joystick Descriptor for particular slot."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @param[out] desc   descriptor (data transfer object) to fill in. desc is"]
        #[doc = "                    filled in regardless of success. In other words, if"]
        #[doc = "                    descriptor is not available, desc is filled in with"]
        #[doc = "                    default values matching the init-values in Java and C++"]
        #[doc = "                    Driver Station for when caller requests a too-large"]
        #[doc = "                    joystick index."]
        #[doc = " @return error code reported from Network Comm back-end.  Zero is good,"]
        #[doc = "         nonzero is bad."]
        pub fn HAL_GetJoystickDescriptor(
            joystickNum: i32,
            desc: *mut root::HAL_JoystickDescriptor,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Gets is a specific joystick is considered to be an XBox controller."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @return true if xbox, false otherwise"]
        pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets the type of joystick connected."]
        #[doc = ""]
        #[doc = " This is device specific, and different depending on what system input type"]
        #[doc = " the joystick uses."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @return the enumerated joystick type"]
        pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
    }
    extern "C" {
        #[doc = " Gets the name of a joystick."]
        #[doc = ""]
        #[doc = " The returned array must be freed with HAL_FreeJoystickName."]
        #[doc = ""]
        #[doc = " Will be null terminated."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @return the joystick name"]
        pub fn HAL_GetJoystickName(joystickNum: i32) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Frees a joystick name received with HAL_GetJoystickName"]
        #[doc = ""]
        #[doc = " @param name the name storage"]
        pub fn HAL_FreeJoystickName(name: *mut ::std::os::raw::c_char);
    }
    extern "C" {
        #[doc = " Gets the type of a specific joystick axis."]
        #[doc = ""]
        #[doc = " This is device specific, and different depending on what system input type"]
        #[doc = " the joystick uses."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @param axis        the axis number"]
        #[doc = " @return the enumerated axis type"]
        pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
    }
    extern "C" {
        #[doc = " Set joystick outputs."]
        #[doc = ""]
        #[doc = " @param joystickNum the joystick number"]
        #[doc = " @param outputs     bitmask of outputs, 1 for on 0 for off"]
        #[doc = " @param leftRumble  the left rumble value (0-FFFF)"]
        #[doc = " @param rightRumble the right rumble value (0-FFFF)"]
        #[doc = " @return the error code, or 0 for success"]
        pub fn HAL_SetJoystickOutputs(
            joystickNum: i32,
            outputs: i64,
            leftRumble: i32,
            rightRumble: i32,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Returns the approximate match time."]
        #[doc = ""]
        #[doc = " The FMS does not send an official match time to the robots, but does send"]
        #[doc = " an approximate match time. The value will count down the time remaining in"]
        #[doc = " the current period (auto or teleop)."]
        #[doc = ""]
        #[doc = " Warning: This is not an official time (so it cannot be used to dispute ref"]
        #[doc = " calls or guarantee that a function will trigger before the match ends)."]
        #[doc = ""]
        #[doc = " The Practice Match function of the DS approximates the behavior seen on"]
        #[doc = " the field."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return time remaining in current match period (auto or teleop)"]
        pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
    }
    extern "C" {
        #[doc = " Gets info about a specific match."]
        #[doc = ""]
        #[doc = " @param[in] info the match info (output)"]
        #[doc = " @return the error code, or 0 for success"]
        pub fn HAL_GetMatchInfo(info: *mut root::HAL_MatchInfo) -> i32;
    }
    extern "C" {
        #[doc = " Releases the DS Mutex to allow proper shutdown of any threads that are"]
        #[doc = " waiting on it."]
        pub fn HAL_ReleaseDSMutex();
    }
    extern "C" {
        #[doc = " Has a new control packet from the driver station arrived since the last"]
        #[doc = " time this function was called?"]
        #[doc = ""]
        #[doc = " @return true if the control data has been updated since the last call"]
        pub fn HAL_IsNewControlData() -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Waits for the newest DS packet to arrive. Note that this is a blocking call."]
        #[doc = " Checks if new control data has arrived since the last HAL_WaitForDSData or"]
        #[doc = " HAL_IsNewControlData call. If new data has not arrived, waits for new data"]
        #[doc = " to arrive. Otherwise, returns immediately."]
        pub fn HAL_WaitForDSData();
    }
    extern "C" {
        #[doc = " Waits for the newest DS packet to arrive. If timeout is <= 0, this will wait"]
        #[doc = " forever. Otherwise, it will wait until either a new packet, or the timeout"]
        #[doc = " time has passed."]
        #[doc = ""]
        #[doc = " @param[in] timeout timeout in seconds"]
        #[doc = " @return true for new data, false for timeout"]
        pub fn HAL_WaitForDSDataTimeout(timeout: f64) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Initializes the driver station communication. This will properly"]
        #[doc = " handle multiple calls. However note that this CANNOT be called from a library"]
        #[doc = " that interfaces with LabVIEW."]
        pub fn HAL_InitializeDriverStation();
    }
    extern "C" {
        #[doc = " Sets the program starting flag in the DS."]
        #[doc = ""]
        #[doc = " This is what changes the DS to showing robot code ready."]
        pub fn HAL_ObserveUserProgramStarting();
    }
    extern "C" {
        #[doc = " Sets the disabled flag in the DS."]
        #[doc = ""]
        #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
        #[doc = " state request. Ensure this gets called about every 50ms, or the robot will be"]
        #[doc = " disabled by the DS."]
        pub fn HAL_ObserveUserProgramDisabled();
    }
    extern "C" {
        #[doc = " Sets the autonomous enabled flag in the DS."]
        #[doc = ""]
        #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
        #[doc = " state request. Ensure this gets called about every 50ms, or the robot will be"]
        #[doc = " disabled by the DS."]
        pub fn HAL_ObserveUserProgramAutonomous();
    }
    extern "C" {
        #[doc = " Sets the teleoperated enabled flag in the DS."]
        #[doc = ""]
        #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
        #[doc = " state request. Ensure this gets called about every 50ms, or the robot will be"]
        #[doc = " disabled by the DS."]
        pub fn HAL_ObserveUserProgramTeleop();
    }
    extern "C" {
        #[doc = " Sets the test mode flag in the DS."]
        #[doc = ""]
        #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
        #[doc = " state request. Ensure this gets called about every 50ms, or the robot will be"]
        #[doc = " disabled by the DS."]
        pub fn HAL_ObserveUserProgramTest();
    }
    pub const HAL_RuntimeType_HAL_Runtime_RoboRIO: root::HAL_RuntimeType = 0;
    pub const HAL_RuntimeType_HAL_Runtime_RoboRIO2: root::HAL_RuntimeType = 1;
    pub const HAL_RuntimeType_HAL_Runtime_Simulation: root::HAL_RuntimeType = 2;
    #[doc = " @defgroup hal_capi WPILib HAL API"]
    #[doc = " Hardware Abstraction Layer to hardware or simulator"]
    #[doc = " @{"]
    pub type HAL_RuntimeType = i32;
    extern "C" {
        #[doc = " Gets the last error set on this thread, or the message for the status code."]
        #[doc = ""]
        #[doc = " If passed HAL_USE_LAST_ERROR, the last error set on the thread will be"]
        #[doc = " returned."]
        #[doc = ""]
        #[doc = " @param[out] status the status code, set to the error status code if input is"]
        #[doc = "               HAL_USE_LAST_ERROR"]
        #[doc = " @return the error message for the code. This does not need to be freed,"]
        #[doc = "               but can be overwritten by another hal call on the same thread."]
        pub fn HAL_GetLastError(status: *mut i32) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the error message for a specific status code."]
        #[doc = ""]
        #[doc = " @param code the status code"]
        #[doc = " @return the error message for the code. This does not need to be freed."]
        pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Returns the FPGA Version number."]
        #[doc = ""]
        #[doc = " For now, expect this to be competition year."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return FPGA Version number."]
        pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
    }
    extern "C" {
        #[doc = " Returns the FPGA Revision number."]
        #[doc = ""]
        #[doc = " The format of the revision is 3 numbers."]
        #[doc = " The 12 most significant bits are the Major Revision."]
        #[doc = " the next 8 bits are the Minor Revision."]
        #[doc = " The 12 least significant bits are the Build Number."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return FPGA Revision number."]
        pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
    }
    extern "C" {
        #[doc = " Returns the runtime type of the HAL."]
        #[doc = ""]
        #[doc = " @return HAL Runtime Type"]
        pub fn HAL_GetRuntimeType() -> root::HAL_RuntimeType;
    }
    extern "C" {
        #[doc = " Gets the state of the \"USER\" button on the roboRIO."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return true if the button is currently pressed down"]
        pub fn HAL_GetFPGAButton(status: *mut i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets if the system outputs are currently active"]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return true if the system outputs are active, false if disabled"]
        pub fn HAL_GetSystemActive(status: *mut i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets if the system is in a browned out state."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return true if the system is in a low voltage brown out, false otherwise"]
        pub fn HAL_GetBrownedOut(status: *mut i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets a port handle for a specific channel."]
        #[doc = ""]
        #[doc = " The created handle does not need to be freed."]
        #[doc = ""]
        #[doc = " @param channel the channel number"]
        #[doc = " @return the created port"]
        pub fn HAL_GetPort(channel: i32) -> root::HAL_PortHandle;
    }
    extern "C" {
        #[doc = " Gets a port handle for a specific channel and module."]
        #[doc = ""]
        #[doc = " This is expected to be used for PCMs, as the roboRIO does not work with"]
        #[doc = " modules anymore."]
        #[doc = ""]
        #[doc = " The created handle does not need to be freed."]
        #[doc = ""]
        #[doc = " @param module  the module number"]
        #[doc = " @param channel the channel number"]
        #[doc = " @return the created port"]
        pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> root::HAL_PortHandle;
    }
    extern "C" {
        #[doc = " Reads the microsecond-resolution timer on the FPGA."]
        #[doc = ""]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return The current time in microseconds according to the FPGA (since FPGA"]
        #[doc = " reset)."]
        pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
    }
    extern "C" {
        #[doc = " Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time."]
        #[doc = ""]
        #[doc = " Note: This is making the assumption that the timestamp being converted is"]
        #[doc = " always in the past.  If you call this with a future timestamp, it probably"]
        #[doc = " will make it in the past.  If you wait over 70 minutes between capturing the"]
        #[doc = " bottom 32 bits of the timestamp and expanding it, you will be off by"]
        #[doc = " multiples of 1<<32 microseconds."]
        #[doc = ""]
        #[doc = " @param[in] unexpandedLower 32 bit FPGA time"]
        #[doc = " @param[out] status the error code, or 0 for success"]
        #[doc = " @return The current time in microseconds according to the FPGA (since FPGA"]
        #[doc = "         reset) as a 64 bit number."]
        pub fn HAL_ExpandFPGATime(unexpandedLower: u32, status: *mut i32) -> u64;
    }
    extern "C" {
        #[doc = " Call this to start up HAL. This is required for robot programs."]
        #[doc = ""]
        #[doc = " This must be called before any other HAL functions. Failure to do so will"]
        #[doc = " result in undefined behavior, and likely segmentation faults. This means that"]
        #[doc = " any statically initialized variables in a program MUST call this function in"]
        #[doc = " their constructors if they want to use other HAL calls."]
        #[doc = ""]
        #[doc = " The common parameters are 500 for timeout and 0 for mode."]
        #[doc = ""]
        #[doc = " This function is safe to call from any thread, and as many times as you wish."]
        #[doc = " It internally guards from any reentrancy."]
        #[doc = ""]
        #[doc = " The applicable modes are:"]
        #[doc = "   0: Try to kill an existing HAL from another program, if not successful,"]
        #[doc = " error."]
        #[doc = "   1: Force kill a HAL from another program."]
        #[doc = "   2: Just warn if another hal exists and cannot be killed. Will likely result"]
        #[doc = " in undefined behavior."]
        #[doc = ""]
        #[doc = " @param timeout the initialization timeout (ms)"]
        #[doc = " @param mode    the initialization mode (see remarks)"]
        #[doc = " @return true if initialization was successful, otherwise false."]
        pub fn HAL_Initialize(timeout: i32, mode: i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Call this to shut down HAL."]
        #[doc = ""]
        #[doc = " This must be called at termination of the robot program to avoid potential"]
        #[doc = " segmentation faults with simulation extensions at exit."]
        pub fn HAL_Shutdown();
    }
    extern "C" {
        #[doc = " Calls registered SimPeriodic \"before\" callbacks (only in simulation mode)."]
        #[doc = " This should be called prior to user code periodic simulation functions."]
        pub fn HAL_SimPeriodicBefore();
    }
    extern "C" {
        #[doc = " Calls registered SimPeriodic \"after\" callbacks (only in simulation mode)."]
        #[doc = " This should be called after user code periodic simulation functions."]
        pub fn HAL_SimPeriodicAfter();
    }
    extern "C" {
        #[doc = " Sets up the system to run the provided main loop in the main thread (e.g."]
        #[doc = " the thread in which main() starts execution) and run the robot code in a"]
        #[doc = " separate thread."]
        #[doc = ""]
        #[doc = " Normally the robot code runs in the main thread, but some GUI systems"]
        #[doc = " require the GUI be run in the main thread."]
        #[doc = ""]
        #[doc = " To be effective, this function must be called before the robot code starts"]
        #[doc = " the main loop (e.g. by frc::StartRobot())."]
        #[doc = ""]
        #[doc = " @param param parameter data to pass to mainFunc and exitFunc"]
        #[doc = " @param mainFunc the function to be run when HAL_RunMain() is called."]
        #[doc = " @param exitFunc the function to be run when HAL_ExitMain() is called."]
        pub fn HAL_SetMain(
            param: *mut ::std::os::raw::c_void,
            mainFunc: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
            >,
            exitFunc: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
            >,
        );
    }
    extern "C" {
        #[doc = " Returns true if HAL_SetMain() has been called."]
        #[doc = ""]
        #[doc = " @return True if HAL_SetMain() has been called, false otherwise."]
        pub fn HAL_HasMain() -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Runs the main function provided to HAL_SetMain()."]
        #[doc = ""]
        #[doc = " If HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()"]
        #[doc = " is called."]
        pub fn HAL_RunMain();
    }
    extern "C" {
        #[doc = " Causes HAL_RunMain() to exit."]
        #[doc = ""]
        #[doc = " If HAL_SetMain() has been called, this calls the exit function provided"]
        #[doc = " to that function."]
        pub fn HAL_ExitMain();
    }
    #[test]
    fn __bindgen_test_layout_base_unit_open0_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_base_unit_open0_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_t_open0_second_double_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_t_open0_radian_double_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_open0_ratio_open1_close1_radians_ratio_open1_close1_ratio_open1_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_t_open0_degree_double_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_SPI_Accumulator_default_delete_open1_SPI_Accumulator_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_SPI_Accumulator_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_SendableHelper_open0_ADXRS450_Gyro_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::wpi::SendableHelper>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::wpi::SendableHelper)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::wpi::SendableHelper>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::wpi::SendableHelper)
            )
        );
    }
}
