/* automatically generated by rust-bindgen 0.66.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const HAL_kInvalidHandle: u32 = 0;
    pub const HAL_IO_CONFIG_DATA_SIZE: u32 = 32;
    pub const HAL_SYS_STATUS_DATA_SIZE: u32 = 44;
    pub const HAL_USER_STATUS_DATA_SIZE: u32 = 908;
    pub const HAL_kMaxJoystickAxes: u32 = 12;
    pub const HAL_kMaxJoystickPOVs: u32 = 12;
    pub const HAL_kMaxJoysticks: u32 = 6;
    pub type __intmax_t = ::std::os::raw::c_long;
    pub type intmax_t = root::__intmax_t;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct basic_string<_CharT> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider,
            pub _M_string_length: root::std::basic_string_size_type,
            pub __bindgen_anon_1: root::std::basic_string__bindgen_ty_2<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string__Char_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::basic_string__Char_alloc_type;
        pub type basic_string_size_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_difference_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::basic_string_const_iterator;
        pub type basic_string___sv_type<_CharT> = root::std::basic_string_view<_CharT>;
        pub type basic_string__If_sv = root::std::enable_if_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string___sv_wrapper<_CharT> {
            pub _M_sv: root::std::basic_string___sv_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::basic_string_pointer,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: *mut _CharT,
            pub _M_allocated_capacity: root::std::basic_string_size_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type __bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_floating_point {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        pub type __enable_if_t = u8;
        pub type enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = root::std::__undefined;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_elem {
            pub _address: u8,
        }
        pub type __ptr_traits_elem_t = root::std::__ptr_traits_elem;
        pub type __ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
        pub type __ptr_traits_ptr_to_element_type<_Elt> = _Elt;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl___difference {
            pub _address: u8,
        }
        pub type __ptr_traits_impl___difference_type = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl___rebind {
            pub _address: u8,
        }
        pub type __ptr_traits_impl_pointer<_Ptr> = _Ptr;
        pub type __ptr_traits_impl_element_type<_Elt> = _Elt;
        pub type __ptr_traits_impl_difference_type = root::std::__ptr_traits_impl___difference;
        pub type __ptr_traits_impl_rebind = root::std::__ptr_traits_impl___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __new_allocator {
            pub _address: u8,
        }
        pub type __new_allocator_value_type<_Tp> = _Tp;
        pub type __new_allocator_size_type = usize;
        pub type __new_allocator_difference_type = isize;
        pub type __new_allocator_pointer<_Tp> = *mut _Tp;
        pub type __new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type __new_allocator_reference<_Tp> = *mut _Tp;
        pub type __new_allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __new_allocator_rebind {
            pub _address: u8,
        }
        pub type __new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type __allocator_base = root::std::__new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        pub type tuple__TCC = u8;
        pub type tuple__ImplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ImplicitCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitCtor = root::std::__enable_if_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple__UseOtherCtor {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uniq_ptr_impl {
            pub _M_t: root::std::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uniq_ptr_impl__Ptr {
            pub _address: u8,
        }
        pub type __uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
        pub type __uniq_ptr_impl__DeleterConstraint = u8;
        pub type __uniq_ptr_impl_pointer = root::std::__uniq_ptr_impl__Ptr;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr {
            pub _M_t: u8,
        }
        pub type unique_ptr__DeleterConstraint = root::std::__uniq_ptr_impl;
        pub type unique_ptr_pointer = root::std::__uniq_ptr_impl;
        pub type unique_ptr_element_type<_Tp> = _Tp;
        pub type unique_ptr_deleter_type<_Dp> = _Dp;
        pub type unique_ptr___safe_conversion_up = root::std::__and_;
        pub type string = root::std::basic_string<::std::os::raw::c_char>;
        pub type streamoff = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        pub type streampos = root::std::fpos<root::mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view<_CharT> {
            pub _M_len: usize,
            pub _M_str: *const _CharT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> =
            *mut root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_pointer<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_reference<_CharT> =
            *mut root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_reference<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_const_iterator<_CharT> =
            *const root::std::basic_string_view_value_type<_CharT>;
        pub type basic_string_view_iterator<_CharT> =
            root::std::basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            root::std::reverse_iterator<root::std::basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            root::std::basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        pub type string_view = root::std::basic_string_view<::std::os::raw::c_char>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct vector__Temporary_value<_Tp> {
            pub _M_this: *mut root::std::vector,
            pub _M_storage: root::std::vector__Temporary_value__Storage<_Tp>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        #[repr(C)]
        pub union vector__Temporary_value__Storage<_Tp> {
            pub _M_byte: ::std::os::raw::c_uchar,
            pub _M_val: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::intmax_t;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::intmax_t;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ratio_multiply {
            pub _address: u8,
        }
        pub type __ratio_multiply_type = u8;
        pub type ratio_multiply = root::std::__ratio_multiply;
        pub type __ratio_add_impl___t = u8;
        pub type __ratio_add_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ratio_add {
            pub _address: u8,
        }
        pub type __ratio_add_type = u8;
        pub type ratio_add = root::std::__ratio_add;
        pub type nano = u8;
        pub type micro = u8;
        pub type milli = u8;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct treat_as_floating_point {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct duration<_Rep> {
                pub __r: root::std::chrono::duration_rep<_Rep>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
            }
            pub type duration___is_float = root::std::chrono::treat_as_floating_point;
            pub type duration___divide = u8;
            pub type duration___is_harmonic = root::std::__bool_constant;
            pub type duration_rep<_Rep> = _Rep;
            pub type duration_period = [u8; 0usize];
            pub type nanoseconds = root::std::chrono::duration<i64>;
            pub type microseconds = root::std::chrono::duration<i64>;
            pub type milliseconds = root::std::chrono::duration<i64>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct time_point<_Dur> {
                pub __d: root::std::chrono::time_point_duration<_Dur>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Dur>>,
            }
            pub type time_point_clock<_Clock> = _Clock;
            pub type time_point_duration<_Dur> = _Dur;
            pub type time_point_rep = [u8; 0usize];
            pub type time_point_period = [u8; 0usize];
        }
        pub type thread_native_handle_type = root::__gthread_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct thread_id {
            pub _M_thread: root::std::thread_native_handle_type,
        }
        #[test]
        fn bindgen_test_layout_thread_id() {
            const UNINIT: ::std::mem::MaybeUninit<thread_id> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<thread_id>(),
                8usize,
                concat!("Size of: ", stringify!(thread_id))
            );
            assert_eq!(
                ::std::mem::align_of::<thread_id>(),
                8usize,
                concat!("Alignment of ", stringify!(thread_id))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr)._M_thread) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(thread_id),
                    "::",
                    stringify!(_M_thread)
                )
            );
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator___convertible_from = root::std::__enable_if_t;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    }
    pub mod wpi {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub type span_storage_type = u8;
        pub type span_element_type<ElementType> = ElementType;
        pub type span_value_type = root::std::remove_cv;
        pub type span_size_type = usize;
        pub type span_difference_type = isize;
        pub type span_pointer<ElementType> = *mut root::wpi::span_element_type<ElementType>;
        pub type span_const_pointer<ElementType> = *const root::wpi::span_element_type<ElementType>;
        pub type span_reference<ElementType> = *mut root::wpi::span_element_type<ElementType>;
        pub type span_const_reference<ElementType> =
            *const root::wpi::span_element_type<ElementType>;
        pub type span_iterator<ElementType> = root::wpi::span_pointer<ElementType>;
        pub type span_reverse_iterator<ElementType> =
            root::std::reverse_iterator<root::wpi::span_iterator<ElementType>>;
        pub type span_subspan_return_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SendableBuilder {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct Sendable__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface for Sendable objects."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Sendable {
            pub vtable_: *const Sendable__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_Sendable() {
            assert_eq!(
                ::std::mem::size_of::<Sendable>(),
                8usize,
                concat!("Size of: ", stringify!(Sendable))
            );
            assert_eq!(
                ::std::mem::align_of::<Sendable>(),
                8usize,
                concat!("Alignment of ", stringify!(Sendable))
            );
        }
        #[doc = " A helper class for use with objects that add themselves to SendableRegistry.\n It takes care of properly calling Move() and Remove() on move and\n destruction.  No action is taken if the object is copied.\n Use public inheritance with CRTP when using this class.\n @tparam CRTP derived class"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SendableHelper {
            pub _address: u8,
        }
        #[doc = " CRTP base class which implements the entire standard iterator facade\n in terms of a minimal subset of the interface.\n\n Use this when it is reasonable to implement most of the iterator\n functionality in terms of a core subset. If you need special behavior or\n there are performance implications for this, you may want to override the\n relevant members instead.\n\n Note, one abstraction that this does *not* provide is implementing\n subtraction in terms of addition by negating the difference. Negation isn't\n always information preserving, and I can see very reasonable iterator\n designs where this doesn't work well. It doesn't really force much added\n boilerplate anyways.\n\n Another abstraction that this doesn't provide is implementing increment in\n terms of addition of one. These aren't equivalent for all iterator\n categories, and respecting that adds a lot of complexity for little gain.\n\n Classes wishing to use `iterator_facade_base` should implement the following\n methods:\n\n Forward Iterators:\n   (All of the following methods)\n   - DerivedT &operator=(const DerivedT &R);\n   - bool operator==(const DerivedT &R) const;\n   - const T &operator*() const;\n   - T &operator*();\n   - DerivedT &operator++();\n\n Bidirectional Iterators:\n   (All methods of forward iterators, plus the following)\n   - DerivedT &operator--();\n\n Random-access Iterators:\n   (All methods of bidirectional iterators excluding the following)\n   - DerivedT &operator++();\n   - DerivedT &operator--();\n   (and plus the following)\n   - bool operator<(const DerivedT &RHS) const;\n   - DifferenceTypeT operator-(const DerivedT &R) const;\n   - DerivedT &operator+=(DifferenceTypeT N);\n   - DerivedT &operator-=(DifferenceTypeT N);\n"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_facade_base {
            pub _address: u8,
        }
        pub const iterator_facade_base_IsRandomAccess:
            root::wpi::iterator_facade_base__bindgen_ty_1 = 0;
        pub const iterator_facade_base_IsBidirectional:
            root::wpi::iterator_facade_base__bindgen_ty_1 = 0;
        pub type iterator_facade_base__bindgen_ty_1 = i32;
        #[doc = " A proxy object for computing a reference via indirecting a copy of an\n iterator. This is used in APIs which need to produce a reference via\n indirection but for which the iterator object might be a temporary. The\n proxy preserves the iterator internally and exposes the indirected\n reference via a conversion operator."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_facade_base_ReferenceProxy<DerivedT> {
            pub I: DerivedT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DerivedT>>,
        }
        #[doc = " StringMapEntryBase - Shared base class of StringMapEntry instances."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringMapEntryBase {
            pub StrLen: usize,
        }
        #[test]
        fn bindgen_test_layout_StringMapEntryBase() {
            const UNINIT: ::std::mem::MaybeUninit<StringMapEntryBase> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<StringMapEntryBase>(),
                8usize,
                concat!("Size of: ", stringify!(StringMapEntryBase))
            );
            assert_eq!(
                ::std::mem::align_of::<StringMapEntryBase>(),
                8usize,
                concat!("Alignment of ", stringify!(StringMapEntryBase))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).StrLen) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringMapEntryBase),
                    "::",
                    stringify!(StrLen)
                )
            );
        }
        #[doc = " StringMapImpl - This is the base class of StringMap that is shared among\n all of its instantiations."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringMapImpl {
            pub TheTable: *mut *mut root::wpi::StringMapEntryBase,
            pub NumBuckets: ::std::os::raw::c_uint,
            pub NumItems: ::std::os::raw::c_uint,
            pub NumTombstones: ::std::os::raw::c_uint,
            pub ItemSize: ::std::os::raw::c_uint,
        }
        #[test]
        fn bindgen_test_layout_StringMapImpl() {
            const UNINIT: ::std::mem::MaybeUninit<StringMapImpl> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<StringMapImpl>(),
                24usize,
                concat!("Size of: ", stringify!(StringMapImpl))
            );
            assert_eq!(
                ::std::mem::align_of::<StringMapImpl>(),
                8usize,
                concat!("Alignment of ", stringify!(StringMapImpl))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).TheTable) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringMapImpl),
                    "::",
                    stringify!(TheTable)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).NumBuckets) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringMapImpl),
                    "::",
                    stringify!(NumBuckets)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).NumItems) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringMapImpl),
                    "::",
                    stringify!(NumItems)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).NumTombstones) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringMapImpl),
                    "::",
                    stringify!(NumTombstones)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ItemSize) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringMapImpl),
                    "::",
                    stringify!(ItemSize)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3wpi13StringMapImpl11RehashTableEj"]
            pub fn StringMapImpl_RehashTable(
                this: *mut root::wpi::StringMapImpl,
                BucketNo: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint;
        }
        extern "C" {
            #[doc = " LookupBucketFor - Look up the bucket that the specified string should end\n up in.  If it already exists as a key in the map, the Item pointer for the\n specified bucket will be non-null.  Otherwise, it will be null.  In either\n case, the FullHashValue field of the bucket will be set to the hash value\n of the string."]
            #[link_name = "\u{1}_ZN3wpi13StringMapImpl15LookupBucketForESt17basic_string_viewIcSt11char_traitsIcEE"]
            pub fn StringMapImpl_LookupBucketFor(
                this: *mut root::wpi::StringMapImpl,
                Key: root::std::string_view,
            ) -> ::std::os::raw::c_uint;
        }
        extern "C" {
            #[doc = " FindKey - Look up the bucket that contains the specified key. If it exists\n in the map, return the bucket number of the key.  Otherwise return -1.\n This does not modify the map."]
            #[link_name = "\u{1}_ZNK3wpi13StringMapImpl7FindKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
            pub fn StringMapImpl_FindKey(
                this: *const root::wpi::StringMapImpl,
                Key: root::std::string_view,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " RemoveKey - Remove the specified StringMapEntry from the table, but do not\n delete it.  This aborts if the value isn't in the table."]
            #[link_name = "\u{1}_ZN3wpi13StringMapImpl9RemoveKeyEPNS_18StringMapEntryBaseE"]
            pub fn StringMapImpl_RemoveKey(
                this: *mut root::wpi::StringMapImpl,
                V: *mut root::wpi::StringMapEntryBase,
            );
        }
        extern "C" {
            #[doc = " RemoveKey - Remove the StringMapEntry for the specified key from the\n table, returning it.  If the key is not in the table, this returns null."]
            #[link_name = "\u{1}_ZN3wpi13StringMapImpl9RemoveKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
            pub fn StringMapImpl_RemoveKey1(
                this: *mut root::wpi::StringMapImpl,
                Key: root::std::string_view,
            ) -> *mut root::wpi::StringMapEntryBase;
        }
        extern "C" {
            #[doc = " Allocate the table with the specified number of buckets and otherwise\n setup the map as empty."]
            #[link_name = "\u{1}_ZN3wpi13StringMapImpl4initEj"]
            pub fn StringMapImpl_init(
                this: *mut root::wpi::StringMapImpl,
                Size: ::std::os::raw::c_uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3wpi13StringMapImplC1Ejj"]
            pub fn StringMapImpl_StringMapImpl(
                this: *mut root::wpi::StringMapImpl,
                InitSize: ::std::os::raw::c_uint,
                ItemSize: ::std::os::raw::c_uint,
            );
        }
        impl StringMapImpl {
            #[inline]
            pub unsafe fn RehashTable(
                &mut self,
                BucketNo: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint {
                StringMapImpl_RehashTable(self, BucketNo)
            }
            #[inline]
            pub unsafe fn LookupBucketFor(
                &mut self,
                Key: root::std::string_view,
            ) -> ::std::os::raw::c_uint {
                StringMapImpl_LookupBucketFor(self, Key)
            }
            #[inline]
            pub unsafe fn FindKey(&self, Key: root::std::string_view) -> ::std::os::raw::c_int {
                StringMapImpl_FindKey(self, Key)
            }
            #[inline]
            pub unsafe fn RemoveKey(&mut self, V: *mut root::wpi::StringMapEntryBase) {
                StringMapImpl_RemoveKey(self, V)
            }
            #[inline]
            pub unsafe fn RemoveKey1(
                &mut self,
                Key: root::std::string_view,
            ) -> *mut root::wpi::StringMapEntryBase {
                StringMapImpl_RemoveKey1(self, Key)
            }
            #[inline]
            pub unsafe fn init(&mut self, Size: ::std::os::raw::c_uint) {
                StringMapImpl_init(self, Size)
            }
            #[inline]
            pub unsafe fn new(
                InitSize: ::std::os::raw::c_uint,
                ItemSize: ::std::os::raw::c_uint,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                StringMapImpl_StringMapImpl(__bindgen_tmp.as_mut_ptr(), InitSize, ItemSize);
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringMapEntry<ValueTy> {
            pub _base: root::wpi::StringMapEntryBase,
            pub second: ValueTy,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTy>>,
        }
        #[doc = " StringMap - This is an unconventional map that is specialized for handling\n keys that are \"strings\", which are basically ranges of bytes. This does some\n funky memory allocation and hashing things to make it extremely efficient,\n storing the string data *after* the value in the map."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct StringMap {
            pub _base: root::wpi::StringMapImpl,
        }
        #[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
        pub type StringMap_MapEntryTy<ValueTy> = root::wpi::StringMapEntry<ValueTy>;
        pub type StringMap_key_type = *const ::std::os::raw::c_char;
        pub type StringMap_mapped_type<ValueTy> = ValueTy;
        #[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
        pub type StringMap_value_type<ValueTy> = root::wpi::StringMapEntry<ValueTy>;
        pub type StringMap_size_type = usize;
        pub type StringMap_const_iterator = root::wpi::StringMapConstIterator;
        pub type StringMap_iterator = root::wpi::StringMapIterator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringMapIterBase {
            pub Ptr: *mut *mut root::wpi::StringMapEntryBase,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringMapConstIterator {
            pub _base: root::wpi::StringMapIterBase,
        }
        pub type StringMapConstIterator_base = root::wpi::StringMapIterBase;
        #[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
        pub type StringMapConstIterator_value_type<ValueTy> = root::wpi::StringMapEntry<ValueTy>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringMapIterator {
            pub _base: root::wpi::StringMapIterBase,
        }
        pub type StringMapIterator_base = root::wpi::StringMapIterBase;
        #[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
        pub type StringMapIterator_value_type<ValueTy> = root::wpi::StringMapEntry<ValueTy>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct raw_ostream {
            _unused: [u8; 0],
        }
        pub mod support {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod hashing {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[doc = " This class is the same as std::priority_queue with two changes:\n\n 1. Adds a remove() function for removing all elements from the priority queue\n    that match the given value.\n 2. Replaces \"void pop()\" with \"T pop()\" so the element can be moved from the\n    queue directly instead of copied from top()."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct priority_queue<Sequence, Compare> {
            pub c: Sequence,
            pub comp: Compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Sequence>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Compare>>,
        }
        pub type priority_queue_value_type = [u8; 0usize];
        pub type priority_queue_reference = [u8; 0usize];
        pub type priority_queue_const_reference = [u8; 0usize];
        pub type priority_queue_size_type = [u8; 0usize];
        pub type priority_queue_container_type<Sequence> = Sequence;
        pub type priority_queue_value_compare<Compare> = Compare;
    }
    pub type HAL_Handle = i32;
    pub type HAL_PortHandle = root::HAL_Handle;
    pub type HAL_AnalogInputHandle = root::HAL_Handle;
    pub type HAL_AnalogOutputHandle = root::HAL_Handle;
    pub type HAL_AnalogTriggerHandle = root::HAL_Handle;
    pub type HAL_CompressorHandle = root::HAL_Handle;
    pub type HAL_CounterHandle = root::HAL_Handle;
    pub type HAL_DigitalHandle = root::HAL_Handle;
    pub type HAL_DigitalPWMHandle = root::HAL_Handle;
    pub type HAL_EncoderHandle = root::HAL_Handle;
    pub type HAL_FPGAEncoderHandle = root::HAL_Handle;
    pub type HAL_GyroHandle = root::HAL_Handle;
    pub type HAL_InterruptHandle = root::HAL_Handle;
    pub type HAL_NotifierHandle = root::HAL_Handle;
    pub type HAL_RelayHandle = root::HAL_Handle;
    pub type HAL_SolenoidHandle = root::HAL_Handle;
    pub type HAL_SerialPortHandle = root::HAL_Handle;
    pub type HAL_CANHandle = root::HAL_Handle;
    pub type HAL_SimDeviceHandle = root::HAL_Handle;
    pub type HAL_SimValueHandle = root::HAL_Handle;
    pub type HAL_DMAHandle = root::HAL_Handle;
    pub type HAL_DutyCycleHandle = root::HAL_Handle;
    pub type HAL_AddressableLEDHandle = root::HAL_Handle;
    pub type HAL_PDPHandle = root::HAL_CANHandle;
    pub type HAL_PowerDistributionHandle = root::HAL_Handle;
    pub type HAL_CTREPCMHandle = root::HAL_Handle;
    pub type HAL_REVPDHHandle = root::HAL_Handle;
    pub type HAL_REVPHHandle = root::HAL_Handle;
    pub type HAL_Bool = i32;
    pub mod hal {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " C++ wrapper around a HAL simulator value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimValue {
            pub m_handle: root::HAL_SimValueHandle,
        }
        #[test]
        fn bindgen_test_layout_SimValue() {
            const UNINIT: ::std::mem::MaybeUninit<SimValue> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SimValue>(),
                4usize,
                concat!("Size of: ", stringify!(SimValue))
            );
            assert_eq!(
                ::std::mem::align_of::<SimValue>(),
                4usize,
                concat!("Alignment of ", stringify!(SimValue))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SimValue),
                    "::",
                    stringify!(m_handle)
                )
            );
        }
        #[doc = " C++ wrapper around a HAL simulator double value handle."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SimDouble {
            pub _base: root::hal::SimValue,
        }
        #[test]
        fn bindgen_test_layout_SimDouble() {
            assert_eq!(
                ::std::mem::size_of::<SimDouble>(),
                4usize,
                concat!("Size of: ", stringify!(SimDouble))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDouble>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDouble))
            );
        }
        #[doc = " A move-only C++ wrapper around a HAL simulator device handle."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SimDevice {
            pub m_handle: root::HAL_SimDeviceHandle,
        }
        pub const SimDevice_Direction_kInput: root::hal::SimDevice_Direction = 0;
        pub const SimDevice_Direction_kOutput: root::hal::SimDevice_Direction = 1;
        pub const SimDevice_Direction_kBidir: root::hal::SimDevice_Direction = 2;
        #[doc = " Direction of a simulated value (from the perspective of user code)."]
        pub type SimDevice_Direction = ::std::os::raw::c_uint;
        #[test]
        fn bindgen_test_layout_SimDevice() {
            const UNINIT: ::std::mem::MaybeUninit<SimDevice> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SimDevice>(),
                4usize,
                concat!("Size of: ", stringify!(SimDevice))
            );
            assert_eq!(
                ::std::mem::align_of::<SimDevice>(),
                4usize,
                concat!("Alignment of ", stringify!(SimDevice))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SimDevice),
                    "::",
                    stringify!(m_handle)
                )
            );
        }
        extern "C" {
            #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index in\n brackets to the device name, e.g. passing index=1 results in \"device[1]\"\n for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKci"]
            pub fn SimDevice_SimDevice(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index and\n channel in brackets to the device name, e.g. passing index=1 and channel=2\n results in \"device[1,2]\" for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name\n @param channel device channel number to append to name"]
            #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKcii"]
            pub fn SimDevice_SimDevice1(
                this: *mut root::hal::SimDevice,
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            );
        }
        impl SimDevice {
            #[inline]
            pub unsafe fn new(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice(__bindgen_tmp.as_mut_ptr(), name, index);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                name: *const ::std::os::raw::c_char,
                index: ::std::os::raw::c_int,
                channel: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SimDevice_SimDevice1(__bindgen_tmp.as_mut_ptr(), name, index, channel);
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " A move-only C++ wrapper around HAL_SPIPort.\n Does not ensure destruction."]
        pub type SPIPort = u32;
        #[doc = " A std::chrono compatible wrapper around the FPGA Timer."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct fpga_clock {
            pub _address: u8,
        }
        pub type fpga_clock_rep = root::rep;
        pub type fpga_clock_period = u8;
        pub type fpga_clock_duration = root::std::chrono::microseconds;
        pub type fpga_clock_time_point =
            root::std::chrono::time_point<root::std::chrono::duration<::std::os::raw::c_long>>;
        pub const fpga_clock_is_steady: bool = true;
        extern "C" {
            #[link_name = "\u{1}_ZN3hal10fpga_clock8min_timeE"]
            pub static fpga_clock_min_time: root::hal::fpga_clock_time_point;
        }
        #[test]
        fn bindgen_test_layout_fpga_clock() {
            assert_eq!(
                ::std::mem::size_of::<fpga_clock>(),
                1usize,
                concat!("Size of: ", stringify!(fpga_clock))
            );
            assert_eq!(
                ::std::mem::align_of::<fpga_clock>(),
                1usize,
                concat!("Alignment of ", stringify!(fpga_clock))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3hal10fpga_clock3nowEv"]
            pub fn fpga_clock_now() -> root::hal::fpga_clock_time_point;
        }
        impl fpga_clock {
            #[inline]
            pub unsafe fn now() -> root::hal::fpga_clock_time_point {
                fpga_clock_now()
            }
        }
    }
    pub const HAL_Type_HAL_UNASSIGNED: root::HAL_Type = 0;
    pub const HAL_Type_HAL_BOOLEAN: root::HAL_Type = 1;
    pub const HAL_Type_HAL_DOUBLE: root::HAL_Type = 2;
    pub const HAL_Type_HAL_ENUM: root::HAL_Type = 4;
    pub const HAL_Type_HAL_INT: root::HAL_Type = 8;
    pub const HAL_Type_HAL_LONG: root::HAL_Type = 16;
    #[doc = " HAL data types."]
    pub type HAL_Type = ::std::os::raw::c_uint;
    #[doc = " HAL Entry Value.  Note this is a typed union."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct HAL_Value {
        pub data: root::HAL_Value__bindgen_ty_1,
        pub type_: root::HAL_Type,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union HAL_Value__bindgen_ty_1 {
        pub v_boolean: root::HAL_Bool,
        pub v_enum: i32,
        pub v_int: i32,
        pub v_long: i64,
        pub v_double: f64,
    }
    #[test]
    fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_Value__bindgen_ty_1> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value__bindgen_ty_1),
                "::",
                stringify!(v_boolean)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).v_enum) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value__bindgen_ty_1),
                "::",
                stringify!(v_enum)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value__bindgen_ty_1),
                "::",
                stringify!(v_int)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value__bindgen_ty_1),
                "::",
                stringify!(v_long)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value__bindgen_ty_1),
                "::",
                stringify!(v_double)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_HAL_Value() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_Value> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_Value>(),
            16usize,
            concat!("Size of: ", stringify!(HAL_Value))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_Value>(),
            8usize,
            concat!("Alignment of ", stringify!(HAL_Value))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_Value),
                "::",
                stringify!(type_)
            )
        );
    }
    #[doc = "< input to user code from the simulator"]
    pub const HAL_SimValueDirection_HAL_SimValueInput: root::HAL_SimValueDirection = 0;
    #[doc = "< output from user code to the simulator"]
    pub const HAL_SimValueDirection_HAL_SimValueOutput: root::HAL_SimValueDirection = 1;
    #[doc = "< bidirectional between user code and simulator"]
    pub const HAL_SimValueDirection_HAL_SimValueBidir: root::HAL_SimValueDirection = 2;
    #[doc = " Direction of a simulated value (from the perspective of user code)."]
    pub type HAL_SimValueDirection = i32;
    extern "C" {
        #[doc = " Creates a simulated device.\n\n The device name must be unique.  0 is returned if the device name already\n exists.  If multiple instances of the same device are desired, recommend\n appending the instance/unique identifer in brackets to the base name,\n e.g. \"device[1]\".\n\n 0 is returned if not in simulation.\n\n @param name device name\n @return simulated device handle"]
        pub fn HAL_CreateSimDevice(
            name: *const ::std::os::raw::c_char,
        ) -> root::HAL_SimDeviceHandle;
    }
    extern "C" {
        #[doc = " Frees a simulated device.\n\n This also allows the same device name to be used again.\n This also frees all the simulated values created on the device.\n\n @param handle simulated device handle"]
        pub fn HAL_FreeSimDevice(handle: root::HAL_SimDeviceHandle);
    }
    extern "C" {
        #[doc = " Creates a value on a simulated device.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param initialValue initial value\n @return simulated value handle"]
        pub fn HAL_CreateSimValue(
            device: root::HAL_SimDeviceHandle,
            name: *const ::std::os::raw::c_char,
            direction: i32,
            initialValue: *const root::HAL_Value,
        ) -> root::HAL_SimValueHandle;
    }
    extern "C" {
        #[doc = " Creates an enumerated value on a simulated device.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param initialValue initial value (selection)\n @return simulated value handle"]
        pub fn HAL_CreateSimValueEnum(
            device: root::HAL_SimDeviceHandle,
            name: *const ::std::os::raw::c_char,
            direction: i32,
            numOptions: i32,
            options: *mut *const ::std::os::raw::c_char,
            initialValue: i32,
        ) -> root::HAL_SimValueHandle;
    }
    extern "C" {
        #[doc = " Creates an enumerated value on a simulated device with double values.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param optionValues array of option double values\n @param initialValue initial value (selection)\n @return simulated value handle"]
        pub fn HAL_CreateSimValueEnumDouble(
            device: root::HAL_SimDeviceHandle,
            name: *const ::std::os::raw::c_char,
            direction: i32,
            numOptions: i32,
            options: *mut *const ::std::os::raw::c_char,
            optionValues: *const f64,
            initialValue: i32,
        ) -> root::HAL_SimValueHandle;
    }
    extern "C" {
        #[doc = " Gets a simulated value.\n\n @param handle simulated value handle\n @param value value (output parameter)"]
        pub fn HAL_GetSimValue(handle: root::HAL_SimValueHandle, value: *mut root::HAL_Value);
    }
    extern "C" {
        #[doc = " Sets a simulated value.\n\n @param handle simulated value handle\n @param value the value to set"]
        pub fn HAL_SetSimValue(handle: root::HAL_SimValueHandle, value: *const root::HAL_Value);
    }
    extern "C" {
        #[doc = " Resets a simulated double or integral value to 0.\n Has no effect on other value types.\n Use this instead of Set(0) for resetting incremental sensor values like\n encoder counts or gyro accumulated angle to ensure correct behavior in a\n distributed system (e.g. WebSockets).\n\n @param handle simulated value handle"]
        pub fn HAL_ResetSimValue(handle: root::HAL_SimValueHandle);
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: root::__mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    pub type mbstate_t = root::__mbstate_t;
    pub type pthread_t = ::std::os::raw::c_ulong;
    pub type __gthread_t = root::pthread_t;
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub const HAL_I2CPort_HAL_I2C_kInvalid: root::HAL_I2CPort = -1;
    pub const HAL_I2CPort_HAL_I2C_kOnboard: root::HAL_I2CPort = 0;
    pub const HAL_I2CPort_HAL_I2C_kMXP: root::HAL_I2CPort = 1;
    #[doc = " @defgroup hal_i2c I2C Functions\n @ingroup hal_capi\n @{"]
    pub type HAL_I2CPort = i32;
    pub mod frc {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct SPI__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " SPI bus interface class.\n\n This class is intended to be used by sensor (and other SPI device) drivers.\n It probably should not be used directly.\n"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct SPI {
            pub vtable_: *const SPI__bindgen_vtable,
            pub m_port: root::hal::SPIPort,
            pub m_msbFirst: bool,
            pub m_sampleOnTrailing: bool,
            pub m_clockIdleHigh: bool,
            pub m_accum: root::std::unique_ptr,
        }
        pub const SPI_Port_kOnboardCS0: root::frc::SPI_Port = 0;
        pub const SPI_Port_kOnboardCS1: root::frc::SPI_Port = 1;
        pub const SPI_Port_kOnboardCS2: root::frc::SPI_Port = 2;
        pub const SPI_Port_kOnboardCS3: root::frc::SPI_Port = 3;
        pub const SPI_Port_kMXP: root::frc::SPI_Port = 4;
        pub type SPI_Port = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SPI_Accumulator {
            _unused: [u8; 0],
        }
        #[test]
        fn bindgen_test_layout_SPI() {
            const UNINIT: ::std::mem::MaybeUninit<SPI> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SPI>(),
                24usize,
                concat!("Size of: ", stringify!(SPI))
            );
            assert_eq!(
                ::std::mem::align_of::<SPI>(),
                8usize,
                concat!("Alignment of ", stringify!(SPI))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SPI),
                    "::",
                    stringify!(m_port)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_msbFirst) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SPI),
                    "::",
                    stringify!(m_msbFirst)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sampleOnTrailing) as usize - ptr as usize },
                13usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SPI),
                    "::",
                    stringify!(m_sampleOnTrailing)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_clockIdleHigh) as usize - ptr as usize },
                14usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SPI),
                    "::",
                    stringify!(m_clockIdleHigh)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_accum) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SPI),
                    "::",
                    stringify!(m_accum)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK3frc3SPI7GetPortEv"]
            pub fn SPI_GetPort(this: *const root::frc::SPI) -> root::frc::SPI_Port;
        }
        extern "C" {
            #[doc = " Configure the rate of the generated clock signal.\n\n The default value is 500,000Hz.\n The maximum value is 4,000,000Hz.\n\n @param hz The clock rate in Hertz."]
            #[link_name = "\u{1}_ZN3frc3SPI12SetClockRateEi"]
            pub fn SPI_SetClockRate(this: *mut root::frc::SPI, hz: ::std::os::raw::c_int);
        }
        extern "C" {
            #[doc = " Configure the order that bits are sent and received on the wire\n to be most significant bit first."]
            #[link_name = "\u{1}_ZN3frc3SPI11SetMSBFirstEv"]
            pub fn SPI_SetMSBFirst(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the order that bits are sent and received on the wire\n to be least significant bit first."]
            #[link_name = "\u{1}_ZN3frc3SPI11SetLSBFirstEv"]
            pub fn SPI_SetLSBFirst(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the leading edge and the data\n changes on the trailing edge."]
            #[link_name = "\u{1}_ZN3frc3SPI26SetSampleDataOnLeadingEdgeEv"]
            pub fn SPI_SetSampleDataOnLeadingEdge(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the trailing edge and the data\n changes on the leading edge."]
            #[link_name = "\u{1}_ZN3frc3SPI27SetSampleDataOnTrailingEdgeEv"]
            pub fn SPI_SetSampleDataOnTrailingEdge(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the falling edge and the data\n changes on the rising edge.\n\n @deprecated Use SetSampleDataOnTrailingEdge() instead.\n"]
            #[link_name = "\u{1}_ZN3frc3SPI22SetSampleDataOnFallingEv"]
            pub fn SPI_SetSampleDataOnFalling(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure that the data is stable on the rising edge and the data\n changes on the falling edge.\n\n @deprecated Use SetSampleDataOnLeadingEdge() instead.\n"]
            #[link_name = "\u{1}_ZN3frc3SPI21SetSampleDataOnRisingEv"]
            pub fn SPI_SetSampleDataOnRising(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the clock output line to be active low.\n This is sometimes called clock polarity high or clock idle high."]
            #[link_name = "\u{1}_ZN3frc3SPI17SetClockActiveLowEv"]
            pub fn SPI_SetClockActiveLow(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the clock output line to be active high.\n This is sometimes called clock polarity low or clock idle low."]
            #[link_name = "\u{1}_ZN3frc3SPI18SetClockActiveHighEv"]
            pub fn SPI_SetClockActiveHigh(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the chip select line to be active high."]
            #[link_name = "\u{1}_ZN3frc3SPI23SetChipSelectActiveHighEv"]
            pub fn SPI_SetChipSelectActiveHigh(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Configure the chip select line to be active low."]
            #[link_name = "\u{1}_ZN3frc3SPI22SetChipSelectActiveLowEv"]
            pub fn SPI_SetChipSelectActiveLow(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Initialize automatic SPI transfer engine.\n\n Only a single engine is available, and use of it blocks use of all other\n chip select usage on the same physical SPI port while it is running.\n\n @param bufferSize buffer size in bytes"]
            #[link_name = "\u{1}_ZN3frc3SPI8InitAutoEi"]
            pub fn SPI_InitAuto(this: *mut root::frc::SPI, bufferSize: ::std::os::raw::c_int);
        }
        extern "C" {
            #[doc = " Frees the automatic SPI transfer engine."]
            #[link_name = "\u{1}_ZN3frc3SPI8FreeAutoEv"]
            pub fn SPI_FreeAuto(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Set the data to be transmitted by the engine.\n\n Up to 16 bytes are configurable, and may be followed by up to 127 zero\n bytes.\n\n @param dataToSend data to send (maximum 16 bytes)\n @param zeroSize number of zeros to send after the data"]
            #[link_name = "\u{1}_ZN3frc3SPI19SetAutoTransmitDataEN3wpi4spanIKhLm18446744073709551615EEEi"]
            pub fn SPI_SetAutoTransmitData(
                this: *mut root::frc::SPI,
                dataToSend: u8,
                zeroSize: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Start running the automatic SPI transfer engine at a periodic rate.\n\n InitAuto() and SetAutoTransmitData() must be called before calling this\n function.\n\n @param period period between transfers (us resolution)"]
            #[link_name = "\u{1}_ZN3frc3SPI13StartAutoRateEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
            pub fn SPI_StartAutoRate(
                this: *mut root::frc::SPI,
                period: root::units::time::second_t,
            );
        }
        extern "C" {
            #[doc = " Start running the automatic SPI transfer engine at a periodic rate.\n\n InitAuto() and SetAutoTransmitData() must be called before calling this\n function.\n\n @deprecated use unit-safe StartAutoRate(units::second_t period) instead.\n\n @param period period between transfers, in seconds (us resolution)"]
            #[link_name = "\u{1}_ZN3frc3SPI13StartAutoRateEd"]
            pub fn SPI_StartAutoRate1(this: *mut root::frc::SPI, period: f64);
        }
        extern "C" {
            #[doc = " Start running the automatic SPI transfer engine when a trigger occurs.\n\n InitAuto() and SetAutoTransmitData() must be called before calling this\n function.\n\n @param source digital source for the trigger (may be an analog trigger)\n @param rising trigger on the rising edge\n @param falling trigger on the falling edge"]
            #[link_name = "\u{1}_ZN3frc3SPI16StartAutoTriggerERNS_13DigitalSourceEbb"]
            pub fn SPI_StartAutoTrigger(
                this: *mut root::frc::SPI,
                source: *mut root::frc::DigitalSource,
                rising: bool,
                falling: bool,
            );
        }
        extern "C" {
            #[doc = " Stop running the automatic SPI transfer engine."]
            #[link_name = "\u{1}_ZN3frc3SPI8StopAutoEv"]
            pub fn SPI_StopAuto(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Force the engine to make a single transfer."]
            #[link_name = "\u{1}_ZN3frc3SPI13ForceAutoReadEv"]
            pub fn SPI_ForceAutoRead(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Read data that has been transferred by the automatic SPI transfer engine.\n\n Transfers may be made a byte at a time, so it's necessary for the caller\n to handle cases where an entire transfer has not been completed.\n\n Each received data sequence consists of a timestamp followed by the\n received data bytes, one byte per word (in the least significant byte).\n The length of each received data sequence is the same as the combined\n size of the data and zeroSize set in SetAutoTransmitData().\n\n Blocks until numToRead words have been read or timeout expires.\n May be called with numToRead=0 to retrieve how many words are available.\n\n @param buffer buffer where read words are stored\n @param numToRead number of words to read\n @param timeout timeout (ms resolution)\n @return Number of words remaining to be read"]
            #[link_name = "\u{1}_ZN3frc3SPI20ReadAutoReceivedDataEPjiN5units6unit_tINS2_4unitISt5ratioILl1ELl1EENS2_9base_unitIS5_ILl0ELl1EES8_S6_S8_S8_S8_S8_S8_S8_EES8_S8_EEdNS2_12linear_scaleEEE"]
            pub fn SPI_ReadAutoReceivedData(
                this: *mut root::frc::SPI,
                buffer: *mut u32,
                numToRead: ::std::os::raw::c_int,
                timeout: root::units::time::second_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the number of bytes dropped by the automatic SPI transfer engine due\n to the receive buffer being full.\n\n @return Number of bytes dropped"]
            #[link_name = "\u{1}_ZN3frc3SPI19GetAutoDroppedCountEv"]
            pub fn SPI_GetAutoDroppedCount(this: *mut root::frc::SPI) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Configure the Auto SPI Stall time between reads.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP.\n @param csToSclkTicks the number of ticks to wait before asserting the cs\n pin\n @param stallTicks the number of ticks to stall for\n @param pow2BytesPerRead the number of bytes to read before stalling"]
            #[link_name = "\u{1}_ZN3frc3SPI18ConfigureAutoStallE11HAL_SPIPortiii"]
            pub fn SPI_ConfigureAutoStall(
                this: *mut root::frc::SPI,
                port: root::HAL_SPIPort,
                csToSclkTicks: ::std::os::raw::c_int,
                stallTicks: ::std::os::raw::c_int,
                pow2BytesPerRead: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Initialize the accumulator.\n\n @param period     Time between reads\n @param cmd        SPI command to send to request data\n @param xferSize   SPI transfer size, in bytes\n @param validMask  Mask to apply to received data for validity checking\n @param validValue After valid_mask is applied, required matching value for\n                   validity checking\n @param dataShift  Bit shift to apply to received data to get actual data\n                   value\n @param dataSize   Size (in bits) of data field\n @param isSigned   Is data field signed?\n @param bigEndian  Is device big endian?"]
            #[link_name = "\u{1}_ZN3frc3SPI15InitAccumulatorEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEEiiiiiibb"]
            pub fn SPI_InitAccumulator(
                this: *mut root::frc::SPI,
                period: root::units::time::second_t,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            );
        }
        extern "C" {
            #[doc = " Initialize the accumulator.\n\n @deprecated Use unit-safe version instead.\n             InitAccumulator(units::second_t period, int cmd, int <!--\n -->         xferSize, int validMask, int validValue, int dataShift, <!--\n -->         int dataSize, bool isSigned, bool bigEndian)\n\n @param period     Time between reads\n @param cmd        SPI command to send to request data\n @param xferSize   SPI transfer size, in bytes\n @param validMask  Mask to apply to received data for validity checking\n @param validValue After valid_mask is applied, required matching value for\n                   validity checking\n @param dataShift  Bit shift to apply to received data to get actual data\n                   value\n @param dataSize   Size (in bits) of data field\n @param isSigned   Is data field signed?\n @param bigEndian  Is device big endian?"]
            #[link_name = "\u{1}_ZN3frc3SPI15InitAccumulatorEdiiiiiibb"]
            pub fn SPI_InitAccumulator1(
                this: *mut root::frc::SPI,
                period: f64,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            );
        }
        extern "C" {
            #[doc = " Frees the accumulator."]
            #[link_name = "\u{1}_ZN3frc3SPI15FreeAccumulatorEv"]
            pub fn SPI_FreeAccumulator(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Resets the accumulator to zero."]
            #[link_name = "\u{1}_ZN3frc3SPI16ResetAccumulatorEv"]
            pub fn SPI_ResetAccumulator(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Set the center value of the accumulator.\n\n The center value is subtracted from each value before it is added to the\n accumulator. This is used for the center value of devices like gyros and\n accelerometers to make integration work and to take the device offset into\n account when integrating."]
            #[link_name = "\u{1}_ZN3frc3SPI20SetAccumulatorCenterEi"]
            pub fn SPI_SetAccumulatorCenter(
                this: *mut root::frc::SPI,
                center: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Set the accumulator's deadband."]
            #[link_name = "\u{1}_ZN3frc3SPI22SetAccumulatorDeadbandEi"]
            pub fn SPI_SetAccumulatorDeadband(
                this: *mut root::frc::SPI,
                deadband: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Read the last value read by the accumulator engine."]
            #[link_name = "\u{1}_ZNK3frc3SPI23GetAccumulatorLastValueEv"]
            pub fn SPI_GetAccumulatorLastValue(
                this: *const root::frc::SPI,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Read the accumulated value.\n\n @return The 64-bit value accumulated since the last Reset()."]
            #[link_name = "\u{1}_ZNK3frc3SPI19GetAccumulatorValueEv"]
            pub fn SPI_GetAccumulatorValue(this: *const root::frc::SPI) -> i64;
        }
        extern "C" {
            #[doc = " Read the number of accumulated values.\n\n Read the count of the accumulated values since the accumulator was last\n Reset().\n\n @return The number of times samples from the channel were accumulated."]
            #[link_name = "\u{1}_ZNK3frc3SPI19GetAccumulatorCountEv"]
            pub fn SPI_GetAccumulatorCount(this: *const root::frc::SPI) -> i64;
        }
        extern "C" {
            #[doc = " Read the average of the accumulated value.\n\n @return The accumulated average value (value / count)."]
            #[link_name = "\u{1}_ZNK3frc3SPI21GetAccumulatorAverageEv"]
            pub fn SPI_GetAccumulatorAverage(this: *const root::frc::SPI) -> f64;
        }
        extern "C" {
            #[doc = " Read the accumulated value and the number of accumulated values atomically.\n\n This function reads the value and count atomically.\n This can be used for averaging.\n\n @param value Pointer to the 64-bit accumulated output.\n @param count Pointer to the number of accumulation cycles."]
            #[link_name = "\u{1}_ZNK3frc3SPI20GetAccumulatorOutputERlS1_"]
            pub fn SPI_GetAccumulatorOutput(
                this: *const root::frc::SPI,
                value: *mut i64,
                count: *mut i64,
            );
        }
        extern "C" {
            #[doc = " Set the center value of the accumulator integrator.\n\n The center value is subtracted from each value*dt before it is added to the\n integrated value. This is used for the center value of devices like gyros\n and accelerometers to take the device offset into account when integrating."]
            #[link_name = "\u{1}_ZN3frc3SPI30SetAccumulatorIntegratedCenterEd"]
            pub fn SPI_SetAccumulatorIntegratedCenter(this: *mut root::frc::SPI, center: f64);
        }
        extern "C" {
            #[doc = " Read the integrated value.  This is the sum of (each value * time between\n values).\n\n @return The integrated value accumulated since the last Reset()."]
            #[link_name = "\u{1}_ZNK3frc3SPI29GetAccumulatorIntegratedValueEv"]
            pub fn SPI_GetAccumulatorIntegratedValue(this: *const root::frc::SPI) -> f64;
        }
        extern "C" {
            #[doc = " Read the average of the integrated value.  This is the sum of (each value\n times the time between values), divided by the count.\n\n @return The average of the integrated value accumulated since the last\n         Reset()."]
            #[link_name = "\u{1}_ZNK3frc3SPI31GetAccumulatorIntegratedAverageEv"]
            pub fn SPI_GetAccumulatorIntegratedAverage(this: *const root::frc::SPI) -> f64;
        }
        extern "C" {
            #[doc = " Constructor\n\n @param port the physical SPI port"]
            #[link_name = "\u{1}_ZN3frc3SPIC1ENS0_4PortE"]
            pub fn SPI_SPI(this: *mut root::frc::SPI, port: root::frc::SPI_Port);
        }
        impl SPI {
            #[inline]
            pub unsafe fn GetPort(&self) -> root::frc::SPI_Port {
                SPI_GetPort(self)
            }
            #[inline]
            pub unsafe fn SetClockRate(&mut self, hz: ::std::os::raw::c_int) {
                SPI_SetClockRate(self, hz)
            }
            #[inline]
            pub unsafe fn SetMSBFirst(&mut self) {
                SPI_SetMSBFirst(self)
            }
            #[inline]
            pub unsafe fn SetLSBFirst(&mut self) {
                SPI_SetLSBFirst(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnLeadingEdge(&mut self) {
                SPI_SetSampleDataOnLeadingEdge(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnTrailingEdge(&mut self) {
                SPI_SetSampleDataOnTrailingEdge(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnFalling(&mut self) {
                SPI_SetSampleDataOnFalling(self)
            }
            #[inline]
            pub unsafe fn SetSampleDataOnRising(&mut self) {
                SPI_SetSampleDataOnRising(self)
            }
            #[inline]
            pub unsafe fn SetClockActiveLow(&mut self) {
                SPI_SetClockActiveLow(self)
            }
            #[inline]
            pub unsafe fn SetClockActiveHigh(&mut self) {
                SPI_SetClockActiveHigh(self)
            }
            #[inline]
            pub unsafe fn SetChipSelectActiveHigh(&mut self) {
                SPI_SetChipSelectActiveHigh(self)
            }
            #[inline]
            pub unsafe fn SetChipSelectActiveLow(&mut self) {
                SPI_SetChipSelectActiveLow(self)
            }
            #[inline]
            pub unsafe fn InitAuto(&mut self, bufferSize: ::std::os::raw::c_int) {
                SPI_InitAuto(self, bufferSize)
            }
            #[inline]
            pub unsafe fn FreeAuto(&mut self) {
                SPI_FreeAuto(self)
            }
            #[inline]
            pub unsafe fn SetAutoTransmitData(
                &mut self,
                dataToSend: u8,
                zeroSize: ::std::os::raw::c_int,
            ) {
                SPI_SetAutoTransmitData(self, dataToSend, zeroSize)
            }
            #[inline]
            pub unsafe fn StartAutoRate(&mut self, period: root::units::time::second_t) {
                SPI_StartAutoRate(self, period)
            }
            #[inline]
            pub unsafe fn StartAutoRate1(&mut self, period: f64) {
                SPI_StartAutoRate1(self, period)
            }
            #[inline]
            pub unsafe fn StartAutoTrigger(
                &mut self,
                source: *mut root::frc::DigitalSource,
                rising: bool,
                falling: bool,
            ) {
                SPI_StartAutoTrigger(self, source, rising, falling)
            }
            #[inline]
            pub unsafe fn StopAuto(&mut self) {
                SPI_StopAuto(self)
            }
            #[inline]
            pub unsafe fn ForceAutoRead(&mut self) {
                SPI_ForceAutoRead(self)
            }
            #[inline]
            pub unsafe fn ReadAutoReceivedData(
                &mut self,
                buffer: *mut u32,
                numToRead: ::std::os::raw::c_int,
                timeout: root::units::time::second_t,
            ) -> ::std::os::raw::c_int {
                SPI_ReadAutoReceivedData(self, buffer, numToRead, timeout)
            }
            #[inline]
            pub unsafe fn GetAutoDroppedCount(&mut self) -> ::std::os::raw::c_int {
                SPI_GetAutoDroppedCount(self)
            }
            #[inline]
            pub unsafe fn ConfigureAutoStall(
                &mut self,
                port: root::HAL_SPIPort,
                csToSclkTicks: ::std::os::raw::c_int,
                stallTicks: ::std::os::raw::c_int,
                pow2BytesPerRead: ::std::os::raw::c_int,
            ) {
                SPI_ConfigureAutoStall(self, port, csToSclkTicks, stallTicks, pow2BytesPerRead)
            }
            #[inline]
            pub unsafe fn InitAccumulator(
                &mut self,
                period: root::units::time::second_t,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            ) {
                SPI_InitAccumulator(
                    self, period, cmd, xferSize, validMask, validValue, dataShift, dataSize,
                    isSigned, bigEndian,
                )
            }
            #[inline]
            pub unsafe fn InitAccumulator1(
                &mut self,
                period: f64,
                cmd: ::std::os::raw::c_int,
                xferSize: ::std::os::raw::c_int,
                validMask: ::std::os::raw::c_int,
                validValue: ::std::os::raw::c_int,
                dataShift: ::std::os::raw::c_int,
                dataSize: ::std::os::raw::c_int,
                isSigned: bool,
                bigEndian: bool,
            ) {
                SPI_InitAccumulator1(
                    self, period, cmd, xferSize, validMask, validValue, dataShift, dataSize,
                    isSigned, bigEndian,
                )
            }
            #[inline]
            pub unsafe fn FreeAccumulator(&mut self) {
                SPI_FreeAccumulator(self)
            }
            #[inline]
            pub unsafe fn ResetAccumulator(&mut self) {
                SPI_ResetAccumulator(self)
            }
            #[inline]
            pub unsafe fn SetAccumulatorCenter(&mut self, center: ::std::os::raw::c_int) {
                SPI_SetAccumulatorCenter(self, center)
            }
            #[inline]
            pub unsafe fn SetAccumulatorDeadband(&mut self, deadband: ::std::os::raw::c_int) {
                SPI_SetAccumulatorDeadband(self, deadband)
            }
            #[inline]
            pub unsafe fn GetAccumulatorLastValue(&self) -> ::std::os::raw::c_int {
                SPI_GetAccumulatorLastValue(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorValue(&self) -> i64 {
                SPI_GetAccumulatorValue(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorCount(&self) -> i64 {
                SPI_GetAccumulatorCount(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorAverage(&self) -> f64 {
                SPI_GetAccumulatorAverage(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorOutput(&self, value: *mut i64, count: *mut i64) {
                SPI_GetAccumulatorOutput(self, value, count)
            }
            #[inline]
            pub unsafe fn SetAccumulatorIntegratedCenter(&mut self, center: f64) {
                SPI_SetAccumulatorIntegratedCenter(self, center)
            }
            #[inline]
            pub unsafe fn GetAccumulatorIntegratedValue(&self) -> f64 {
                SPI_GetAccumulatorIntegratedValue(self)
            }
            #[inline]
            pub unsafe fn GetAccumulatorIntegratedAverage(&self) -> f64 {
                SPI_GetAccumulatorIntegratedAverage(self)
            }
            #[inline]
            pub unsafe fn new(port: root::frc::SPI_Port) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SPI_SPI(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc3SPID1Ev"]
            pub fn SPI_SPI_destructor(this: *mut root::frc::SPI);
        }
        extern "C" {
            #[doc = " Write data to the peripheral device.  Blocks until there is space in the\n output FIFO.\n\n If not running in output only mode, also saves the data received\n on the CIPO input during the transfer into the receive FIFO."]
            #[link_name = "\u{1}_ZN3frc3SPI5WriteEPhi"]
            pub fn SPI_Write(
                this: *mut ::std::os::raw::c_void,
                data: *mut u8,
                size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Read a word from the receive FIFO.\n\n Waits for the current transfer to complete if the receive FIFO is empty.\n\n If the receive FIFO is empty, there is no active transfer, and initiate\n is false, errors.\n\n @param initiate     If true, this function pushes \"0\" into the transmit\n                     buffer and initiates a transfer. If false, this\n                     function assumes that data is already in the receive\n                     FIFO from a previous write.\n @param dataReceived Buffer to receive data from the device\n @param size         The length of the transaction, in bytes"]
            #[link_name = "\u{1}_ZN3frc3SPI4ReadEbPhi"]
            pub fn SPI_Read(
                this: *mut ::std::os::raw::c_void,
                initiate: bool,
                dataReceived: *mut u8,
                size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Perform a simultaneous read/write transaction with the device\n\n @param dataToSend   The data to be written out to the device\n @param dataReceived Buffer to receive data from the device\n @param size         The length of the transaction, in bytes"]
            #[link_name = "\u{1}_ZN3frc3SPI11TransactionEPhS1_i"]
            pub fn SPI_Transaction(
                this: *mut ::std::os::raw::c_void,
                dataToSend: *mut u8,
                dataReceived: *mut u8,
                size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        #[repr(C)]
        pub struct Gyro__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface for yaw rate gyros."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Gyro {
            pub vtable_: *const Gyro__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_Gyro() {
            assert_eq!(
                ::std::mem::size_of::<Gyro>(),
                8usize,
                concat!("Size of: ", stringify!(Gyro))
            );
            assert_eq!(
                ::std::mem::align_of::<Gyro>(),
                8usize,
                concat!("Alignment of ", stringify!(Gyro))
            );
        }
        #[doc = " Use a rate gyro to return the robots heading relative to a starting position.\n\n The %Gyro class tracks the robots heading based on the starting position. As\n the robot rotates the new heading is computed by integrating the rate of\n rotation returned by the sensor. When the class is instantiated, it does a\n short calibration routine where it samples the gyro while at rest to\n determine the default offset. This is subtracted from each sample to\n determine the heading.\n\n This class is for the digital ADXRS450 gyro sensor that connects via SPI.\n Only one instance of an ADXRS %Gyro is supported."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ADXRS450_Gyro {
            pub _base: root::frc::Gyro,
            pub _base_1: root::wpi::Sendable,
            pub m_spi: root::frc::SPI,
            pub m_port: root::frc::SPI_Port,
            pub m_simDevice: root::hal::SimDevice,
            pub m_simAngle: root::hal::SimDouble,
            pub m_simRate: root::hal::SimDouble,
        }
        #[test]
        fn bindgen_test_layout_ADXRS450_Gyro() {
            const UNINIT: ::std::mem::MaybeUninit<ADXRS450_Gyro> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ADXRS450_Gyro>(),
                56usize,
                concat!("Size of: ", stringify!(ADXRS450_Gyro))
            );
            assert_eq!(
                ::std::mem::align_of::<ADXRS450_Gyro>(),
                8usize,
                concat!("Alignment of ", stringify!(ADXRS450_Gyro))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_spi) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ADXRS450_Gyro),
                    "::",
                    stringify!(m_spi)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ADXRS450_Gyro),
                    "::",
                    stringify!(m_port)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ADXRS450_Gyro),
                    "::",
                    stringify!(m_simDevice)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simAngle) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ADXRS450_Gyro),
                    "::",
                    stringify!(m_simAngle)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_simRate) as usize - ptr as usize },
                52usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ADXRS450_Gyro),
                    "::",
                    stringify!(m_simRate)
                )
            );
        }
        extern "C" {
            #[doc = " Get the SPI port number.\n\n @return The SPI port number."]
            #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro7GetPortEv"]
            pub fn ADXRS450_Gyro_GetPort(
                this: *const root::frc::ADXRS450_Gyro,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " %Gyro constructor on onboard CS0."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_GyroC1Ev"]
            pub fn ADXRS450_Gyro_ADXRS450_Gyro(this: *mut root::frc::ADXRS450_Gyro);
        }
        extern "C" {
            #[doc = " %Gyro constructor on the specified SPI port.\n\n @param port The SPI port the gyro is attached to."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_GyroC1ENS_3SPI4PortE"]
            pub fn ADXRS450_Gyro_ADXRS450_Gyro1(
                this: *mut root::frc::ADXRS450_Gyro,
                port: root::frc::SPI_Port,
            );
        }
        impl ADXRS450_Gyro {
            #[inline]
            pub unsafe fn GetPort(&self) -> ::std::os::raw::c_int {
                ADXRS450_Gyro_GetPort(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ADXRS450_Gyro_ADXRS450_Gyro(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(port: root::frc::SPI_Port) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ADXRS450_Gyro_ADXRS450_Gyro1(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[doc = " Return the actual angle in degrees that the robot is currently facing.\n\n The angle is based on integration of the returned rate from the gyro.\n The angle is continuous, that is it will continue from 360->361 degrees.\n This allows algorithms that wouldn't want to see a discontinuity in the\n gyro output as it sweeps from 360 to 0 on the second time around.\n\n @return the current heading of the robot in degrees."]
            #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro8GetAngleEv"]
            pub fn ADXRS450_Gyro_GetAngle(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Return the rate of rotation of the gyro\n\n The rate is based on the most recent reading of the gyro.\n\n @return the current rate in degrees per second"]
            #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro7GetRateEv"]
            pub fn ADXRS450_Gyro_GetRate(this: *mut ::std::os::raw::c_void) -> f64;
        }
        extern "C" {
            #[doc = " Reset the gyro.\n\n Resets the gyro to a heading of zero. This can be used if there is\n significant drift in the gyro and it needs to be recalibrated after it has\n been running."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_Gyro5ResetEv"]
            pub fn ADXRS450_Gyro_Reset(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Initialize the gyro.\n\n Calibrate the gyro by running for a number of samples and computing the\n center value. Then use the center value as the Accumulator center value for\n subsequent measurements.\n\n It's important to make sure that the robot is not moving while the\n centering calculations are in progress, this is typically done when the\n robot is first turned on while it's sitting at rest before the competition\n starts."]
            #[link_name = "\u{1}_ZN3frc13ADXRS450_Gyro9CalibrateEv"]
            pub fn ADXRS450_Gyro_Calibrate(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZThn8_N3frc13ADXRS450_Gyro12InitSendableERN3wpi15SendableBuilderE"]
            pub fn ADXRS450_Gyro_InitSendable(
                this: *mut ::std::os::raw::c_void,
                builder: *mut root::wpi::SendableBuilder,
            );
        }
        pub const AnalogTriggerType_kInWindow: root::frc::AnalogTriggerType = 0;
        pub const AnalogTriggerType_kState: root::frc::AnalogTriggerType = 1;
        pub const AnalogTriggerType_kRisingPulse: root::frc::AnalogTriggerType = 2;
        pub const AnalogTriggerType_kFallingPulse: root::frc::AnalogTriggerType = 3;
        pub type AnalogTriggerType = ::std::os::raw::c_int;
        #[repr(C)]
        pub struct DigitalSource__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " DigitalSource Interface.\n\n The DigitalSource represents all the possible inputs for a counter or a\n quadrature encoder. The source may be either a digital input or an analog\n input. If the caller just provides a channel, then a digital input will be\n constructed and freed when finished for the source. The source can either be\n a digital input or analog trigger but not both."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DigitalSource {
            pub vtable_: *const DigitalSource__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_DigitalSource() {
            assert_eq!(
                ::std::mem::size_of::<DigitalSource>(),
                8usize,
                concat!("Size of: ", stringify!(DigitalSource))
            );
            assert_eq!(
                ::std::mem::align_of::<DigitalSource>(),
                8usize,
                concat!("Alignment of ", stringify!(DigitalSource))
            );
        }
        #[repr(C)]
        pub struct GenericHID__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Handle input from standard HID devices connected to the Driver Station.\n\n <p>This class handles standard input that comes from the Driver Station. Each\n time a value is requested the most recent value is returned. There is a\n single class instance for each device and the mapping of ports to hardware\n buttons depends on the code in the Driver Station."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct GenericHID {
            pub vtable_: *const GenericHID__bindgen_vtable,
            pub m_port: ::std::os::raw::c_int,
            pub m_outputs: ::std::os::raw::c_int,
            pub m_leftRumble: u16,
            pub m_rightRumble: u16,
        }
        pub const GenericHID_RumbleType_kLeftRumble: root::frc::GenericHID_RumbleType = 0;
        pub const GenericHID_RumbleType_kRightRumble: root::frc::GenericHID_RumbleType = 1;
        pub type GenericHID_RumbleType = ::std::os::raw::c_uint;
        pub const GenericHID_HIDType_kUnknown: root::frc::GenericHID_HIDType = -1;
        pub const GenericHID_HIDType_kXInputUnknown: root::frc::GenericHID_HIDType = 0;
        pub const GenericHID_HIDType_kXInputGamepad: root::frc::GenericHID_HIDType = 1;
        pub const GenericHID_HIDType_kXInputWheel: root::frc::GenericHID_HIDType = 2;
        pub const GenericHID_HIDType_kXInputArcadeStick: root::frc::GenericHID_HIDType = 3;
        pub const GenericHID_HIDType_kXInputFlightStick: root::frc::GenericHID_HIDType = 4;
        pub const GenericHID_HIDType_kXInputDancePad: root::frc::GenericHID_HIDType = 5;
        pub const GenericHID_HIDType_kXInputGuitar: root::frc::GenericHID_HIDType = 6;
        pub const GenericHID_HIDType_kXInputGuitar2: root::frc::GenericHID_HIDType = 7;
        pub const GenericHID_HIDType_kXInputDrumKit: root::frc::GenericHID_HIDType = 8;
        pub const GenericHID_HIDType_kXInputGuitar3: root::frc::GenericHID_HIDType = 11;
        pub const GenericHID_HIDType_kXInputArcadePad: root::frc::GenericHID_HIDType = 19;
        pub const GenericHID_HIDType_kHIDJoystick: root::frc::GenericHID_HIDType = 20;
        pub const GenericHID_HIDType_kHIDGamepad: root::frc::GenericHID_HIDType = 21;
        pub const GenericHID_HIDType_kHIDDriving: root::frc::GenericHID_HIDType = 22;
        pub const GenericHID_HIDType_kHIDFlight: root::frc::GenericHID_HIDType = 23;
        pub const GenericHID_HIDType_kHID1stPerson: root::frc::GenericHID_HIDType = 24;
        pub type GenericHID_HIDType = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_GenericHID() {
            const UNINIT: ::std::mem::MaybeUninit<GenericHID> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GenericHID>(),
                24usize,
                concat!("Size of: ", stringify!(GenericHID))
            );
            assert_eq!(
                ::std::mem::align_of::<GenericHID>(),
                8usize,
                concat!("Alignment of ", stringify!(GenericHID))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GenericHID),
                    "::",
                    stringify!(m_port)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_outputs) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GenericHID),
                    "::",
                    stringify!(m_outputs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_leftRumble) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GenericHID),
                    "::",
                    stringify!(m_leftRumble)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_rightRumble) as usize - ptr as usize },
                18usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GenericHID),
                    "::",
                    stringify!(m_rightRumble)
                )
            );
        }
        extern "C" {
            #[doc = " Get the button value (starting at button 1).\n\n The buttons are returned in a single 16 bit value with one bit representing\n the state of each button. The appropriate button is returned as a boolean\n value.\n\n This method returns true if the button is being held down at the time\n that this method is being called.\n\n @param button The button number to be read (starting at 1)\n @return The state of the button."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID12GetRawButtonEi"]
            pub fn GenericHID_GetRawButton(
                this: *const root::frc::GenericHID,
                button: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the button was pressed since the last check. %Button indexes begin\n at 1.\n\n This method returns true if the button went from not pressed to held down\n since the last time this method was called. This is useful if you only\n want to call a function once when you press the button.\n\n @param button The button index, beginning at 1.\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc10GenericHID19GetRawButtonPressedEi"]
            pub fn GenericHID_GetRawButtonPressed(
                this: *mut root::frc::GenericHID,
                button: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the button was released since the last check. %Button indexes begin\n at 1.\n\n This method returns true if the button went from held down to not pressed\n since the last time this method was called. This is useful if you only\n want to call a function once when you release the button.\n\n @param button The button index, beginning at 1.\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc10GenericHID20GetRawButtonReleasedEi"]
            pub fn GenericHID_GetRawButtonReleased(
                this: *mut root::frc::GenericHID,
                button: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Get the value of the axis.\n\n @param axis The axis to read, starting at 0.\n @return The value of the axis."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID10GetRawAxisEi"]
            pub fn GenericHID_GetRawAxis(
                this: *const root::frc::GenericHID,
                axis: ::std::os::raw::c_int,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Get the angle in degrees of a POV on the HID.\n\n The POV angles start at 0 in the up direction, and increase clockwise\n (e.g. right is 90, upper-left is 315).\n\n @param pov The index of the POV to read (starting at 0)\n @return the angle of the POV in degrees, or -1 if the POV is not pressed."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID6GetPOVEi"]
            pub fn GenericHID_GetPOV(
                this: *const root::frc::GenericHID,
                pov: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the number of axes for the HID.\n\n @return the number of axis for the current HID"]
            #[link_name = "\u{1}_ZNK3frc10GenericHID12GetAxisCountEv"]
            pub fn GenericHID_GetAxisCount(
                this: *const root::frc::GenericHID,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the number of POVs for the HID.\n\n @return the number of POVs for the current HID"]
            #[link_name = "\u{1}_ZNK3frc10GenericHID11GetPOVCountEv"]
            pub fn GenericHID_GetPOVCount(
                this: *const root::frc::GenericHID,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the number of buttons for the HID.\n\n @return the number of buttons on the current HID"]
            #[link_name = "\u{1}_ZNK3frc10GenericHID14GetButtonCountEv"]
            pub fn GenericHID_GetButtonCount(
                this: *const root::frc::GenericHID,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get if the HID is connected.\n\n @return true if the HID is connected"]
            #[link_name = "\u{1}_ZNK3frc10GenericHID11IsConnectedEv"]
            pub fn GenericHID_IsConnected(this: *const root::frc::GenericHID) -> bool;
        }
        extern "C" {
            #[doc = " Get the type of the HID.\n\n @return the type of the HID."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID7GetTypeEv"]
            pub fn GenericHID_GetType(
                this: *const root::frc::GenericHID,
            ) -> root::frc::GenericHID_HIDType;
        }
        extern "C" {
            #[doc = " Get the name of the HID.\n\n @return the name of the HID."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID7GetNameB5cxx11Ev"]
            pub fn GenericHID_GetName(this: *const root::frc::GenericHID) -> root::std::string;
        }
        extern "C" {
            #[doc = " Get the axis type of a joystick axis.\n\n @return the axis type of a joystick axis."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID11GetAxisTypeEi"]
            pub fn GenericHID_GetAxisType(
                this: *const root::frc::GenericHID,
                axis: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Get the port number of the HID.\n\n @return The port number of the HID."]
            #[link_name = "\u{1}_ZNK3frc10GenericHID7GetPortEv"]
            pub fn GenericHID_GetPort(this: *const root::frc::GenericHID) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[doc = " Set a single HID output value for the HID.\n\n @param outputNumber The index of the output to set (1-32)\n @param value        The value to set the output to"]
            #[link_name = "\u{1}_ZN3frc10GenericHID9SetOutputEib"]
            pub fn GenericHID_SetOutput(
                this: *mut root::frc::GenericHID,
                outputNumber: ::std::os::raw::c_int,
                value: bool,
            );
        }
        extern "C" {
            #[doc = " Set all output values for the HID.\n\n @param value The 32 bit output value (1 bit for each output)"]
            #[link_name = "\u{1}_ZN3frc10GenericHID10SetOutputsEi"]
            pub fn GenericHID_SetOutputs(
                this: *mut root::frc::GenericHID,
                value: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[doc = " Set the rumble output for the HID.\n\n The DS currently supports 2 rumble values, left rumble and right rumble.\n\n @param type  Which rumble value to set\n @param value The normalized value (0 to 1) to set the rumble to"]
            #[link_name = "\u{1}_ZN3frc10GenericHID9SetRumbleENS0_10RumbleTypeEd"]
            pub fn GenericHID_SetRumble(
                this: *mut root::frc::GenericHID,
                type_: root::frc::GenericHID_RumbleType,
                value: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc10GenericHIDC1Ei"]
            pub fn GenericHID_GenericHID(
                this: *mut root::frc::GenericHID,
                port: ::std::os::raw::c_int,
            );
        }
        impl GenericHID {
            #[inline]
            pub unsafe fn GetRawButton(&self, button: ::std::os::raw::c_int) -> bool {
                GenericHID_GetRawButton(self, button)
            }
            #[inline]
            pub unsafe fn GetRawButtonPressed(&mut self, button: ::std::os::raw::c_int) -> bool {
                GenericHID_GetRawButtonPressed(self, button)
            }
            #[inline]
            pub unsafe fn GetRawButtonReleased(&mut self, button: ::std::os::raw::c_int) -> bool {
                GenericHID_GetRawButtonReleased(self, button)
            }
            #[inline]
            pub unsafe fn GetRawAxis(&self, axis: ::std::os::raw::c_int) -> f64 {
                GenericHID_GetRawAxis(self, axis)
            }
            #[inline]
            pub unsafe fn GetPOV(&self, pov: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
                GenericHID_GetPOV(self, pov)
            }
            #[inline]
            pub unsafe fn GetAxisCount(&self) -> ::std::os::raw::c_int {
                GenericHID_GetAxisCount(self)
            }
            #[inline]
            pub unsafe fn GetPOVCount(&self) -> ::std::os::raw::c_int {
                GenericHID_GetPOVCount(self)
            }
            #[inline]
            pub unsafe fn GetButtonCount(&self) -> ::std::os::raw::c_int {
                GenericHID_GetButtonCount(self)
            }
            #[inline]
            pub unsafe fn IsConnected(&self) -> bool {
                GenericHID_IsConnected(self)
            }
            #[inline]
            pub unsafe fn GetType(&self) -> root::frc::GenericHID_HIDType {
                GenericHID_GetType(self)
            }
            #[inline]
            pub unsafe fn GetName(&self) -> root::std::string {
                GenericHID_GetName(self)
            }
            #[inline]
            pub unsafe fn GetAxisType(&self, axis: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
                GenericHID_GetAxisType(self, axis)
            }
            #[inline]
            pub unsafe fn GetPort(&self) -> ::std::os::raw::c_int {
                GenericHID_GetPort(self)
            }
            #[inline]
            pub unsafe fn SetOutput(&mut self, outputNumber: ::std::os::raw::c_int, value: bool) {
                GenericHID_SetOutput(self, outputNumber, value)
            }
            #[inline]
            pub unsafe fn SetOutputs(&mut self, value: ::std::os::raw::c_int) {
                GenericHID_SetOutputs(self, value)
            }
            #[inline]
            pub unsafe fn SetRumble(
                &mut self,
                type_: root::frc::GenericHID_RumbleType,
                value: f64,
            ) {
                GenericHID_SetRumble(self, type_, value)
            }
            #[inline]
            pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                GenericHID_GenericHID(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
        pub const RuntimeType_kRoboRIO: root::frc::RuntimeType = 0;
        pub const RuntimeType_kRoboRIO2: root::frc::RuntimeType = 1;
        pub const RuntimeType_kSimulation: root::frc::RuntimeType = 2;
        pub type RuntimeType = ::std::os::raw::c_uint;
        #[repr(C)]
        pub struct RobotBase__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Implement a Robot Program framework.\n\n The RobotBase class is intended to be subclassed by a user creating a robot\n program. Overridden Autonomous() and OperatorControl() methods are called at\n the appropriate time as the match proceeds. In the current implementation,\n the Autonomous code will run to completion before the OperatorControl code\n could start. In the future the Autonomous code might be spawned as a task,\n then killed at the end of the Autonomous period."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct RobotBase {
            pub vtable_: *const RobotBase__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc9RobotBase10m_threadIdE"]
            pub static mut RobotBase_m_threadId: root::std::thread_id;
        }
        #[test]
        fn bindgen_test_layout_RobotBase() {
            assert_eq!(
                ::std::mem::size_of::<RobotBase>(),
                8usize,
                concat!("Size of: ", stringify!(RobotBase))
            );
            assert_eq!(
                ::std::mem::align_of::<RobotBase>(),
                8usize,
                concat!("Alignment of ", stringify!(RobotBase))
            );
        }
        extern "C" {
            #[doc = " Determine if the Robot is currently enabled.\n\n @return True if the Robot is currently enabled by the field controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase9IsEnabledEv"]
            pub fn RobotBase_IsEnabled(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the Robot is currently disabled.\n\n @return True if the Robot is currently disabled by the field controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase10IsDisabledEv"]
            pub fn RobotBase_IsDisabled(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is currently in Autonomous mode.\n\n @return True if the robot is currently operating Autonomously as determined\n         by the field controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase12IsAutonomousEv"]
            pub fn RobotBase_IsAutonomous(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is currently in Autonomous mode and enabled.\n\n @return True if the robot us currently operating Autonomously while enabled\n as determined by the field controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase19IsAutonomousEnabledEv"]
            pub fn RobotBase_IsAutonomousEnabled(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is currently in Operator Control mode.\n\n @return True if the robot is currently operating in Tele-Op mode as\n         determined by the field controls.\n @deprecated Use IsTeleop() instead."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase17IsOperatorControlEv"]
            pub fn RobotBase_IsOperatorControl(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is currently in Operator Control mode.\n\n @return True if the robot is currently operating in Tele-Op mode as\n         determined by the field controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase8IsTeleopEv"]
            pub fn RobotBase_IsTeleop(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is current in Operator Control mode and enabled.\n\n @return True if the robot is currently operating in Tele-Op mode while\n         enabled as determined by the field-controls.\n @deprecated Use IsTeleopEnabled() instead."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase24IsOperatorControlEnabledEv"]
            pub fn RobotBase_IsOperatorControlEnabled(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is current in Operator Control mode and enabled.\n\n @return True if the robot is currently operating in Tele-Op mode while\n wnabled as determined by the field-controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase15IsTeleopEnabledEv"]
            pub fn RobotBase_IsTeleopEnabled(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Determine if the robot is currently in Test mode.\n\n @return True if the robot is currently running tests as determined by the\n         field controls."]
            #[link_name = "\u{1}_ZNK3frc9RobotBase6IsTestEv"]
            pub fn RobotBase_IsTest(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Indicates if new data is available from the driver station.\n\n @return Has new data arrived over the network since the last time this\n         function was called?"]
            #[link_name = "\u{1}_ZNK3frc9RobotBase18IsNewDataAvailableEv"]
            pub fn RobotBase_IsNewDataAvailable(this: *const root::frc::RobotBase) -> bool;
        }
        extern "C" {
            #[doc = " Gets the ID of the main robot thread."]
            #[link_name = "\u{1}_ZN3frc9RobotBase11GetThreadIdEv"]
            pub fn RobotBase_GetThreadId() -> root::std::thread_id;
        }
        extern "C" {
            #[doc = " Get the current runtime type.\n\n @return Current runtime type."]
            #[link_name = "\u{1}_ZN3frc9RobotBase14GetRuntimeTypeEv"]
            pub fn RobotBase_GetRuntimeType() -> root::frc::RuntimeType;
        }
        extern "C" {
            #[doc = " Constructor for a generic robot program.\n\n User code should be placed in the constructor that runs before the\n Autonomous or Operator Control period starts. The constructor will run to\n completion before Autonomous is entered.\n\n This must be used to ensure that the communications code starts. In the\n future it would be nice to put this code into it's own task that loads on\n boot so ensure that it runs."]
            #[link_name = "\u{1}_ZN3frc9RobotBaseC2Ev"]
            pub fn RobotBase_RobotBase(this: *mut root::frc::RobotBase);
        }
        impl RobotBase {
            #[inline]
            pub unsafe fn IsEnabled(&self) -> bool {
                RobotBase_IsEnabled(self)
            }
            #[inline]
            pub unsafe fn IsDisabled(&self) -> bool {
                RobotBase_IsDisabled(self)
            }
            #[inline]
            pub unsafe fn IsAutonomous(&self) -> bool {
                RobotBase_IsAutonomous(self)
            }
            #[inline]
            pub unsafe fn IsAutonomousEnabled(&self) -> bool {
                RobotBase_IsAutonomousEnabled(self)
            }
            #[inline]
            pub unsafe fn IsOperatorControl(&self) -> bool {
                RobotBase_IsOperatorControl(self)
            }
            #[inline]
            pub unsafe fn IsTeleop(&self) -> bool {
                RobotBase_IsTeleop(self)
            }
            #[inline]
            pub unsafe fn IsOperatorControlEnabled(&self) -> bool {
                RobotBase_IsOperatorControlEnabled(self)
            }
            #[inline]
            pub unsafe fn IsTeleopEnabled(&self) -> bool {
                RobotBase_IsTeleopEnabled(self)
            }
            #[inline]
            pub unsafe fn IsTest(&self) -> bool {
                RobotBase_IsTest(self)
            }
            #[inline]
            pub unsafe fn IsNewDataAvailable(&self) -> bool {
                RobotBase_IsNewDataAvailable(self)
            }
            #[inline]
            pub unsafe fn GetThreadId() -> root::std::thread_id {
                RobotBase_GetThreadId()
            }
            #[inline]
            pub unsafe fn GetRuntimeType() -> root::frc::RuntimeType {
                RobotBase_GetRuntimeType()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                RobotBase_RobotBase(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " A class for keeping track of how much time it takes for different parts of\n code to execute. This is done with epochs, that are added to calls to\n AddEpoch() and can be printed with a call to PrintEpochs().\n\n Epochs are a way to partition the time elapsed so that when overruns occur,\n one can determine which parts of an operation consumed the most time."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Tracer {
            pub m_startTime: root::hal::fpga_clock_time_point,
            pub m_lastEpochsPrintTime: root::hal::fpga_clock_time_point,
            pub m_epochs: root::wpi::StringMap,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc6Tracer15kMinPrintPeriodE"]
            pub static Tracer_kMinPrintPeriod: root::std::chrono::milliseconds;
        }
        #[test]
        fn bindgen_test_layout_Tracer() {
            const UNINIT: ::std::mem::MaybeUninit<Tracer> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Tracer>(),
                40usize,
                concat!("Size of: ", stringify!(Tracer))
            );
            assert_eq!(
                ::std::mem::align_of::<Tracer>(),
                8usize,
                concat!("Alignment of ", stringify!(Tracer))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tracer),
                    "::",
                    stringify!(m_startTime)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_lastEpochsPrintTime) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tracer),
                    "::",
                    stringify!(m_lastEpochsPrintTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_epochs) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tracer),
                    "::",
                    stringify!(m_epochs)
                )
            );
        }
        extern "C" {
            #[doc = " Restarts the epoch timer."]
            #[link_name = "\u{1}_ZN3frc6Tracer10ResetTimerEv"]
            pub fn Tracer_ResetTimer(this: *mut root::frc::Tracer);
        }
        extern "C" {
            #[doc = " Clears all epochs."]
            #[link_name = "\u{1}_ZN3frc6Tracer11ClearEpochsEv"]
            pub fn Tracer_ClearEpochs(this: *mut root::frc::Tracer);
        }
        extern "C" {
            #[doc = " Adds time since last epoch to the list printed by PrintEpochs().\n\n Epochs are a way to partition the time elapsed so that when overruns occur,\n one can determine which parts of an operation consumed the most time.\n\n @param epochName The name to associate with the epoch."]
            #[link_name = "\u{1}_ZN3frc6Tracer8AddEpochESt17basic_string_viewIcSt11char_traitsIcEE"]
            pub fn Tracer_AddEpoch(this: *mut root::frc::Tracer, epochName: root::std::string_view);
        }
        extern "C" {
            #[doc = " Prints list of epochs added so far and their times to the DriverStation."]
            #[link_name = "\u{1}_ZN3frc6Tracer11PrintEpochsEv"]
            pub fn Tracer_PrintEpochs(this: *mut root::frc::Tracer);
        }
        extern "C" {
            #[doc = " Prints list of epochs added so far and their times to a stream.\n\n @param os output stream"]
            #[link_name = "\u{1}_ZN3frc6Tracer11PrintEpochsERN3wpi11raw_ostreamE"]
            pub fn Tracer_PrintEpochs1(
                this: *mut root::frc::Tracer,
                os: *mut root::wpi::raw_ostream,
            );
        }
        extern "C" {
            #[doc = " Constructs a Tracer instance."]
            #[link_name = "\u{1}_ZN3frc6TracerC1Ev"]
            pub fn Tracer_Tracer(this: *mut root::frc::Tracer);
        }
        impl Tracer {
            #[inline]
            pub unsafe fn ResetTimer(&mut self) {
                Tracer_ResetTimer(self)
            }
            #[inline]
            pub unsafe fn ClearEpochs(&mut self) {
                Tracer_ClearEpochs(self)
            }
            #[inline]
            pub unsafe fn AddEpoch(&mut self, epochName: root::std::string_view) {
                Tracer_AddEpoch(self, epochName)
            }
            #[inline]
            pub unsafe fn PrintEpochs(&mut self) {
                Tracer_PrintEpochs(self)
            }
            #[inline]
            pub unsafe fn PrintEpochs1(&mut self, os: *mut root::wpi::raw_ostream) {
                Tracer_PrintEpochs1(self, os)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Tracer_Tracer(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " A class that's a wrapper around a watchdog timer.\n\n When the timer expires, a message is printed to the console and an optional\n user-provided callback is invoked.\n\n The watchdog is initialized disabled, so the user needs to call Enable()\n before use."]
        #[repr(C)]
        pub struct Watchdog {
            pub m_startTime: root::units::time::second_t,
            pub m_timeout: root::units::time::second_t,
            pub m_expirationTime: root::units::time::second_t,
            pub m_callback: [u64; 4usize],
            pub m_lastTimeoutPrintTime: root::units::time::second_t,
            pub m_tracer: root::frc::Tracer,
            pub m_isExpired: bool,
            pub m_suppressTimeoutMessage: bool,
            pub m_impl: *mut root::frc::Watchdog_Impl,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Watchdog_Impl {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc8Watchdog15kMinPrintPeriodE"]
            pub static Watchdog_kMinPrintPeriod: root::units::unit_t;
        }
        #[test]
        fn bindgen_test_layout_Watchdog() {
            const UNINIT: ::std::mem::MaybeUninit<Watchdog> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Watchdog>(),
                120usize,
                concat!("Size of: ", stringify!(Watchdog))
            );
            assert_eq!(
                ::std::mem::align_of::<Watchdog>(),
                8usize,
                concat!("Alignment of ", stringify!(Watchdog))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_startTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_timeout) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_timeout)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_expirationTime) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_expirationTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_callback) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_callback)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_lastTimeoutPrintTime) as usize - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_lastTimeoutPrintTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_tracer) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_tracer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isExpired) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_isExpired)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_suppressTimeoutMessage) as usize - ptr as usize
                },
                105usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_suppressTimeoutMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_impl) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Watchdog),
                    "::",
                    stringify!(m_impl)
                )
            );
        }
        extern "C" {
            #[doc = " Returns the time since the watchdog was last fed."]
            #[link_name = "\u{1}_ZNK3frc8Watchdog7GetTimeEv"]
            pub fn Watchdog_GetTime(
                this: *const root::frc::Watchdog,
            ) -> root::units::time::second_t;
        }
        extern "C" {
            #[doc = " Sets the watchdog's timeout.\n\n @param timeout The watchdog's timeout in seconds with microsecond\n                resolution."]
            #[link_name = "\u{1}_ZN3frc8Watchdog10SetTimeoutEN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
            pub fn Watchdog_SetTimeout(
                this: *mut root::frc::Watchdog,
                timeout: root::units::time::second_t,
            );
        }
        extern "C" {
            #[doc = " Returns the watchdog's timeout."]
            #[link_name = "\u{1}_ZNK3frc8Watchdog10GetTimeoutEv"]
            pub fn Watchdog_GetTimeout(
                this: *const root::frc::Watchdog,
            ) -> root::units::time::second_t;
        }
        extern "C" {
            #[doc = " Returns true if the watchdog timer has expired."]
            #[link_name = "\u{1}_ZNK3frc8Watchdog9IsExpiredEv"]
            pub fn Watchdog_IsExpired(this: *const root::frc::Watchdog) -> bool;
        }
        extern "C" {
            #[doc = " Adds time since last epoch to the list printed by PrintEpochs().\n\n Epochs are a way to partition the time elapsed so that when overruns occur,\n one can determine which parts of an operation consumed the most time.\n\n @param epochName The name to associate with the epoch."]
            #[link_name = "\u{1}_ZN3frc8Watchdog8AddEpochESt17basic_string_viewIcSt11char_traitsIcEE"]
            pub fn Watchdog_AddEpoch(
                this: *mut root::frc::Watchdog,
                epochName: root::std::string_view,
            );
        }
        extern "C" {
            #[doc = " Prints list of epochs added so far and their times."]
            #[link_name = "\u{1}_ZN3frc8Watchdog11PrintEpochsEv"]
            pub fn Watchdog_PrintEpochs(this: *mut root::frc::Watchdog);
        }
        extern "C" {
            #[doc = " Resets the watchdog timer.\n\n This also enables the timer if it was previously disabled."]
            #[link_name = "\u{1}_ZN3frc8Watchdog5ResetEv"]
            pub fn Watchdog_Reset(this: *mut root::frc::Watchdog);
        }
        extern "C" {
            #[doc = " Enables the watchdog timer."]
            #[link_name = "\u{1}_ZN3frc8Watchdog6EnableEv"]
            pub fn Watchdog_Enable(this: *mut root::frc::Watchdog);
        }
        extern "C" {
            #[doc = " Disables the watchdog timer."]
            #[link_name = "\u{1}_ZN3frc8Watchdog7DisableEv"]
            pub fn Watchdog_Disable(this: *mut root::frc::Watchdog);
        }
        extern "C" {
            #[doc = " Enable or disable suppression of the generic timeout message.\n\n This may be desirable if the user-provided callback already prints a more\n specific message.\n\n @param suppress Whether to suppress generic timeout message."]
            #[link_name = "\u{1}_ZN3frc8Watchdog22SuppressTimeoutMessageEb"]
            pub fn Watchdog_SuppressTimeoutMessage(this: *mut root::frc::Watchdog, suppress: bool);
        }
        extern "C" {
            #[doc = " Watchdog constructor.\n\n @param timeout  The watchdog's timeout in seconds with microsecond\n                 resolution.\n @param callback This function is called when the timeout expires."]
            #[link_name = "\u{1}_ZN3frc8WatchdogC1EN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEESt8functionIFvvEE"]
            pub fn Watchdog_Watchdog(
                this: *mut root::frc::Watchdog,
                timeout: root::units::time::second_t,
                callback: [u64; 4usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc8WatchdogC1EOS0_"]
            pub fn Watchdog_Watchdog1(
                this: *mut root::frc::Watchdog,
                rhs: *mut root::frc::Watchdog,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc8WatchdogD1Ev"]
            pub fn Watchdog_Watchdog_destructor(this: *mut root::frc::Watchdog);
        }
        impl Watchdog {
            #[inline]
            pub unsafe fn GetTime(&self) -> root::units::time::second_t {
                Watchdog_GetTime(self)
            }
            #[inline]
            pub unsafe fn SetTimeout(&mut self, timeout: root::units::time::second_t) {
                Watchdog_SetTimeout(self, timeout)
            }
            #[inline]
            pub unsafe fn GetTimeout(&self) -> root::units::time::second_t {
                Watchdog_GetTimeout(self)
            }
            #[inline]
            pub unsafe fn IsExpired(&self) -> bool {
                Watchdog_IsExpired(self)
            }
            #[inline]
            pub unsafe fn AddEpoch(&mut self, epochName: root::std::string_view) {
                Watchdog_AddEpoch(self, epochName)
            }
            #[inline]
            pub unsafe fn PrintEpochs(&mut self) {
                Watchdog_PrintEpochs(self)
            }
            #[inline]
            pub unsafe fn Reset(&mut self) {
                Watchdog_Reset(self)
            }
            #[inline]
            pub unsafe fn Enable(&mut self) {
                Watchdog_Enable(self)
            }
            #[inline]
            pub unsafe fn Disable(&mut self) {
                Watchdog_Disable(self)
            }
            #[inline]
            pub unsafe fn SuppressTimeoutMessage(&mut self, suppress: bool) {
                Watchdog_SuppressTimeoutMessage(self, suppress)
            }
            #[inline]
            pub unsafe fn new(
                timeout: root::units::time::second_t,
                callback: [u64; 4usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Watchdog_Watchdog(__bindgen_tmp.as_mut_ptr(), timeout, callback);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(rhs: *mut root::frc::Watchdog) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Watchdog_Watchdog1(__bindgen_tmp.as_mut_ptr(), rhs);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Watchdog_Watchdog_destructor(self)
            }
        }
        #[test]
        fn __bindgen_test_layout_unit_t_open0__bindgen_ty_id_118756_open1_ratio_open2_close2_base_unit_open2_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_close2_ratio_open2_close2_ratio_open2_close2_close1_double_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::units::unit_t>(),
                8usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::units::unit_t)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::units::unit_t>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::units::unit_t)
                )
            );
        }
        #[doc = " IterativeRobotBase implements a specific type of robot program framework,\n extending the RobotBase class.\n\n The IterativeRobotBase class does not implement StartCompetition(), so it\n should not be used by teams directly.\n\n This class provides the following functions which are called by the main\n loop, StartCompetition(), at the appropriate times:\n\n RobotInit() -- provide for initialization at robot power-on\n\n Init() functions -- each of the following functions is called once when the\n appropriate mode is entered:\n\n \\li DisabledInit() -- called each and every time disabled is entered from\n   another mode\n \\li AutonomousInit() -- called each and every time autonomous is entered from\n   another mode\n \\li TeleopInit() -- called each and every time teleop is entered from another\n   mode\n \\li TestInit() -- called each and every time test is entered from another\n   mode\n\n Periodic() functions -- each of these functions is called on an interval:\n\n \\li RobotPeriodic()\n \\li DisabledPeriodic()\n \\li AutonomousPeriodic()\n \\li TeleopPeriodic()\n \\li TestPeriodic()\n\n Exit() functions -- each of the following functions is called once when the\n appropriate mode is exited:\n\n \\li DisabledExit() -- called each and every time disabled is exited\n \\li AutonomousExit() -- called each and every time autonomous is exited\n \\li TeleopExit() -- called each and every time teleop is exited\n \\li TestExit() -- called each and every time test is exited"]
        #[repr(C)]
        pub struct IterativeRobotBase {
            pub _base: root::frc::RobotBase,
            pub m_lastMode: root::frc::IterativeRobotBase_Mode,
            pub m_period: root::units::time::second_t,
            pub m_watchdog: root::frc::Watchdog,
            pub m_ntFlushEnabled: bool,
        }
        pub const IterativeRobotBase_Mode_kNone: root::frc::IterativeRobotBase_Mode = 0;
        pub const IterativeRobotBase_Mode_kDisabled: root::frc::IterativeRobotBase_Mode = 1;
        pub const IterativeRobotBase_Mode_kAutonomous: root::frc::IterativeRobotBase_Mode = 2;
        pub const IterativeRobotBase_Mode_kTeleop: root::frc::IterativeRobotBase_Mode = 3;
        pub const IterativeRobotBase_Mode_kTest: root::frc::IterativeRobotBase_Mode = 4;
        pub type IterativeRobotBase_Mode = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_IterativeRobotBase() {
            const UNINIT: ::std::mem::MaybeUninit<IterativeRobotBase> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<IterativeRobotBase>(),
                152usize,
                concat!("Size of: ", stringify!(IterativeRobotBase))
            );
            assert_eq!(
                ::std::mem::align_of::<IterativeRobotBase>(),
                8usize,
                concat!("Alignment of ", stringify!(IterativeRobotBase))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_lastMode) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IterativeRobotBase),
                    "::",
                    stringify!(m_lastMode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_period) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IterativeRobotBase),
                    "::",
                    stringify!(m_period)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_watchdog) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IterativeRobotBase),
                    "::",
                    stringify!(m_watchdog)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ntFlushEnabled) as usize - ptr as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IterativeRobotBase),
                    "::",
                    stringify!(m_ntFlushEnabled)
                )
            );
        }
        extern "C" {
            #[doc = " Enables or disables flushing NetworkTables every loop iteration.\n By default, this is disabled.\n\n @param enabled True to enable, false to disable"]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase28SetNetworkTablesFlushEnabledEb"]
            pub fn IterativeRobotBase_SetNetworkTablesFlushEnabled(
                this: *mut root::frc::IterativeRobotBase,
                enabled: bool,
            );
        }
        extern "C" {
            #[doc = " Gets time period between calls to Periodic() functions."]
            #[link_name = "\u{1}_ZNK3frc18IterativeRobotBase9GetPeriodEv"]
            pub fn IterativeRobotBase_GetPeriod(
                this: *const root::frc::IterativeRobotBase,
            ) -> root::units::time::second_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase8LoopFuncEv"]
            pub fn IterativeRobotBase_LoopFunc(this: *mut root::frc::IterativeRobotBase);
        }
        extern "C" {
            #[doc = " Constructor for IterativeRobotBase.\n\n @param period Period in seconds.\n\n @deprecated Use IterativeRobotBase(units::second_t period) with unit-safety\n instead"]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBaseC2Ed"]
            pub fn IterativeRobotBase_IterativeRobotBase(
                this: *mut root::frc::IterativeRobotBase,
                period: f64,
            );
        }
        extern "C" {
            #[doc = " Constructor for IterativeRobotBase.\n\n @param period Period."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBaseC2EN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
            pub fn IterativeRobotBase_IterativeRobotBase1(
                this: *mut root::frc::IterativeRobotBase,
                period: root::units::time::second_t,
            );
        }
        impl IterativeRobotBase {
            #[inline]
            pub unsafe fn SetNetworkTablesFlushEnabled(&mut self, enabled: bool) {
                IterativeRobotBase_SetNetworkTablesFlushEnabled(self, enabled)
            }
            #[inline]
            pub unsafe fn GetPeriod(&self) -> root::units::time::second_t {
                IterativeRobotBase_GetPeriod(self)
            }
            #[inline]
            pub unsafe fn LoopFunc(&mut self) {
                IterativeRobotBase_LoopFunc(self)
            }
            #[inline]
            pub unsafe fn new(period: f64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                IterativeRobotBase_IterativeRobotBase(__bindgen_tmp.as_mut_ptr(), period);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(period: root::units::time::second_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                IterativeRobotBase_IterativeRobotBase1(__bindgen_tmp.as_mut_ptr(), period);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[doc = " Robot-wide initialization code should go here.\n\n Users should override this method for default Robot-wide initialization\n which will be called when the robot is first powered on. It will be called\n exactly one time.\n\n Warning: the Driver Station \"Robot Code\" light and FMS \"Robot Ready\"\n indicators will be off until RobotInit() exits. Code in RobotInit() that\n waits for enable will cause the robot to never indicate that the code is\n ready, causing the robot to be bypassed in a match."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase9RobotInitEv"]
            pub fn IterativeRobotBase_RobotInit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Robot-wide simulation initialization code should go here.\n\n Users should override this method for default Robot-wide simulation\n related initialization which will be called when the robot is first\n started. It will be called exactly one time after RobotInit is called\n only when the robot is in simulation."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14SimulationInitEv"]
            pub fn IterativeRobotBase_SimulationInit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Initialization code for disabled mode should go here.\n\n Users should override this method for initialization code which will be\n called each time\n the robot enters disabled mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase12DisabledInitEv"]
            pub fn IterativeRobotBase_DisabledInit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Initialization code for autonomous mode should go here.\n\n Users should override this method for initialization code which will be\n called each time the robot enters autonomous mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14AutonomousInitEv"]
            pub fn IterativeRobotBase_AutonomousInit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Initialization code for teleop mode should go here.\n\n Users should override this method for initialization code which will be\n called each time the robot enters teleop mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase10TeleopInitEv"]
            pub fn IterativeRobotBase_TeleopInit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Initialization code for test mode should go here.\n\n Users should override this method for initialization code which will be\n called each time the robot enters test mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase8TestInitEv"]
            pub fn IterativeRobotBase_TestInit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Periodic code for all modes should go here.\n\n This function is called each time a new packet is received from the driver\n station."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase13RobotPeriodicEv"]
            pub fn IterativeRobotBase_RobotPeriodic(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Periodic simulation code should go here.\n\n This function is called in a simulated robot after user code executes."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase18SimulationPeriodicEv"]
            pub fn IterativeRobotBase_SimulationPeriodic(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Periodic code for disabled mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in disabled\n mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase16DisabledPeriodicEv"]
            pub fn IterativeRobotBase_DisabledPeriodic(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Periodic code for autonomous mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in\n autonomous mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase18AutonomousPeriodicEv"]
            pub fn IterativeRobotBase_AutonomousPeriodic(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Periodic code for teleop mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in teleop\n mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14TeleopPeriodicEv"]
            pub fn IterativeRobotBase_TeleopPeriodic(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Periodic code for test mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in test\n mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase12TestPeriodicEv"]
            pub fn IterativeRobotBase_TestPeriodic(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Exit code for disabled mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits disabled mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase12DisabledExitEv"]
            pub fn IterativeRobotBase_DisabledExit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Exit code for autonomous mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits autonomous mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14AutonomousExitEv"]
            pub fn IterativeRobotBase_AutonomousExit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Exit code for teleop mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits teleop mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase10TeleopExitEv"]
            pub fn IterativeRobotBase_TeleopExit(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Exit code for test mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits test mode."]
            #[link_name = "\u{1}_ZN3frc18IterativeRobotBase8TestExitEv"]
            pub fn IterativeRobotBase_TestExit(this: *mut ::std::os::raw::c_void);
        }
        #[doc = " TimedRobot implements the IterativeRobotBase robot program framework.\n\n The TimedRobot class is intended to be subclassed by a user creating a\n robot program.\n\n Periodic() functions from the base class are called on an interval by a\n Notifier instance."]
        #[repr(C)]
        pub struct TimedRobot {
            pub _base: root::frc::IterativeRobotBase,
            pub m_notifier: u32,
            pub m_startTime: root::units::time::second_t,
            pub m_callbacks: root::wpi::priority_queue<root::std::vector, root::std::greater>,
        }
        #[repr(C)]
        pub struct TimedRobot_Callback {
            pub func: [u64; 4usize],
            pub period: root::units::time::second_t,
            pub expirationTime: root::units::time::second_t,
        }
        #[test]
        fn bindgen_test_layout_TimedRobot_Callback() {
            const UNINIT: ::std::mem::MaybeUninit<TimedRobot_Callback> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TimedRobot_Callback>(),
                48usize,
                concat!("Size of: ", stringify!(TimedRobot_Callback))
            );
            assert_eq!(
                ::std::mem::align_of::<TimedRobot_Callback>(),
                8usize,
                concat!("Alignment of ", stringify!(TimedRobot_Callback))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimedRobot_Callback),
                    "::",
                    stringify!(func)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimedRobot_Callback),
                    "::",
                    stringify!(period)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).expirationTime) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimedRobot_Callback),
                    "::",
                    stringify!(expirationTime)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc10TimedRobot14kDefaultPeriodE"]
            pub static TimedRobot_kDefaultPeriod: root::units::unit_t;
        }
        #[test]
        fn bindgen_test_layout_TimedRobot() {
            const UNINIT: ::std::mem::MaybeUninit<TimedRobot> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TimedRobot>(),
                192usize,
                concat!("Size of: ", stringify!(TimedRobot))
            );
            assert_eq!(
                ::std::mem::align_of::<TimedRobot>(),
                8usize,
                concat!("Alignment of ", stringify!(TimedRobot))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_notifier) as usize - ptr as usize },
                148usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimedRobot),
                    "::",
                    stringify!(m_notifier)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimedRobot),
                    "::",
                    stringify!(m_startTime)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_callbacks) as usize - ptr as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimedRobot),
                    "::",
                    stringify!(m_callbacks)
                )
            );
        }
        extern "C" {
            #[doc = " Add a callback to run at a specific period with a starting time offset.\n\n This is scheduled on TimedRobot's Notifier, so TimedRobot and the callback\n run synchronously. Interactions between them are thread-safe.\n\n @param callback The callback to run.\n @param period   The period at which to run the callback.\n @param offset   The offset from the common starting time. This is useful\n                 for scheduling a callback in a different timeslot relative\n                 to TimedRobot."]
            #[link_name = "\u{1}_ZN3frc10TimedRobot11AddPeriodicESt8functionIFvvEEN5units6unit_tINS4_4unitISt5ratioILl1ELl1EENS4_9base_unitIS7_ILl0ELl1EESA_S8_SA_SA_SA_SA_SA_SA_EESA_SA_EEdNS4_12linear_scaleEEESE_"]
            pub fn TimedRobot_AddPeriodic(
                this: *mut root::frc::TimedRobot,
                callback: [u64; 4usize],
                period: root::units::time::second_t,
                offset: root::units::time::second_t,
            );
        }
        extern "C" {
            #[doc = " Constructor for TimedRobot.\n\n @deprecated use unit safe constructor instead.\n TimedRobot(units::second_t period = kDefaultPeriod)\n\n @param period Period in seconds."]
            #[link_name = "\u{1}_ZN3frc10TimedRobotC1Ed"]
            pub fn TimedRobot_TimedRobot(this: *mut root::frc::TimedRobot, period: f64);
        }
        extern "C" {
            #[doc = " Constructor for TimedRobot.\n\n @param period Period."]
            #[link_name = "\u{1}_ZN3frc10TimedRobotC1EN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
            pub fn TimedRobot_TimedRobot1(
                this: *mut root::frc::TimedRobot,
                period: root::units::time::second_t,
            );
        }
        impl TimedRobot {
            #[inline]
            pub unsafe fn AddPeriodic(
                &mut self,
                callback: [u64; 4usize],
                period: root::units::time::second_t,
                offset: root::units::time::second_t,
            ) {
                TimedRobot_AddPeriodic(self, callback, period, offset)
            }
            #[inline]
            pub unsafe fn new(period: f64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TimedRobot_TimedRobot(__bindgen_tmp.as_mut_ptr(), period);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(period: root::units::time::second_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TimedRobot_TimedRobot1(__bindgen_tmp.as_mut_ptr(), period);
                __bindgen_tmp.assume_init()
            }
        }
        #[test]
        fn __bindgen_test_layout_unit_t_open0_unit_open1_ratio_open2_close2__bindgen_ty_id_119686_open2_ratio_open3_close3_base_unit_open3_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_ratio_open4_close4_close3_ratio_open3_close3_ratio_open3_close3_close2_ratio_open2_close2_ratio_open2_close2_close1_double_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::units::unit_t>(),
                8usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::units::unit_t)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::units::unit_t>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::units::unit_t)
                )
            );
        }
        extern "C" {
            #[doc = " Provide an alternate \"main loop\" via StartCompetition()."]
            #[link_name = "\u{1}_ZN3frc10TimedRobot16StartCompetitionEv"]
            pub fn TimedRobot_StartCompetition(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[doc = " Ends the main loop in StartCompetition()."]
            #[link_name = "\u{1}_ZN3frc10TimedRobot14EndCompetitionEv"]
            pub fn TimedRobot_EndCompetition(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3frc10TimedRobotD1Ev"]
            pub fn TimedRobot_TimedRobot_destructor(this: *mut root::frc::TimedRobot);
        }
        #[doc = " TimesliceRobot extends the TimedRobot robot program framework to provide\n timeslice scheduling of periodic functions.\n\n The TimesliceRobot class is intended to be subclassed by a user creating a\n robot program.\n\n This class schedules robot operations serially in a timeslice format.\n TimedRobot's periodic functions are the first in the timeslice table with 0\n ms offset and 20 ms period. You can schedule additional controller periodic\n functions at a shorter period (5 ms by default). You give each one a\n timeslice duration, then they're run sequentially. The main benefit of this\n approach is consistent starting times for each controller periodic, which can\n make odometry and estimators more accurate and controller outputs change more\n consistently.\n\n Here's an example of measured subsystem durations and their timeslice\n allocations:\n\n <table>\n   <tr>\n     <td><b>Subsystem</b></td>\n     <td><b>Duration (ms)</b></td>\n     <td><b>Allocation (ms)</b></td>\n   </tr>\n   <tr>\n     <td><b>Total</b></td>\n     <td>5.0</td>\n     <td>5.0</td>\n   </tr>\n   <tr>\n     <td>TimedRobot</td>\n     <td>?</td>\n     <td>2.0</td>\n   </tr>\n   <tr>\n     <td>Drivetrain</td>\n     <td>1.32</td>\n     <td>1.5</td>\n   </tr>\n   <tr>\n     <td>Flywheel</td>\n     <td>0.6</td>\n     <td>0.7</td>\n   </tr>\n   <tr>\n     <td>Turret</td>\n     <td>0.6</td>\n     <td>0.8</td>\n   </tr>\n   <tr>\n     <td><b>Free</b></td>\n     <td>0.0</td>\n     <td>N/A</td>\n   </tr>\n </table>\n\n Since TimedRobot periodic functions only run every 20ms, that leaves a 2 ms\n empty spot in the allocation table for three of the four 5 ms cycles\n comprising 20 ms. That's OK because the OS needs time to do other things.\n\n If the robot periodic functions and the controller periodic functions have a\n lot of scheduling jitter that cause them to occasionally overlap with later\n timeslices, consider giving the main robot thread a real-time priority using\n frc::SetCurrentThreadPriority(). An RT priority of 15 is a reasonable choice.\n\n If you do enable RT though, <i>make sure your periodic functions do not\n block</i>. If they do, the operating system will lock up, and you'll have to\n boot the roboRIO into safe mode and delete the robot program to recover."]
        #[repr(C)]
        pub struct TimesliceRobot {
            pub _base: root::frc::TimedRobot,
            pub m_nextOffset: root::units::time::second_t,
            pub m_controllerPeriod: root::units::time::second_t,
        }
        #[test]
        fn bindgen_test_layout_TimesliceRobot() {
            const UNINIT: ::std::mem::MaybeUninit<TimesliceRobot> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<TimesliceRobot>(),
                208usize,
                concat!("Size of: ", stringify!(TimesliceRobot))
            );
            assert_eq!(
                ::std::mem::align_of::<TimesliceRobot>(),
                8usize,
                concat!("Alignment of ", stringify!(TimesliceRobot))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_nextOffset) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimesliceRobot),
                    "::",
                    stringify!(m_nextOffset)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_controllerPeriod) as usize - ptr as usize },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimesliceRobot),
                    "::",
                    stringify!(m_controllerPeriod)
                )
            );
        }
        extern "C" {
            #[doc = " Schedule a periodic function with the constructor's controller period and\n the given allocation. The function's runtime allocation will be placed\n after the end of the previous one's.\n\n If a call to this function makes the allocations exceed the controller\n period, an exception will be thrown since that means the TimesliceRobot\n periodic functions and the given function will have conflicting\n timeslices.\n\n @param func       Function to schedule.\n @param allocation The function's runtime allocation out of the controller\n                   period."]
            #[link_name = "\u{1}_ZN3frc14TimesliceRobot8ScheduleESt8functionIFvvEEN5units6unit_tINS4_4unitISt5ratioILl1ELl1EENS4_9base_unitIS7_ILl0ELl1EESA_S8_SA_SA_SA_SA_SA_SA_EESA_SA_EEdNS4_12linear_scaleEEE"]
            pub fn TimesliceRobot_Schedule(
                this: *mut root::frc::TimesliceRobot,
                func: [u64; 4usize],
                allocation: root::units::time::second_t,
            );
        }
        extern "C" {
            #[doc = " Constructor for TimesliceRobot.\n\n @param robotPeriodicAllocation The allocation to give the TimesliceRobot\n                                periodic functions.\n @param controllerPeriod The controller period. The sum of all scheduler\n                         allocations should be less than or equal to this\n                         value."]
            #[link_name = "\u{1}_ZN3frc14TimesliceRobotC1EN5units6unit_tINS1_4unitISt5ratioILl1ELl1EENS1_9base_unitIS4_ILl0ELl1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEESB_"]
            pub fn TimesliceRobot_TimesliceRobot(
                this: *mut root::frc::TimesliceRobot,
                robotPeriodicAllocation: root::units::time::second_t,
                controllerPeriod: root::units::time::second_t,
            );
        }
        impl TimesliceRobot {
            #[inline]
            pub unsafe fn Schedule(
                &mut self,
                func: [u64; 4usize],
                allocation: root::units::time::second_t,
            ) {
                TimesliceRobot_Schedule(self, func, allocation)
            }
            #[inline]
            pub unsafe fn new(
                robotPeriodicAllocation: root::units::time::second_t,
                controllerPeriod: root::units::time::second_t,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TimesliceRobot_TimesliceRobot(
                    __bindgen_tmp.as_mut_ptr(),
                    robotPeriodicAllocation,
                    controllerPeriod,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[doc = " Handle input from Xbox 360 or Xbox One controllers connected to the Driver\n Station.\n\n This class handles Xbox input that comes from the Driver Station. Each time a\n value is requested the most recent value is returned. There is a single class\n instance for each controller and the mapping of ports to hardware buttons\n depends on the code in the Driver Station."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct XboxController {
            pub _base: root::frc::GenericHID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct XboxController_Button {
            pub _address: u8,
        }
        pub const XboxController_Button_kLeftBumper: ::std::os::raw::c_int = 5;
        pub const XboxController_Button_kRightBumper: ::std::os::raw::c_int = 6;
        pub const XboxController_Button_kLeftStick: ::std::os::raw::c_int = 9;
        pub const XboxController_Button_kRightStick: ::std::os::raw::c_int = 10;
        pub const XboxController_Button_kA: ::std::os::raw::c_int = 1;
        pub const XboxController_Button_kB: ::std::os::raw::c_int = 2;
        pub const XboxController_Button_kX: ::std::os::raw::c_int = 3;
        pub const XboxController_Button_kY: ::std::os::raw::c_int = 4;
        pub const XboxController_Button_kBack: ::std::os::raw::c_int = 7;
        pub const XboxController_Button_kStart: ::std::os::raw::c_int = 8;
        #[test]
        fn bindgen_test_layout_XboxController_Button() {
            assert_eq!(
                ::std::mem::size_of::<XboxController_Button>(),
                1usize,
                concat!("Size of: ", stringify!(XboxController_Button))
            );
            assert_eq!(
                ::std::mem::align_of::<XboxController_Button>(),
                1usize,
                concat!("Alignment of ", stringify!(XboxController_Button))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct XboxController_Axis {
            pub _address: u8,
        }
        pub const XboxController_Axis_kLeftX: ::std::os::raw::c_int = 0;
        pub const XboxController_Axis_kRightX: ::std::os::raw::c_int = 4;
        pub const XboxController_Axis_kLeftY: ::std::os::raw::c_int = 1;
        pub const XboxController_Axis_kRightY: ::std::os::raw::c_int = 5;
        pub const XboxController_Axis_kLeftTrigger: ::std::os::raw::c_int = 2;
        pub const XboxController_Axis_kRightTrigger: ::std::os::raw::c_int = 3;
        #[test]
        fn bindgen_test_layout_XboxController_Axis() {
            assert_eq!(
                ::std::mem::size_of::<XboxController_Axis>(),
                1usize,
                concat!("Size of: ", stringify!(XboxController_Axis))
            );
            assert_eq!(
                ::std::mem::align_of::<XboxController_Axis>(),
                1usize,
                concat!("Alignment of ", stringify!(XboxController_Axis))
            );
        }
        #[test]
        fn bindgen_test_layout_XboxController() {
            assert_eq!(
                ::std::mem::size_of::<XboxController>(),
                24usize,
                concat!("Size of: ", stringify!(XboxController))
            );
            assert_eq!(
                ::std::mem::align_of::<XboxController>(),
                8usize,
                concat!("Alignment of ", stringify!(XboxController))
            );
        }
        extern "C" {
            #[doc = " Get the X axis value of left side of the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController8GetLeftXEv"]
            pub fn XboxController_GetLeftX(this: *const root::frc::XboxController) -> f64;
        }
        extern "C" {
            #[doc = " Get the X axis value of right side of the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController9GetRightXEv"]
            pub fn XboxController_GetRightX(this: *const root::frc::XboxController) -> f64;
        }
        extern "C" {
            #[doc = " Get the Y axis value of left side of the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController8GetLeftYEv"]
            pub fn XboxController_GetLeftY(this: *const root::frc::XboxController) -> f64;
        }
        extern "C" {
            #[doc = " Get the Y axis value of right side of the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController9GetRightYEv"]
            pub fn XboxController_GetRightY(this: *const root::frc::XboxController) -> f64;
        }
        extern "C" {
            #[doc = " Get the left trigger (LT) axis value of the controller. Note that this axis\n is bound to the range of [0, 1] as opposed to the usual [-1, 1]."]
            #[link_name = "\u{1}_ZNK3frc14XboxController18GetLeftTriggerAxisEv"]
            pub fn XboxController_GetLeftTriggerAxis(this: *const root::frc::XboxController)
                -> f64;
        }
        extern "C" {
            #[doc = " Get the right trigger (RT) axis value of the controller. Note that this\n axis is bound to the range of [0, 1] as opposed to the usual [-1, 1]."]
            #[link_name = "\u{1}_ZNK3frc14XboxController19GetRightTriggerAxisEv"]
            pub fn XboxController_GetRightTriggerAxis(
                this: *const root::frc::XboxController,
            ) -> f64;
        }
        extern "C" {
            #[doc = " Read the value of the left bumper (LB) button on the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController13GetLeftBumperEv"]
            pub fn XboxController_GetLeftBumper(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the right bumper (RB) button on the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController14GetRightBumperEv"]
            pub fn XboxController_GetRightBumper(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the left bumper (LB) was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController20GetLeftBumperPressedEv"]
            pub fn XboxController_GetLeftBumperPressed(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the right bumper (RB) was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController21GetRightBumperPressedEv"]
            pub fn XboxController_GetRightBumperPressed(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the left bumper (LB) was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController21GetLeftBumperReleasedEv"]
            pub fn XboxController_GetLeftBumperReleased(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the right bumper (RB) was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController22GetRightBumperReleasedEv"]
            pub fn XboxController_GetRightBumperReleased(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the left stick button (LSB) on the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController18GetLeftStickButtonEv"]
            pub fn XboxController_GetLeftStickButton(
                this: *const root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the right stick button (RSB) on the controller."]
            #[link_name = "\u{1}_ZNK3frc14XboxController19GetRightStickButtonEv"]
            pub fn XboxController_GetRightStickButton(
                this: *const root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the left stick button (LSB) was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController25GetLeftStickButtonPressedEv"]
            pub fn XboxController_GetLeftStickButtonPressed(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the right stick button (RSB) was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController26GetRightStickButtonPressedEv"]
            pub fn XboxController_GetRightStickButtonPressed(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the left stick button (LSB) was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController26GetLeftStickButtonReleasedEv"]
            pub fn XboxController_GetLeftStickButtonReleased(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the right stick button (RSB) was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController27GetRightStickButtonReleasedEv"]
            pub fn XboxController_GetRightStickButtonReleased(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the A button on the controller.\n\n @return The state of the button."]
            #[link_name = "\u{1}_ZNK3frc14XboxController10GetAButtonEv"]
            pub fn XboxController_GetAButton(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the A button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController17GetAButtonPressedEv"]
            pub fn XboxController_GetAButtonPressed(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the A button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController18GetAButtonReleasedEv"]
            pub fn XboxController_GetAButtonReleased(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the B button on the controller.\n\n @return The state of the button."]
            #[link_name = "\u{1}_ZNK3frc14XboxController10GetBButtonEv"]
            pub fn XboxController_GetBButton(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the B button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController17GetBButtonPressedEv"]
            pub fn XboxController_GetBButtonPressed(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the B button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController18GetBButtonReleasedEv"]
            pub fn XboxController_GetBButtonReleased(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the X button on the controller.\n\n @return The state of the button."]
            #[link_name = "\u{1}_ZNK3frc14XboxController10GetXButtonEv"]
            pub fn XboxController_GetXButton(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the X button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController17GetXButtonPressedEv"]
            pub fn XboxController_GetXButtonPressed(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the X button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController18GetXButtonReleasedEv"]
            pub fn XboxController_GetXButtonReleased(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the Y button on the controller.\n\n @return The state of the button."]
            #[link_name = "\u{1}_ZNK3frc14XboxController10GetYButtonEv"]
            pub fn XboxController_GetYButton(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the Y button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController17GetYButtonPressedEv"]
            pub fn XboxController_GetYButtonPressed(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the Y button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController18GetYButtonReleasedEv"]
            pub fn XboxController_GetYButtonReleased(this: *mut root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the Y button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZNK3frc14XboxController13GetBackButtonEv"]
            pub fn XboxController_GetBackButton(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the back button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController20GetBackButtonPressedEv"]
            pub fn XboxController_GetBackButtonPressed(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the back button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController21GetBackButtonReleasedEv"]
            pub fn XboxController_GetBackButtonReleased(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Read the value of the start button on the controller.\n\n @return The state of the button."]
            #[link_name = "\u{1}_ZNK3frc14XboxController14GetStartButtonEv"]
            pub fn XboxController_GetStartButton(this: *const root::frc::XboxController) -> bool;
        }
        extern "C" {
            #[doc = " Whether the start button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController21GetStartButtonPressedEv"]
            pub fn XboxController_GetStartButtonPressed(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether the start button was released since the last check.\n\n @return Whether the button was released since the last check."]
            #[link_name = "\u{1}_ZN3frc14XboxController22GetStartButtonReleasedEv"]
            pub fn XboxController_GetStartButtonReleased(
                this: *mut root::frc::XboxController,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Construct an instance of an Xbox controller.\n\n The controller index is the USB port on the Driver Station.\n\n @param port The port on the Driver Station that the controller is plugged\n             into (0-5)."]
            #[link_name = "\u{1}_ZN3frc14XboxControllerC1Ei"]
            pub fn XboxController_XboxController(
                this: *mut root::frc::XboxController,
                port: ::std::os::raw::c_int,
            );
        }
        impl XboxController {
            #[inline]
            pub unsafe fn GetLeftX(&self) -> f64 {
                XboxController_GetLeftX(self)
            }
            #[inline]
            pub unsafe fn GetRightX(&self) -> f64 {
                XboxController_GetRightX(self)
            }
            #[inline]
            pub unsafe fn GetLeftY(&self) -> f64 {
                XboxController_GetLeftY(self)
            }
            #[inline]
            pub unsafe fn GetRightY(&self) -> f64 {
                XboxController_GetRightY(self)
            }
            #[inline]
            pub unsafe fn GetLeftTriggerAxis(&self) -> f64 {
                XboxController_GetLeftTriggerAxis(self)
            }
            #[inline]
            pub unsafe fn GetRightTriggerAxis(&self) -> f64 {
                XboxController_GetRightTriggerAxis(self)
            }
            #[inline]
            pub unsafe fn GetLeftBumper(&self) -> bool {
                XboxController_GetLeftBumper(self)
            }
            #[inline]
            pub unsafe fn GetRightBumper(&self) -> bool {
                XboxController_GetRightBumper(self)
            }
            #[inline]
            pub unsafe fn GetLeftBumperPressed(&mut self) -> bool {
                XboxController_GetLeftBumperPressed(self)
            }
            #[inline]
            pub unsafe fn GetRightBumperPressed(&mut self) -> bool {
                XboxController_GetRightBumperPressed(self)
            }
            #[inline]
            pub unsafe fn GetLeftBumperReleased(&mut self) -> bool {
                XboxController_GetLeftBumperReleased(self)
            }
            #[inline]
            pub unsafe fn GetRightBumperReleased(&mut self) -> bool {
                XboxController_GetRightBumperReleased(self)
            }
            #[inline]
            pub unsafe fn GetLeftStickButton(&self) -> bool {
                XboxController_GetLeftStickButton(self)
            }
            #[inline]
            pub unsafe fn GetRightStickButton(&self) -> bool {
                XboxController_GetRightStickButton(self)
            }
            #[inline]
            pub unsafe fn GetLeftStickButtonPressed(&mut self) -> bool {
                XboxController_GetLeftStickButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetRightStickButtonPressed(&mut self) -> bool {
                XboxController_GetRightStickButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetLeftStickButtonReleased(&mut self) -> bool {
                XboxController_GetLeftStickButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetRightStickButtonReleased(&mut self) -> bool {
                XboxController_GetRightStickButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetAButton(&self) -> bool {
                XboxController_GetAButton(self)
            }
            #[inline]
            pub unsafe fn GetAButtonPressed(&mut self) -> bool {
                XboxController_GetAButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetAButtonReleased(&mut self) -> bool {
                XboxController_GetAButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetBButton(&self) -> bool {
                XboxController_GetBButton(self)
            }
            #[inline]
            pub unsafe fn GetBButtonPressed(&mut self) -> bool {
                XboxController_GetBButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetBButtonReleased(&mut self) -> bool {
                XboxController_GetBButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetXButton(&self) -> bool {
                XboxController_GetXButton(self)
            }
            #[inline]
            pub unsafe fn GetXButtonPressed(&mut self) -> bool {
                XboxController_GetXButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetXButtonReleased(&mut self) -> bool {
                XboxController_GetXButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetYButton(&self) -> bool {
                XboxController_GetYButton(self)
            }
            #[inline]
            pub unsafe fn GetYButtonPressed(&mut self) -> bool {
                XboxController_GetYButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetYButtonReleased(&mut self) -> bool {
                XboxController_GetYButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetBackButton(&self) -> bool {
                XboxController_GetBackButton(self)
            }
            #[inline]
            pub unsafe fn GetBackButtonPressed(&mut self) -> bool {
                XboxController_GetBackButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetBackButtonReleased(&mut self) -> bool {
                XboxController_GetBackButtonReleased(self)
            }
            #[inline]
            pub unsafe fn GetStartButton(&self) -> bool {
                XboxController_GetStartButton(self)
            }
            #[inline]
            pub unsafe fn GetStartButtonPressed(&mut self) -> bool {
                XboxController_GetStartButtonPressed(self)
            }
            #[inline]
            pub unsafe fn GetStartButtonReleased(&mut self) -> bool {
                XboxController_GetStartButtonReleased(self)
            }
            #[inline]
            pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                XboxController_XboxController(__bindgen_tmp.as_mut_ptr(), port);
                __bindgen_tmp.assume_init()
            }
        }
    }
    pub const HAL_SPIPort_HAL_SPI_kInvalid: root::HAL_SPIPort = -1;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS0: root::HAL_SPIPort = 0;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS1: root::HAL_SPIPort = 1;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS2: root::HAL_SPIPort = 2;
    pub const HAL_SPIPort_HAL_SPI_kOnboardCS3: root::HAL_SPIPort = 3;
    pub const HAL_SPIPort_HAL_SPI_kMXP: root::HAL_SPIPort = 4;
    #[doc = " @defgroup hal_spi SPI Functions\n @ingroup hal_capi\n @{"]
    pub type HAL_SPIPort = i32;
    pub mod fmt {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod units {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @brief\t\thelper type to identify base units.\n @details\t\tA non-templated base class for `base_unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _base_unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__base_unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_base_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_base_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_base_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_base_unit_t))
                );
            }
            #[doc = " @brief\t\thelper type to identify units.\n @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _unit {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__unit() {
                assert_eq!(
                    ::std::mem::size_of::<_unit>(),
                    1usize,
                    concat!("Size of: ", stringify!(_unit))
                );
                assert_eq!(
                    ::std::mem::align_of::<_unit>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_unit))
                );
            }
            #[doc = " @brief\t\thelper type to identify units.\n @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _unit_t {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__unit_t() {
                assert_eq!(
                    ::std::mem::size_of::<_unit_t>(),
                    1usize,
                    concat!("Size of: ", stringify!(_unit_t))
                );
                assert_eq!(
                    ::std::mem::align_of::<_unit_t>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_unit_t))
                );
            }
        }
        pub mod constants {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod traits {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @brief\t\tunit traits implementation for classes which are not units."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct unit_traits {
                pub _address: u8,
            }
            pub type unit_traits_base_unit_type = ::std::os::raw::c_void;
            pub type unit_traits_conversion_ratio = ::std::os::raw::c_void;
            pub type unit_traits_pi_exponent_ratio = ::std::os::raw::c_void;
            pub type unit_traits_translation_ratio = ::std::os::raw::c_void;
        }
        #[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct base_unit {
            pub _address: u8,
        }
        pub type base_unit_meter_ratio<Meter> = Meter;
        pub type base_unit_kilogram_ratio<Kilogram> = Kilogram;
        pub type base_unit_second_ratio<Second> = Second;
        pub type base_unit_radian_ratio<Radian> = Radian;
        pub type base_unit_ampere_ratio<Ampere> = Ampere;
        pub type base_unit_kelvin_ratio<Kelvin> = Kelvin;
        pub type base_unit_mole_ratio<Mole> = Mole;
        pub type base_unit_candela_ratio<Candela> = Candela;
        pub type base_unit_byte_ratio<Byte> = Byte;
        pub mod category {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
            pub type time_unit = root::units::base_unit;
        }
        #[doc = " @brief\t\tunit type template specialization for units derived from base units."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unit {
            pub _address: u8,
        }
        pub type unit_base_unit_type = root::units::traits::unit_traits;
        pub type unit_conversion_ratio = root::std::ratio_multiply;
        pub type unit_pi_exponent_ratio = root::std::ratio_add;
        pub type unit_translation_ratio = root::std::ratio_add;
        #[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
        #[repr(C)]
        pub struct unit_t {
            pub _base: root::units::linear_scale<[u8; 0usize]>,
        }
        pub type unit_t_nls = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_non_linear_scale_type = root::units::linear_scale<[u8; 0usize]>;
        pub type unit_t_underlying_type<T> = T;
        pub type unit_t_value_type<T> = T;
        pub type unit_t_unit_type<Units> = Units;
        #[doc = " @cond"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct linear_scale<T> {
            #[doc = "< linearized value."]
            pub m_value: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub mod time {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type seconds = u8;
            pub type second = root::units::time::seconds;
            #[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
            pub type second_t = root::units::unit_t;
        }
    }
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kBroadcast: root::HAL_CANDeviceType = 0;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kRobotController: root::HAL_CANDeviceType = 1;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kMotorController: root::HAL_CANDeviceType = 2;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kRelayController: root::HAL_CANDeviceType = 3;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kGyroSensor: root::HAL_CANDeviceType = 4;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kAccelerometer: root::HAL_CANDeviceType = 5;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kUltrasonicSensor: root::HAL_CANDeviceType = 6;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kGearToothSensor: root::HAL_CANDeviceType = 7;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kPowerDistribution: root::HAL_CANDeviceType = 8;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kPneumatics: root::HAL_CANDeviceType = 9;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kMiscellaneous: root::HAL_CANDeviceType = 10;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kIOBreakout: root::HAL_CANDeviceType = 11;
    pub const HAL_CANDeviceType_HAL_CAN_Dev_kFirmwareUpdate: root::HAL_CANDeviceType = 31;
    #[doc = " The CAN device type.\n\n Teams should use HAL_CAN_Dev_kMiscellaneous"]
    pub type HAL_CANDeviceType = i32;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kBroadcast: root::HAL_CANManufacturer = 0;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kNI: root::HAL_CANManufacturer = 1;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kLM: root::HAL_CANManufacturer = 2;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kDEKA: root::HAL_CANManufacturer = 3;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kCTRE: root::HAL_CANManufacturer = 4;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kREV: root::HAL_CANManufacturer = 5;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kGrapple: root::HAL_CANManufacturer = 6;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kMS: root::HAL_CANManufacturer = 7;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kTeamUse: root::HAL_CANManufacturer = 8;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kKauaiLabs: root::HAL_CANManufacturer = 9;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kCopperforge: root::HAL_CANManufacturer = 10;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kPWF: root::HAL_CANManufacturer = 11;
    pub const HAL_CANManufacturer_HAL_CAN_Man_kStudica: root::HAL_CANManufacturer = 12;
    #[doc = " The CAN manufacturer ID.\n\n Teams should use HAL_CAN_Man_kTeamUse."]
    pub type HAL_CANManufacturer = i32;
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_ControlWord {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[test]
    fn bindgen_test_layout_HAL_ControlWord() {
        assert_eq!(
            ::std::mem::size_of::<HAL_ControlWord>(),
            4usize,
            concat!("Size of: ", stringify!(HAL_ControlWord))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_ControlWord>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_ControlWord))
        );
    }
    impl HAL_ControlWord {
        #[inline]
        pub fn enabled(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_enabled(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn autonomous(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_autonomous(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn test(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_test(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn eStop(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_eStop(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn fmsAttached(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_fmsAttached(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dsAttached(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_dsAttached(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn control_reserved(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
        }
        #[inline]
        pub fn set_control_reserved(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(6usize, 26u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            enabled: u32,
            autonomous: u32,
            test: u32,
            eStop: u32,
            fmsAttached: u32,
            dsAttached: u32,
            control_reserved: u32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
                enabled as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
                autonomous as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let test: u32 = unsafe { ::std::mem::transmute(test) };
                test as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
                eStop as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
                fmsAttached as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
                dsAttached as u64
            });
            __bindgen_bitfield_unit.set(6usize, 26u8, {
                let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
                control_reserved as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed1: root::HAL_AllianceStationID = 0;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed2: root::HAL_AllianceStationID = 1;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed3: root::HAL_AllianceStationID = 2;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue1: root::HAL_AllianceStationID = 3;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue2: root::HAL_AllianceStationID = 4;
    pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue3: root::HAL_AllianceStationID = 5;
    pub type HAL_AllianceStationID = i32;
    pub const HAL_MatchType_HAL_kMatchType_none: root::HAL_MatchType = 0;
    pub const HAL_MatchType_HAL_kMatchType_practice: root::HAL_MatchType = 1;
    pub const HAL_MatchType_HAL_kMatchType_qualification: root::HAL_MatchType = 2;
    pub const HAL_MatchType_HAL_kMatchType_elimination: root::HAL_MatchType = 3;
    pub type HAL_MatchType = i32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickAxes {
        pub count: i16,
        pub axes: [f32; 12usize],
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickAxes() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickAxes> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickAxes>(),
            52usize,
            concat!("Size of: ", stringify!(HAL_JoystickAxes))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickAxes>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_JoystickAxes))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickAxes),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickAxes),
                "::",
                stringify!(axes)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickPOVs {
        pub count: i16,
        pub povs: [i16; 12usize],
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickPOVs() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickPOVs> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickPOVs>(),
            26usize,
            concat!("Size of: ", stringify!(HAL_JoystickPOVs))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickPOVs>(),
            2usize,
            concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickPOVs),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickPOVs),
                "::",
                stringify!(povs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickButtons {
        pub buttons: u32,
        pub count: u8,
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickButtons() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickButtons> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickButtons>(),
            8usize,
            concat!("Size of: ", stringify!(HAL_JoystickButtons))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickButtons>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_JoystickButtons))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickButtons),
                "::",
                stringify!(buttons)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickButtons),
                "::",
                stringify!(count)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_JoystickDescriptor {
        pub isXbox: u8,
        pub type_: u8,
        pub name: [::std::os::raw::c_char; 256usize],
        pub axisCount: u8,
        pub axisTypes: [u8; 12usize],
        pub buttonCount: u8,
        pub povCount: u8,
    }
    #[test]
    fn bindgen_test_layout_HAL_JoystickDescriptor() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickDescriptor> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_JoystickDescriptor>(),
            273usize,
            concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_JoystickDescriptor>(),
            1usize,
            concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).isXbox) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(isXbox)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).axisCount) as usize - ptr as usize },
            258usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(axisCount)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).axisTypes) as usize - ptr as usize },
            259usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(axisTypes)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).buttonCount) as usize - ptr as usize },
            271usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(buttonCount)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).povCount) as usize - ptr as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_JoystickDescriptor),
                "::",
                stringify!(povCount)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HAL_MatchInfo {
        pub eventName: [::std::os::raw::c_char; 64usize],
        pub matchType: root::HAL_MatchType,
        pub matchNumber: u16,
        pub replayNumber: u8,
        pub gameSpecificMessage: [u8; 64usize],
        pub gameSpecificMessageSize: u16,
    }
    #[test]
    fn bindgen_test_layout_HAL_MatchInfo() {
        const UNINIT: ::std::mem::MaybeUninit<HAL_MatchInfo> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HAL_MatchInfo>(),
            140usize,
            concat!("Size of: ", stringify!(HAL_MatchInfo))
        );
        assert_eq!(
            ::std::mem::align_of::<HAL_MatchInfo>(),
            4usize,
            concat!("Alignment of ", stringify!(HAL_MatchInfo))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).eventName) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_MatchInfo),
                "::",
                stringify!(eventName)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).matchType) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_MatchInfo),
                "::",
                stringify!(matchType)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).matchNumber) as usize - ptr as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_MatchInfo),
                "::",
                stringify!(matchNumber)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).replayNumber) as usize - ptr as usize },
            70usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_MatchInfo),
                "::",
                stringify!(replayNumber)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessage) as usize - ptr as usize },
            71usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_MatchInfo),
                "::",
                stringify!(gameSpecificMessage)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessageSize) as usize - ptr as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(HAL_MatchInfo),
                "::",
                stringify!(gameSpecificMessageSize)
            )
        );
    }
    extern "C" {
        #[doc = " Sends an error to the driver station.\n\n @param isError   true for error, false for warning\n @param errorCode the error code\n @param isLVCode  true for a LV error code, false for a standard error code\n @param details   the details of the error\n @param location  the file location of the errror\n @param callStack the callstack of the error\n @param printMsg  true to print the error message to stdout as well as to the\n DS"]
        pub fn HAL_SendError(
            isError: root::HAL_Bool,
            errorCode: i32,
            isLVCode: root::HAL_Bool,
            details: *const ::std::os::raw::c_char,
            location: *const ::std::os::raw::c_char,
            callStack: *const ::std::os::raw::c_char,
            printMsg: root::HAL_Bool,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Sends a line to the driver station console.\n\n @param line the line to send (null terminated)"]
        pub fn HAL_SendConsoleLine(line: *const ::std::os::raw::c_char) -> i32;
    }
    extern "C" {
        #[doc = " Gets the current control word of the driver station.\n\n The control work contains the robot state.\n\n @param controlWord the control word (out)\n @return the error code, or 0 for success"]
        pub fn HAL_GetControlWord(controlWord: *mut root::HAL_ControlWord) -> i32;
    }
    extern "C" {
        #[doc = " Gets the current alliance station ID.\n\n @param[out] status the error code, or 0 for success\n @return the alliance station ID"]
        pub fn HAL_GetAllianceStation(status: *mut i32) -> root::HAL_AllianceStationID;
    }
    extern "C" {
        #[doc = " Gets the axes of a specific joystick.\n\n @param joystickNum the joystick number\n @param axes        the axes values (output)\n @return the error code, or 0 for success"]
        pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut root::HAL_JoystickAxes) -> i32;
    }
    extern "C" {
        #[doc = " Gets the POVs of a specific joystick.\n\n @param joystickNum the joystick number\n @param povs        the POV values (output)\n @return the error code, or 0 for success"]
        pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut root::HAL_JoystickPOVs) -> i32;
    }
    extern "C" {
        #[doc = " Gets the buttons of a specific joystick.\n\n @param joystickNum the joystick number\n @param buttons     the button values (output)\n @return the error code, or 0 for success"]
        pub fn HAL_GetJoystickButtons(
            joystickNum: i32,
            buttons: *mut root::HAL_JoystickButtons,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Retrieves the Joystick Descriptor for particular slot.\n\n @param joystickNum the joystick number\n @param[out] desc   descriptor (data transfer object) to fill in. desc is\n                    filled in regardless of success. In other words, if\n                    descriptor is not available, desc is filled in with\n                    default values matching the init-values in Java and C++\n                    Driver Station for when caller requests a too-large\n                    joystick index.\n @return error code reported from Network Comm back-end.  Zero is good,\n         nonzero is bad."]
        pub fn HAL_GetJoystickDescriptor(
            joystickNum: i32,
            desc: *mut root::HAL_JoystickDescriptor,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Gets is a specific joystick is considered to be an XBox controller.\n\n @param joystickNum the joystick number\n @return true if xbox, false otherwise"]
        pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets the type of joystick connected.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @return the enumerated joystick type"]
        pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
    }
    extern "C" {
        #[doc = " Gets the name of a joystick.\n\n The returned array must be freed with HAL_FreeJoystickName.\n\n Will be null terminated.\n\n @param joystickNum the joystick number\n @return the joystick name"]
        pub fn HAL_GetJoystickName(joystickNum: i32) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Frees a joystick name received with HAL_GetJoystickName\n\n @param name the name storage"]
        pub fn HAL_FreeJoystickName(name: *mut ::std::os::raw::c_char);
    }
    extern "C" {
        #[doc = " Gets the type of a specific joystick axis.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @param axis        the axis number\n @return the enumerated axis type"]
        pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
    }
    extern "C" {
        #[doc = " Set joystick outputs.\n\n @param joystickNum the joystick number\n @param outputs     bitmask of outputs, 1 for on 0 for off\n @param leftRumble  the left rumble value (0-FFFF)\n @param rightRumble the right rumble value (0-FFFF)\n @return the error code, or 0 for success"]
        pub fn HAL_SetJoystickOutputs(
            joystickNum: i32,
            outputs: i64,
            leftRumble: i32,
            rightRumble: i32,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Returns the approximate match time.\n\n The FMS does not send an official match time to the robots, but does send\n an approximate match time. The value will count down the time remaining in\n the current period (auto or teleop).\n\n Warning: This is not an official time (so it cannot be used to dispute ref\n calls or guarantee that a function will trigger before the match ends).\n\n The Practice Match function of the DS approximates the behavior seen on\n the field.\n\n @param[out] status the error code, or 0 for success\n @return time remaining in current match period (auto or teleop)"]
        pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
    }
    extern "C" {
        #[doc = " Gets info about a specific match.\n\n @param[in] info the match info (output)\n @return the error code, or 0 for success"]
        pub fn HAL_GetMatchInfo(info: *mut root::HAL_MatchInfo) -> i32;
    }
    extern "C" {
        #[doc = " Releases the DS Mutex to allow proper shutdown of any threads that are\n waiting on it."]
        pub fn HAL_ReleaseDSMutex();
    }
    extern "C" {
        #[doc = " Has a new control packet from the driver station arrived since the last\n time this function was called?\n\n @return true if the control data has been updated since the last call"]
        pub fn HAL_IsNewControlData() -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Waits for the newest DS packet to arrive. Note that this is a blocking call.\n Checks if new control data has arrived since the last HAL_WaitForDSData or\n HAL_IsNewControlData call. If new data has not arrived, waits for new data\n to arrive. Otherwise, returns immediately."]
        pub fn HAL_WaitForDSData();
    }
    extern "C" {
        #[doc = " Waits for the newest DS packet to arrive. If timeout is <= 0, this will wait\n forever. Otherwise, it will wait until either a new packet, or the timeout\n time has passed.\n\n @param[in] timeout timeout in seconds\n @return true for new data, false for timeout"]
        pub fn HAL_WaitForDSDataTimeout(timeout: f64) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Initializes the driver station communication. This will properly\n handle multiple calls. However note that this CANNOT be called from a library\n that interfaces with LabVIEW."]
        pub fn HAL_InitializeDriverStation();
    }
    extern "C" {
        #[doc = " Sets the program starting flag in the DS.\n\n This is what changes the DS to showing robot code ready."]
        pub fn HAL_ObserveUserProgramStarting();
    }
    extern "C" {
        #[doc = " Sets the disabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
        pub fn HAL_ObserveUserProgramDisabled();
    }
    extern "C" {
        #[doc = " Sets the autonomous enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
        pub fn HAL_ObserveUserProgramAutonomous();
    }
    extern "C" {
        #[doc = " Sets the teleoperated enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
        pub fn HAL_ObserveUserProgramTeleop();
    }
    extern "C" {
        #[doc = " Sets the test mode flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
        pub fn HAL_ObserveUserProgramTest();
    }
    pub const HAL_RuntimeType_HAL_Runtime_RoboRIO: root::HAL_RuntimeType = 0;
    pub const HAL_RuntimeType_HAL_Runtime_RoboRIO2: root::HAL_RuntimeType = 1;
    pub const HAL_RuntimeType_HAL_Runtime_Simulation: root::HAL_RuntimeType = 2;
    #[doc = " @defgroup hal_capi WPILib HAL API\n Hardware Abstraction Layer to hardware or simulator\n @{"]
    pub type HAL_RuntimeType = i32;
    extern "C" {
        #[doc = " Gets the last error set on this thread, or the message for the status code.\n\n If passed HAL_USE_LAST_ERROR, the last error set on the thread will be\n returned.\n\n @param[out] status the status code, set to the error status code if input is\n               HAL_USE_LAST_ERROR\n @return the error message for the code. This does not need to be freed,\n               but can be overwritten by another hal call on the same thread."]
        pub fn HAL_GetLastError(status: *mut i32) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the error message for a specific status code.\n\n @param code the status code\n @return the error message for the code. This does not need to be freed."]
        pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Returns the FPGA Version number.\n\n For now, expect this to be competition year.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Version number."]
        pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
    }
    extern "C" {
        #[doc = " Returns the FPGA Revision number.\n\n The format of the revision is 3 numbers.\n The 12 most significant bits are the Major Revision.\n the next 8 bits are the Minor Revision.\n The 12 least significant bits are the Build Number.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Revision number."]
        pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
    }
    extern "C" {
        #[doc = " Returns the runtime type of the HAL.\n\n @return HAL Runtime Type"]
        pub fn HAL_GetRuntimeType() -> root::HAL_RuntimeType;
    }
    extern "C" {
        #[doc = " Gets the state of the \"USER\" button on the roboRIO.\n\n @param[out] status the error code, or 0 for success\n @return true if the button is currently pressed down"]
        pub fn HAL_GetFPGAButton(status: *mut i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets if the system outputs are currently active\n\n @param[out] status the error code, or 0 for success\n @return true if the system outputs are active, false if disabled"]
        pub fn HAL_GetSystemActive(status: *mut i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets if the system is in a browned out state.\n\n @param[out] status the error code, or 0 for success\n @return true if the system is in a low voltage brown out, false otherwise"]
        pub fn HAL_GetBrownedOut(status: *mut i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Gets a port handle for a specific channel.\n\n The created handle does not need to be freed.\n\n @param channel the channel number\n @return the created port"]
        pub fn HAL_GetPort(channel: i32) -> root::HAL_PortHandle;
    }
    extern "C" {
        #[doc = " Gets a port handle for a specific channel and module.\n\n This is expected to be used for PCMs, as the roboRIO does not work with\n modules anymore.\n\n The created handle does not need to be freed.\n\n @param module  the module number\n @param channel the channel number\n @return the created port"]
        pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> root::HAL_PortHandle;
    }
    extern "C" {
        #[doc = " Reads the microsecond-resolution timer on the FPGA.\n\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n reset)."]
        pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
    }
    extern "C" {
        #[doc = " Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time.\n\n Note: This is making the assumption that the timestamp being converted is\n always in the past.  If you call this with a future timestamp, it probably\n will make it in the past.  If you wait over 70 minutes between capturing the\n bottom 32 bits of the timestamp and expanding it, you will be off by\n multiples of 1<<32 microseconds.\n\n @param[in] unexpandedLower 32 bit FPGA time\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n         reset) as a 64 bit number."]
        pub fn HAL_ExpandFPGATime(unexpandedLower: u32, status: *mut i32) -> u64;
    }
    extern "C" {
        #[doc = " Call this to start up HAL. This is required for robot programs.\n\n This must be called before any other HAL functions. Failure to do so will\n result in undefined behavior, and likely segmentation faults. This means that\n any statically initialized variables in a program MUST call this function in\n their constructors if they want to use other HAL calls.\n\n The common parameters are 500 for timeout and 0 for mode.\n\n This function is safe to call from any thread, and as many times as you wish.\n It internally guards from any reentrancy.\n\n The applicable modes are:\n   0: Try to kill an existing HAL from another program, if not successful,\n error.\n   1: Force kill a HAL from another program.\n   2: Just warn if another hal exists and cannot be killed. Will likely result\n in undefined behavior.\n\n @param timeout the initialization timeout (ms)\n @param mode    the initialization mode (see remarks)\n @return true if initialization was successful, otherwise false."]
        pub fn HAL_Initialize(timeout: i32, mode: i32) -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Call this to shut down HAL.\n\n This must be called at termination of the robot program to avoid potential\n segmentation faults with simulation extensions at exit."]
        pub fn HAL_Shutdown();
    }
    extern "C" {
        #[doc = " Calls registered SimPeriodic \"before\" callbacks (only in simulation mode).\n This should be called prior to user code periodic simulation functions."]
        pub fn HAL_SimPeriodicBefore();
    }
    extern "C" {
        #[doc = " Calls registered SimPeriodic \"after\" callbacks (only in simulation mode).\n This should be called after user code periodic simulation functions."]
        pub fn HAL_SimPeriodicAfter();
    }
    extern "C" {
        #[doc = " Sets up the system to run the provided main loop in the main thread (e.g.\n the thread in which main() starts execution) and run the robot code in a\n separate thread.\n\n Normally the robot code runs in the main thread, but some GUI systems\n require the GUI be run in the main thread.\n\n To be effective, this function must be called before the robot code starts\n the main loop (e.g. by frc::StartRobot()).\n\n @param param parameter data to pass to mainFunc and exitFunc\n @param mainFunc the function to be run when HAL_RunMain() is called.\n @param exitFunc the function to be run when HAL_ExitMain() is called."]
        pub fn HAL_SetMain(
            param: *mut ::std::os::raw::c_void,
            mainFunc: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
            >,
            exitFunc: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
            >,
        );
    }
    extern "C" {
        #[doc = " Returns true if HAL_SetMain() has been called.\n\n @return True if HAL_SetMain() has been called, false otherwise."]
        pub fn HAL_HasMain() -> root::HAL_Bool;
    }
    extern "C" {
        #[doc = " Runs the main function provided to HAL_SetMain().\n\n If HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()\n is called."]
        pub fn HAL_RunMain();
    }
    extern "C" {
        #[doc = " Causes HAL_RunMain() to exit.\n\n If HAL_SetMain() has been called, this calls the exit function provided\n to that function."]
        pub fn HAL_ExitMain();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_3 {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_basic_string_open0_char_char_traits_open1_char_close1_allocator_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_basic_string_view_open0_char_char_traits_open1_char_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::basic_string_view<::std::os::raw::c_char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::basic_string_view<::std::os::raw::c_char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::basic_string_view<::std::os::raw::c_char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::basic_string_view<::std::os::raw::c_char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_duration_open0_int64_t_nano_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::chrono::duration<i64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::chrono::duration<i64>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::chrono::duration<i64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::chrono::duration<i64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_duration_open0_int64_t_micro_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::chrono::duration<i64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::chrono::duration<i64>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::chrono::duration<i64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::chrono::duration<i64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_duration_open0_int64_t_milli_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::chrono::duration<i64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::chrono::duration<i64>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::chrono::duration<i64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::chrono::duration<i64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_base_unit_open0_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_t_open0_second_double_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit_t>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit_t)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unique_ptr_open0_SPI_Accumulator_default_delete_open1_SPI_Accumulator_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::unique_ptr>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::unique_ptr)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_default_delete_open0_SPI_Accumulator_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::default_delete>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::default_delete)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_SendableHelper_open0_ADXRS450_Gyro_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::wpi::SendableHelper>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::wpi::SendableHelper)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::wpi::SendableHelper>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::wpi::SendableHelper)
            )
        );
    }
    pub type rep = ::std::os::raw::c_long;
    #[test]
    fn __bindgen_test_layout_time_point_open0_fpga_clock_duration_open1_long_ratio_open2_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<
                root::std::chrono::time_point<root::std::chrono::duration<::std::os::raw::c_long>>,
            >(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::std::chrono::time_point<
                        root::std::chrono::duration<::std::os::raw::c_long>,
                    >
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::std::chrono::time_point<root::std::chrono::duration<::std::os::raw::c_long>>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::std::chrono::time_point<
                        root::std::chrono::duration<::std::os::raw::c_long>,
                    >
                )
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_duration_open0_long_ratio_open1_close1_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::chrono::duration<::std::os::raw::c_long>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::chrono::duration<::std::os::raw::c_long>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::chrono::duration<::std::os::raw::c_long>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::chrono::duration<::std::os::raw::c_long>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_StringMap_open0_nanoseconds_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::wpi::StringMap>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::wpi::StringMap)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::wpi::StringMap>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::wpi::StringMap)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_base_unit_open0_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_unit_open0_ratio_open1_close1__bindgen_ty_id_119686_open1_ratio_open2_close2_base_unit_open2_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_ratio_open3_close3_close2_ratio_open2_close2_ratio_open2_close2_close1_ratio_open1_close1_ratio_open1_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_base_unit_open0_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_ratio_open1_close1_close0_instantiation_2(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::units::base_unit>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::units::base_unit)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_priority_queue_open0_TimedRobot_Callback_vector_open1_TimedRobot_Callback_allocator_open2_TimedRobot_Callback_close2_close1_greater_open1_TimedRobot_Callback_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::wpi::priority_queue<root::std::vector, root::std::greater>>(
            ),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify ! (root :: wpi :: priority_queue < root :: std :: vector , root :: std :: greater >)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::wpi::priority_queue<root::std::vector, root::std::greater>>(
            ),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify ! (root :: wpi :: priority_queue < root :: std :: vector , root :: std :: greater >)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_TimedRobot_Callback_allocator_open1_TimedRobot_Callback_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_TimedRobot_Callback_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_greater_open0_TimedRobot_Callback_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::greater>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::greater)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::greater>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::greater)
            )
        );
    }
}
